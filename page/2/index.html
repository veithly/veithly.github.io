<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Ricky,邵侠">
<meta name="description" content="曾梦想仗剑走天涯，却发现过安检时被没收了">
<meta name="theme-color" content="#555">
<title>邵侠小站</title>
<link rel="shortcut icon" href="/favicon.ico?v=1661396479638">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>邵侠小站</span>
            </a>  
          
        </div>
        
          <p class="subtitle">曾梦想仗剑走天涯，却发现过安检时被没收了</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item nav-item-active">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Ricky Shao</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">不止前端！</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">30</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">32</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">32</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://ricky.shineteens.com/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  


</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box gemini">
          <section class="section  posts-expand slide-down-in">
            
  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://ricky.shineteens.com/post/tbAaAqNsf/">
      JavaScript｜ES7~ES12常见基础用法
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2022-08-15</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://ricky.shineteens.com/tag/fB0pVEAG4/">
        <span>ES6</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/2BbnUmwOd/">
        <span>JavaScript</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>7分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1554<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <p>ES7~ES12是 ES6 的补充，里面有很多比较灵活的用法可以在日常中使用，如果对 ES6 不太熟悉的可以看看这里：<a href="https://ricky.shineteens.com/post/j9qm98nhv/">JavaScript｜ES6日常用法详解</a></p>
<h2 id="es7-array-includes">ES7 - Array Includes</h2>
<p>在ES7之前，如果我们想判断一个数组中是否包含某个元素，需要通过 indexOf 获取结果，并且判断是否为 -1。 在ES7中，我们可以通过includes来判断一个数组中是否包含一个指定的元素，根据情况，如果包含则返回 true， 否则返回false。<br>
<code>arr.includes(valueToFind[, fromIndex])</code><br>
fromIndex(可选): 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。</p>
<pre><code class="language-js">const arr = [1, 2, 3, 4, 5];
console.log(arr.includes(3)); // true
console.log(arr.includes(6)); // false
console.log(arr.includes(3, 3)); // false
console.log(arr.includes(3, -1)); // true
</code></pre>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://ricky.shineteens.com/post/tbAaAqNsf/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://ricky.shineteens.com/post/7cQbwosME/">
      微服务｜系统应用架构演变
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2022-08-12</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://ricky.shineteens.com/tag/tzlLItuaD/">
        <span>微服务</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/VfSpNRpldr/">
        <span>分布式系统</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/qhk6X1vFr6/">
        <span>系统架构</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>5分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1264<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <h2 id="单体架构">单体架构</h2>
<figure data-type="image" tabindex="1"><img src="https://nas.shineteens.com:9999/i/2022/08/12/62f5fddcc6f67.png" alt="1660288475283.png" loading="lazy"></figure>
<p>单体架构即将所有的业务放在一个项目中开发，作为一个应用部署，这样的架构比较简单，但是不能满足复杂的业务需求。早期互联网产品因为流量小所以靠单体应用也能维持业务，但现在随着业务更加复杂单体应用已经满足不了。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://ricky.shineteens.com/post/7cQbwosME/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://ricky.shineteens.com/post/J9qM98Nhv/">
      JavaScript｜ES6日常用法详解
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2022-08-09</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://ricky.shineteens.com/tag/fB0pVEAG4/">
        <span>ES6</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/2BbnUmwOd/">
        <span>JavaScript</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>16分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>3488<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <p>ES6全称ECMAScript 6.0 ，是JavaScript 的下一个版本标准。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<p>在前文中提到了ES6的新特性——class语法糖的使用。本文来讲讲除了class外ES6～ES12其他的新的特性，如果没有读的可以去看看：<a href="https://ricky.shineteens.com/post/u7zwdeg-m/">JavaScript｜Class定义类</a>。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://ricky.shineteens.com/post/J9qM98Nhv/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://ricky.shineteens.com/post/U7Zwdeg-m/">
      JavaScript｜Class定义类
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2022-08-09</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://ricky.shineteens.com/tag/2BbnUmwOd/">
        <span>JavaScript</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/vwSjS_4RKc/">
        <span>面向对象</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>4分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>785<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <h2 id="认识class和class的构造函数">认识class和class的构造函数</h2>
<p>在之前我讲原型的文章中，按构造函数创建的类不仅和普通的函数相似，还不容易理解。在ES6中，我们可以使用class来定义类，class的本质其实是构造函数的语法糖而已。</p>
<pre><code class="language-javascript">class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  say() {
    console.log(`${this.name} is ${this.age} years old.`);
  }
}

var person = new Person('Tom', 18);

person.say(); // Tom is 18 years old.

console.log(person); // Person { name: 'Tom', age: 18 }
console.log(person.__proto__); // {}
</code></pre>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://ricky.shineteens.com/post/U7Zwdeg-m/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://ricky.shineteens.com/post/3kIqfwJzc/">
      JavaScript｜原型判断
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2022-08-04</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://ricky.shineteens.com/tag/IfGFShXd9/">
        <span>原型链</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/2BbnUmwOd/">
        <span>JavaScript</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>329<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <h2 id="对象是否有属于自己的属性">对象是否有属于自己的属性</h2>
<p>通过hasOwnProperty()方法判断对象是否有属于自己的属性，而不是原型的属性。</p>
<pre><code class="language-javascript">var obj = {
    name: 'obj',
};

var obj1 = Object.create(obj, {
    age: {
        value: 18,
        enumerable: true,
        configurable: true,
        writable: true,
    },
});

console.log(obj1); // { age: 18 }
console.log(obj1.hasOwnProperty('age')); // true
console.log(obj1.hasOwnProperty('name')); // false
</code></pre>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://ricky.shineteens.com/post/3kIqfwJzc/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://ricky.shineteens.com/post/CkpK7rqXL/">
      JavaScript｜对象原型的理解
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2022-08-01</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://ricky.shineteens.com/tag/2BbnUmwOd/">
        <span>JavaScript</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/_7zozl9nc-/">
        <span>对象</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/RMmiODQeM/">
        <span>原型</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>4分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>856<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <h2 id="认识对象的原型">认识对象的原型</h2>
<p>JavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。</p>
<p>那么这个对象有什么用呢？<br>
当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作；<br>
这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它；<br>
如果对象中没有该属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性；</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://ricky.shineteens.com/post/CkpK7rqXL/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://ricky.shineteens.com/post/jvcyCW48G/">
      JavaScript｜对象创建与属性控制
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2022-07-26</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://ricky.shineteens.com/tag/CD1IewxwF/">
        <span>JS</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/vwSjS_4RKc/">
        <span>面向对象</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>7分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1738<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <h2 id="面向对象概念">面向对象概念</h2>
<p>对象是JavaScript中一个非常重要的概念，这是因为对象可以将多个相关联的数据封装到一起，更好的描述一个事物：<br>
比如我们可以描述一辆车：Car，具有颜色（color）、速度（speed）、品牌（brand）、价格（price），行驶（travel）等等；<br>
比如我们可以描述一个人：Person，具有姓名（name）、年龄（age）、身高（height），吃东西（eat）、跑步（run）等等；</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://ricky.shineteens.com/post/jvcyCW48G/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>

  <article class="post-list-box  post box-shadow-wrapper">
    <div class="article-wrapper bg-color">
      <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://ricky.shineteens.com/post/yY0lLI5Ye/">
      OpenVPN｜在局域网里头，才有家的感觉
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2022-07-25</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://ricky.shineteens.com/tag/uZhHBA2HZ/">
        <span>群晖</span>
      </a>、
      
      
      
      <a href="https://ricky.shineteens.com/tag/8lI5Qg-wZU/">
        <span>VPN</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>3分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>702<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
      <div class="post-body">
        
        
          <p>上一篇写了如何用群晖原生的VPN Server搭建OpenVPN回家，这一篇讲讲客户端怎么配置才能连接OpenVPN，并且通过配置能够使用OpenVPN转发某个网段，屏蔽某些ip和网段。</p>

        
        
        <div class="post-button text-center">
          <a class="btn" href="https://ricky.shineteens.com/post/yY0lLI5Ye/" rel="contents">
            阅读全文 »
          </a>
        </div>
        
      </div>
      
    </div>
  </article>
  
            
            
<div class="page bg-color">
  <ul class="pagination-ul">
    
      <li class="pagination-dir">
        <a href="https://ricky.shineteens.com/">
          <i class="fa fa-angle-left"></i>
        </a>
      </li>
    
    
      
        <li class="pagination-li ">
            <a href="/page/../">
              1
            </a>
        </li>
      
        <li class="pagination-li pagination-active">
            <a href="/page/2">
              2
            </a>
        </li>
      
        <li class="pagination-li ">
            <a href="/page/3">
              3
            </a>
        </li>
      
        <li class="pagination-li ">
            <a href="/page/4">
              4
            </a>
        </li>
      
    
    
      <li class="pagination-dir">
        <a href="/page/3">
          <i class="fa fa-angle-right"></i>
        </a>
      </li>
    
  </ul>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="poweredby">
      ©️2021-2022 Ricky版权所有<a href="http://beian.miit.gov.cn/" target="_blank"> 粤ICP备20009350号</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'hijiki'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'Aoba') {
				AIimgSrc.push(message_Path + "model/Aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'Aoba') {
							model = message_Path + "model/Aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/2Xxn7pCb3/"" data-c="
          &lt;h2 id=&#34;框架集合&#34;&gt;框架集合&lt;/h2&gt;
&lt;p&gt;微服务是分布式架构的最佳实践方案，那这种方案它也需要具体的技术框架去落地。所以在全球有很多的互联网公司也都在去尝试开发自己的微服务落地技术。但是在这些技术里，真正广为人知的就是Spring Cloud。Spring Cloud 以微服务为核心的分布式系统构建标准，是一系列框架的有序集合，直至现在，由不同编程语言、不同技术框架所开发的微服务系统中，基于 Spring Cloud 的解决方案仍然是最为主流的选择。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://spring.io/projects/spring-cloud&#34;&gt;Spring Cloud&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://spring.io/projects/spring-cloud-alibaba&#34;&gt;Spring Cloud Alibaba&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fcb02ae2c64.jpg&#34; alt=&#34;62fcb02ae2c64&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;p&gt;Spring Cloud Alibaba的微服务系统可以拆分成图中的架构：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fcb1f47f158.jpg&#34; alt=&#34;62fcb1f47f158&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;除了Spring Cloud，还有一些其他方案的框架可以选用，如:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cloudwego.io/zh/&#34;&gt;CloudWeGo&lt;/a&gt;，是一套由字节跳动开源的、可快速构建企业级云原生微服务架构的中间件集合。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tarscloud.org/&#34;&gt;Tars&lt;/a&gt;，是一套高性能、多语言的微服务治理框架。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dubbo.apache.org/&#34;&gt;Dubbo&lt;/a&gt;，是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案，&lt;br&gt;
涵盖 Java、Golang 等多种语言 SDK 实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/senecajs/seneca&#34;&gt;Seneca&lt;/a&gt;，微服务架构的node.js的工具集。&lt;/p&gt;
&lt;h2 id=&#34;注册发现服务&#34;&gt;注册发现服务&lt;/h2&gt;
&lt;h3 id=&#34;nacos&#34;&gt;Nacos&lt;/h3&gt;
&lt;p&gt;Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://nacos.io/zh-cn/index.html&#34;&gt;Nacos&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;consul&#34;&gt;Consul&lt;/h3&gt;
&lt;p&gt;Consul是一个基于微服务的服务发现和管理工具，可以让我们轻松地管理和发现微服务，并且可以让我们轻松地管理微服务的负载均衡。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.consul.io/&#34;&gt;Consul&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;eureka&#34;&gt;Eureka&lt;/h3&gt;
&lt;p&gt;Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在微服务的中间层服务，以达到负载均衡和中间层服务故障转移的目的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/eureka&#34;&gt;Eureka&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;zookeeper&#34;&gt;Zookeeper&lt;/h3&gt;
&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zookeeper.apache.org/&#34;&gt;ZooKeeper&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;服务之间的通讯&#34;&gt;服务之间的通讯&lt;/h2&gt;
&lt;h3 id=&#34;thift&#34;&gt;thift&lt;/h3&gt;
&lt;p&gt;Apache thift 软件框架，用于可扩展的跨语言服务开发，结合了软件栈和代码生成引擎，可以在 C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk、OCaml 和 Delphi 等语言之间高效、无缝地构建服务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://thrift.apache.org/&#34;&gt;thift&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;grpc&#34;&gt;gRPC&lt;/h3&gt;
&lt;p&gt;GRPC 是一个现代的开源高性能远程过程调用(Remote Process Call，RPC)框架，可以在任何环境中运行。它可以通过可插拔的负载平衡、跟踪、健康检查和身份验证支持，有效地连接数据中心内和数据中心之间的服务。它还适用于物联网设备、移动应用程序和浏览器到后端服务的最后一公里分布式计算。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://grpc.io/&#34;&gt;gRPC&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;dubbo&#34;&gt;Dubbo&lt;/h3&gt;
&lt;p&gt;Dubbo 是一款微服务框架，为微服务提供高性能 RPC 通信，提供 Java、Golang 等语言 SDK 实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dubbo.apache.org/zh/&#34;&gt;Dubbo&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;tars&#34;&gt;Tars&lt;/h3&gt;
&lt;p&gt;Tars 是一个高性能、多语言的微服务治理框架。为微服务提供 RPC 通信，提供C++、Java、Go、JavaScript、php 等语言 SDK 实现，还可以部署在k8s集群上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://tarscloud.org/&#34;&gt;Tars&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;feign&#34;&gt;feign&lt;/h3&gt;
&lt;p&gt;feign是一个RESTful客户端框架，主要用于Java。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/OpenFeign/feign&#34;&gt;feign&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;kitex&#34;&gt;Kitex&lt;/h3&gt;
&lt;p&gt;Kitex 是字节跳动内部的 Golang 微服务 RPC 框架，具有高性能、强可扩展的特点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cloudwego.io/zh/docs/kitex/overview/&#34;&gt;Kitex&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;hertz&#34;&gt;Hertz&lt;/h3&gt;
&lt;p&gt;Hertz 是一个 Golang 微服务 HTTP 框架，在设计之初参考了其他开源框架 fasthttp、gin、echo 的优势， 并结合字节跳动内部的需求，使其具有高易用性、高性能、高扩展性等特点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cloudwego.io/zh/docs/hertz/overview/&#34;&gt;Hertz&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h2&gt;
&lt;h3 id=&#34;ribbon&#34;&gt;Ribbon&lt;/h3&gt;
&lt;p&gt;Ribbon 是一个内置了软件负载平衡器的进程间通信(远程过程调用)库。主要使用模型包括带有各种序列化方案支持的 REST 调用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/ribbon&#34;&gt;Ribbon&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;网关&#34;&gt;网关&lt;/h2&gt;
&lt;h3 id=&#34;spring-cloud-gateway&#34;&gt;Spring Cloud Gateway&lt;/h3&gt;
&lt;p&gt;Spring Cloud Gateway 是一个网关服务，用于将多个服务集成到一个网关服务中，并且提供统一的访问接口。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://spring.io/projects/spring-cloud-gateway&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;zuul&#34;&gt;Zuul&lt;/h3&gt;
&lt;p&gt;Zuul 是一个提供动态路由、监视、弹性、安全等功能的网关服务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/zuul&#34;&gt;Zuul&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;容错保护&#34;&gt;容错保护&lt;/h2&gt;
&lt;h3 id=&#34;sentinel&#34;&gt;Sentinel&lt;/h3&gt;
&lt;p&gt;Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://sentinelguard.io/zh-cn/&#34;&gt;Sentinel&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;hystrix&#34;&gt;Hystrix&lt;/h3&gt;
&lt;p&gt;Hystrix是由Netflflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Netflix/Hystrix&#34;&gt;Hystrix&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;resilience4j&#34;&gt;Resilience4j&lt;/h3&gt;
&lt;p&gt;Resilicence4J一款非常轻量、简单，并且文档非常清晰、丰富的熔断工具，这也是Hystrix官方推荐的替代产品。不仅如此，Resilicence4j还原生支持Spring Boot 1.x/2.x，而且监控也支持和prometheus等多款主流产品进行整合。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/resilience4j/resilience4j&#34;&gt;Resilience4j&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;链路追踪&#34;&gt;链路追踪&lt;/h2&gt;
&lt;h3 id=&#34;zipkin&#34;&gt;Zipkin&lt;/h3&gt;
&lt;p&gt;Zipkin分布式跟踪系统；它可以帮助收集时间数据，解决在微服务架构下的延迟问题；它管理这些数据的收集和查找。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://zipkin.io/&#34;&gt;Zipkin&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;skywalking&#34;&gt;Skywalking&lt;/h3&gt;
&lt;p&gt;Skywalking 是用于分布式系统的应用程序性能监视工具，特别是为微服务、云本地和基于容器(Kubernetes)架构设计的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://skywalking.apache.org/&#34;&gt;Skywalking&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;jaeger&#34;&gt;Jaeger&lt;/h3&gt;
&lt;p&gt;Jaeger 是一个开源端到端分布式跟踪，监视和排除复杂分布式系统中的事务。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jaegertracing.io/&#34;&gt;Jaeger&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;分布式事务&#34;&gt;分布式事务&lt;/h2&gt;
&lt;h3 id=&#34;seata&#34;&gt;Seata&lt;/h3&gt;
&lt;p&gt;Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://seata.io/zh-cn/index.html&#34;&gt;Seata&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;数据存储&#34;&gt;数据存储&lt;/h2&gt;
&lt;h3 id=&#34;minio&#34;&gt;Minio&lt;/h3&gt;
&lt;p&gt;MinIO 提供高性能、 S3兼容的对象存储。原产于 Kubernetes 的 minIO 是唯一可用于所有公共云、Kubernetes 发行版、私有云和边缘储存的对象存储套件。MinIO 在 GNU AGPL v3下是100% 开源的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://min.io/&#34;&gt;Minio&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;服务部署&#34;&gt;服务部署&lt;/h2&gt;
&lt;h3 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h3&gt;
&lt;p&gt;Kubernetes是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。&lt;/p&gt;
&lt;p&gt;在Kubernetes中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://kubernetes.io/&#34;&gt;Kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;docker&#34;&gt;Docker&lt;/h3&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt;&lt;/p&gt;
">微服务｜现有技术框架选型与资料整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/IZaI2U_Lq/"" data-c="
          &lt;p&gt;之前的文章里讲了Promise的好处以及具体应用，不了解Promise用法的读者可以移步到这里：&lt;a href=&#34;https://ricky.shineteens.com/post/lgixxdcqc/&#34;&gt;JavaScript｜Promise使用详解&lt;/a&gt;。这里我们主要来看看Promise是怎么实现的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;promise结构设计&#34;&gt;Promise结构设计&lt;/h2&gt;
&lt;p&gt;如果要实现一个Promise，应该按照Promise A+规范来设计：&lt;a href=&#34;https://promisesaplus.com/&#34;&gt;Promise A+&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;
const PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;
const PROMISE_STATUS_REJECTED = &#39;rejected&#39;

class myPromise{
    constructor(executor) {
        this.status = PROMISE_STATUS_PENDING
        this.value = undefined
        this.reason = undefined

        const resolve = (value) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行
                this.status = PROMISE_STATUS_FULFILLED
                console.log(&#39;resolve called&#39;);
                this.value = value
            }
        }
        const reject = (reason) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) {
                this.status = PROMISE_STATUS_REJECTED
                console.log(&#39;reject called&#39;);
                this.reason = reason
            }
        }
        executor(resolve, reject) // 调用resolve/reject方法
    }
}

const promise = new myPromise((resolve, reject) =&amp;gt; {
    console.log(&#39;执行了&#39;); // 执行了
    resolve() // resolve called
    reject() // 要注意，这里不会调用reject方法
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promisethen方法设计&#34;&gt;Promise.then方法设计&lt;/h2&gt;
&lt;p&gt;Promise.then方法是Promise的核心方法，它的作用是：当Promise的状态变为fulfilled或rejected时，执行then方法的回调函数，但是调用这个方法有需要考虑很多问题，如多次调用，链式调用，以及调用时Promise的状态等等。&lt;/p&gt;
&lt;h3 id=&#34;then方法基本结构&#34;&gt;then方法基本结构&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;
const PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;
const PROMISE_STATUS_REJECTED = &#39;rejected&#39;

class myPromise{
    constructor(executor) {
        this.status = PROMISE_STATUS_PENDING
        this.value = undefined
        this.reason = undefined

        const resolve = (value) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行
                this.status = PROMISE_STATUS_FULFILLED
                queueMicrotask(() =&amp;gt; { // 异步执行，先执行then方法，将onFulfilled方法放入队列中
                    this.value = value
                    this.onfulfilled&amp;amp;&amp;amp;this.onfulfilled(value)
                })
            }
        }
        const reject = (reason) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) {
                this.status = PROMISE_STATUS_REJECTED
                queueMicrotask(() =&amp;gt; {
                    this.reason = reason
                    this.onrejected&amp;amp;&amp;amp;this.onrejected(reason)
                })
            }
        }
        executor(resolve, reject) // 调用resolve/reject方法
    }

    then(onfulfilled, onrejected) {
        this.onfulfilled = onfulfilled
        this.onrejected = onrejected
    }
}

const promise = new myPromise((resolve, reject) =&amp;gt; {
    console.log(&#39;执行了&#39;); // 执行了
    resolve(&#39;res&#39;)
}).then(res =&amp;gt; {
    console.log(res) // res
}, err =&amp;gt; {
    console.log(err)
})

const promise1 = new myPromise((resolve, reject) =&amp;gt; {
    console.log(&#39;执行了&#39;); // 执行了
    reject(&#39;err&#39;)
}).then(res =&amp;gt; {
    console.log(res)
}, err =&amp;gt; {
    console.log(err) // err
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;then方法多次调用&#34;&gt;then方法多次调用&lt;/h3&gt;
&lt;p&gt;上述实现的then虽然能够实现，但如果再次添加then方法的时候会覆盖掉onfulfilled和onrejected，所以需要添加一个多次调用的方法。这里我们将方法加入到数组中，然后遍历数组，执行每一个方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;
const PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;
const PROMISE_STATUS_REJECTED = &#39;rejected&#39;

class myPromise{
    constructor(executor) {
        this.status = PROMISE_STATUS_PENDING
        this.value = undefined
        this.reason = undefined
        this.onfulfilledFns = []
        this.onrejectedFns = []

        const resolve = (value) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行
                queueMicrotask(() =&amp;gt; { // 异步执行，先执行then方法，将onFulfilled方法放入队列中
                    if (this.status !== PROMISE_STATUS_PENDING) return // 如果状态已经变化，则不执行
                    this.status = PROMISE_STATUS_FULFILLED // 设置状态，放在微任务队列可以保证状态变化的时候，不会执行then方法
                    this.value = value
                    this.onfulfilledFns.forEach(fn =&amp;gt; {
                        fn(this.value)
                    })
                })
            }
        }
        const reject = (reason) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) {
                queueMicrotask(() =&amp;gt; {
                    if (this.status !== PROMISE_STATUS_PENDING) return
                    this.status = PROMISE_STATUS_REJECTED
                    this.reason = reason
                    this.onfulfilledFns.forEach(fn =&amp;gt; {
                        fn(this.reason)
                    })
                })
            }
        }
        executor(resolve, reject) // 调用resolve/reject方法
    }

    then(onfulfilled, onrejected) {
        // 调用then时，状态确，例如setTimeout(() =&amp;gt; {}, 0)，那么就会立即执行onfulfilled方法，而不是将方法放入队列中
        if (this.status === PROMISE_STATUS_FULFILLED) {
            onfulfilled(this.value)
        } else if (this.status === PROMISE_STATUS_REJECTED) {
            onrejected(this.reason)
        } 
        // 将成功回调和失败回调放入数组中
        if (this.status === PROMISE_STATUS_PENDING) {
            this.onfulfilledFns.push(onfulfilled)
            this.onrejectedFns.push(onrejected)
        }
    }
}

const promise = new myPromise((resolve, reject) =&amp;gt; {
    console.log(&#39;执行了&#39;); // 执行了
    resolve(&#39;res&#39;)
    reject(&#39;err&#39;)
})

// 调用then方法多次调用
promise.then(res =&amp;gt; {
  console.log(&amp;quot;res1:&amp;quot;, res)
}, err =&amp;gt; {
  console.log(&amp;quot;err:&amp;quot;, err)
})

promise.then(res =&amp;gt; {
  console.log(&amp;quot;res2:&amp;quot;, res)
}, err =&amp;gt; {
  console.log(&amp;quot;err2:&amp;quot;, err)
})

// 在确定Promise状态之后, 再次调用then
setTimeout(() =&amp;gt; {
  promise.then(res =&amp;gt; {
    console.log(&amp;quot;res3:&amp;quot;, res)
  }, err =&amp;gt; {
    console.log(&amp;quot;err3:&amp;quot;, err)
  })
}, 1000)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;then方法的链式调用&#34;&gt;then方法的链式调用&lt;/h3&gt;
&lt;p&gt;上述实现的then方法多次调用，但如果在一个then后面再次调用then方法，则会报错，原因是then没有返回，我们需要在then函数中添加一个返回值，返回一个新的myPromise对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;
const PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;
const PROMISE_STATUS_REJECTED = &#39;rejected&#39;

// 抽离try catch函数储存返回值
function execFunctionWithCatchError(execFn, value, resolve, reject) {
    try {
        const reason = execFn(value)
        resolve(reason)   
    } catch (error) {
        reject(error)
    }
}

class myPromise{
    constructor(executor) {
        this.status = PROMISE_STATUS_PENDING
        this.value = undefined
        this.reason = undefined
        this.onfulfilledFns = []
        this.onrejectedFns = []

        const resolve = (value) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行
                queueMicrotask(() =&amp;gt; { // 异步执行，先执行then方法，将onFulfilled方法放入队列中
                    if (this.status !== PROMISE_STATUS_PENDING) return // 如果状态已经变化，则不执行
                    this.status = PROMISE_STATUS_FULFILLED // 设置状态，放在微任务队列可以保证状态变化的时候，不会执行then方法
                    this.value = value
                    this.onfulfilledFns.forEach(fn =&amp;gt; {
                        fn(this.value)
                    })
                })
            }
        }
        const reject = (reason) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) {
                queueMicrotask(() =&amp;gt; {
                    if (this.status !== PROMISE_STATUS_PENDING) return
                    this.status = PROMISE_STATUS_REJECTED
                    this.reason = reason
                    this.onrejectedFns.forEach(fn =&amp;gt; {
                        fn(this.reason)
                    })
                })
            }
        }
        try { // 第一个promise可能报错，报错信息需要通过REJECT方法传递给第二个promise
            executor(resolve, reject) // 调用resolve/reject方法
        } catch (err) {
            reject(err)
        }
    }

    then(onfulfilled, onrejected) {
        return new myPromise((resolve, reject) =&amp;gt; { // 直接返回这个promise，如果没有then会直接执行
            // 调用then时，状态确，例如setTimeout(() =&amp;gt; {}, 0)，那么就会立即执行onfulfilled方法，而不是将方法放入队列中
            if (this.status === PROMISE_STATUS_FULFILLED &amp;amp;&amp;amp; resolve) {
                // try { //回调函数需要获取结果或者报错，所以需要try catch
                //     const value = onfulfilled(this.value)
                //     resolve(value)
                // } catch (error) {
                //     reject(error)
                // }
                execFunctionWithCatchError(onfulfilled, this.value, resolve, reject)
            } else if (this.status === PROMISE_STATUS_REJECTED &amp;amp;&amp;amp; onrejected) {
                execFunctionWithCatchError(onrejected, this.reason, resolve, reject)
            } 
            // 将成功回调和失败回调放入数组中
            if (this.status === PROMISE_STATUS_PENDING) {
                this.onfulfilledFns.push(() =&amp;gt; {
                    execFunctionWithCatchError(onfulfilled, this.value, resolve, reject)
                })
                this.onrejectedFns.push(() =&amp;gt; {
                    execFunctionWithCatchError(onrejected, this.reason, resolve, reject)
                })
            }
        })
    }
}

const promise = new myPromise((resolve, reject) =&amp;gt; {
    console.log(&#39;执行了&#39;); // 执行了
    resolve(&#39;res&#39;)
    reject(&#39;err&#39;)
})

// 调用then方法多次调用
promise.then(res =&amp;gt; {
  console.log(&amp;quot;res1:&amp;quot;, res)
  return &amp;quot;aaaa&amp;quot;
  // throw new Error(&amp;quot;err message&amp;quot;)
}, err =&amp;gt; {
  console.log(&amp;quot;err1:&amp;quot;, err)
  return &amp;quot;bbbbb&amp;quot;
  // throw new Error(&amp;quot;err message&amp;quot;)
}).then(res =&amp;gt; {
  console.log(&amp;quot;res2:&amp;quot;, res)
}, err =&amp;gt; {
  console.log(&amp;quot;err2:&amp;quot;, err)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promisecatch方法设计&#34;&gt;Promise.catch方法设计&lt;/h2&gt;
&lt;p&gt;Promise.catch方法是Promise.prototype.then方法的简化版本，当Promise的状态变为rejected时，会调用参数函数，并将Promise的reason作为参数传入函数。在这里可以直接调用then方法来实现吗，除了调用then，还需要设置相关的边界条件处理undefined，并且要确保resolve和reject方法的返回值能够被下一个方法捕获到。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;
const PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;
const PROMISE_STATUS_REJECTED = &#39;rejected&#39;

// 抽离try catch函数储存返回值
function execFunctionWithCatchError(execFn, value, resolve, reject) {
    try {
        const reason = execFn(value)
        resolve(reason)   
    } catch (error) {
        reject(error)
    }
}

class myPromise{
    constructor(executor) {
        this.status = PROMISE_STATUS_PENDING
        this.value = undefined
        this.reason = undefined
        this.onfulfilledFns = []
        this.onrejectedFns = []

        const resolve = (value) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行
                queueMicrotask(() =&amp;gt; { // 异步执行，先执行then方法，将onFulfilled方法放入队列中
                    if (this.status !== PROMISE_STATUS_PENDING) return // 如果状态已经变化，则不执行
                    this.status = PROMISE_STATUS_FULFILLED // 设置状态，放在微任务队列可以保证状态变化的时候，不会执行then方法
                    this.value = value
                    this.onfulfilledFns.forEach(fn =&amp;gt; {
                        fn(this.value)
                    })
                })
            }
        }
        const reject = (reason) =&amp;gt; {
            if (this.status === PROMISE_STATUS_PENDING) {
                queueMicrotask(() =&amp;gt; {
                    if (this.status !== PROMISE_STATUS_PENDING) return
                    this.status = PROMISE_STATUS_REJECTED
                    this.reason = reason
                    this.onrejectedFns.forEach(fn =&amp;gt; {
                        fn(this.reason)
                    })
                })
            }
        }
        try { // 第一个promise可能报错，报错信息需要通过REJECT方法传递给第二个promise
            executor(resolve, reject) // 调用resolve/reject方法
        } catch (err) {
            reject(err)
        }
    }

    then(onfulfilled, onrejected) {
        // catch 传入 undefined 会抛出异常，让 promise 去调用下一个 reject
        const defaultOnRejected = err =&amp;gt; {throw err}
        onrejected = onrejected || defaultOnRejected
        // resolve 也需要返回
        const defaultOnFulfilled = value =&amp;gt; { value }
        onfulfilled = onfulfilled || defaultOnFulfilled

        return new myPromise((resolve, reject) =&amp;gt; { // 直接返回这个promise，如果没有then会直接执行
            // 调用then时，状态确，例如setTimeout(() =&amp;gt; {}, 0)，那么就会立即执行onfulfilled方法，而不是将方法放入队列中
            if (this.status === PROMISE_STATUS_FULFILLED &amp;amp;&amp;amp; onfulfilled) {
                //回调函数需要获取结果或者报错，所以需要try catch
                execFunctionWithCatchError(onfulfilled, this.value, resolve, reject)
            } 
            if (this.status === PROMISE_STATUS_REJECTED &amp;amp;&amp;amp; onrejected) {
                execFunctionWithCatchError(onrejected, this.reason, resolve, reject)
            } 
            // 将成功回调和失败回调放入数组中
            if (this.status === PROMISE_STATUS_PENDING) {
                // catch 会传入 undefined
                if (onfulfilled) this.onfulfilledFns.push(() =&amp;gt; {
                    execFunctionWithCatchError(onfulfilled, this.value, resolve, reject)
                })
                if (onrejected) this.onrejectedFns.push(() =&amp;gt; {
                    execFunctionWithCatchError(onrejected, this.reason, resolve, reject)
                })
            }
        })
    }

    catch(onrejected) {
        return this.then(undefined, onrejected) // 将实例返回出来，以便下一个方法调用
    }
}

const promise = new myPromise((resolve, reject) =&amp;gt; {
    console.log(&#39;执行了&#39;); // 执行了
    // resolve(&#39;res&#39;)
    reject(&#39;err&#39;)
})

// 调用catch方法
promise.then(res =&amp;gt; {
  console.log(&amp;quot;res:&amp;quot;, res)
}).catch(err =&amp;gt; {
  console.log(&amp;quot;err:&amp;quot;, err) // err: err
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promisefinally方法设计&#34;&gt;Promise.finally方法设计&lt;/h2&gt;
&lt;p&gt;Promise.finally的实现可以直接在将then方法下的两个参数传入finally的方法实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;class myPromise{
    //...其余方法同上，注意catch方法
    finally(onFinally) {
        this.then(() =&amp;gt; onFinally(), () =&amp;gt; onFinally())
    }
}

const promise = new myPromise((resolve, reject) =&amp;gt; {
    console.log(&#39;执行了&#39;); // 执行了
    resolve(&#39;res&#39;)
}).then((res) =&amp;gt; {
    console.log(&amp;quot;res:&amp;quot;, res) // res: res
}).catch((err) =&amp;gt; {
    console.log(&amp;quot;err:&amp;quot;, err)
}).finally(() =&amp;gt; {
    console.log(&amp;quot;finally&amp;quot;) // finally
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promiseresolve-promisereject方法直接实现&#34;&gt;Promise.resolve &amp;amp;&amp;amp; Promise.reject方法直接实现&lt;/h2&gt;
&lt;p&gt;通过设置静态函数来 new 一个新的 promise 就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;class myPromise{
    //...其余方法同上
    static resolve(value) {
        return new myPromise((resolve, reject) =&amp;gt; {
            resolve(value)
        })
    }
    static reject(reason) {
        return new myPromise((resolve, reject) =&amp;gt; {
            reject(reason)
        })
    }
}

myPromise.resolve(&#39;Hello World&#39;).then(res =&amp;gt; {
    console.log(&amp;quot;res:&amp;quot;, res) // res: Hello World
})

myPromise.reject(&#39;err&#39;).catch(err =&amp;gt; {
    console.log(&amp;quot;err:&amp;quot;, err) // err: err
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promiseall-promiseallsettled方法实现&#34;&gt;Promise.all &amp;amp;&amp;amp; Promise.allSettled方法实现&lt;/h2&gt;
&lt;p&gt;两个方法都是通过对数组进行遍历，分别执行Promise，但不同的是：Promise.allSettled返回的是一个数组，数组中的每一项是一个Promise的状态，而Promise.all返回的是一个Promise，Promise.all返回的Promise的状态是数组中所有Promise的状态的并集。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;class myPromise {
    // ...其余方法同上
    static all(promises) {
        return new myPromise((resolve, reject) =&amp;gt; {
            let result = []
            promises.forEach(promise =&amp;gt; {
                promise.then(
                res =&amp;gt; {
                    result.push(res)
                    // 如果数组中的所有Promise都执行完毕，则执行resolve
                    if (result.length === promises.length) {
                        resolve(result)
                    }
                }),
                // 如果数组中的某一个Promise执行失败，则执行reject
                err =&amp;gt; {
                    reject(err)
                })
            })
        })
    }

    static allSettled(promises) {
        return new myPromise((resolve, reject) =&amp;gt; {
            let result = []
            promises.forEach(promise =&amp;gt; {
                // 对每个结果进行分类，分为fulfilled和rejected，加入到数组中
                promise.then(
                res =&amp;gt; {
                    result.push({status: &#39;fulfilled&#39;, value: res})
                    if (result.length === promises.length) {
                        resolve(result)
                    }
                }),
                err =&amp;gt; {
                    result.push({status: &#39;rejected&#39;, reason: err})
                    if (result.length === promises.length) {
                        resolve(result)
                    }
                })
            })
        })
    }
}

const p1 = new myPromise((resolve) =&amp;gt; {
  setTimeout(() =&amp;gt; { resolve(1111) }, 1000)
})
const p2 = new myPromise((resolve, reject) =&amp;gt; {
  setTimeout(() =&amp;gt; { reject(2222) }, 2000)
})
const p3 = new myPromise((resolve) =&amp;gt; {
  setTimeout(() =&amp;gt; { resolve(3333) }, 3000)
})

myPromise.all([p1, p2, p3]).then(res =&amp;gt; {
  console.log(&amp;quot;res:&amp;quot;, res) // res: [ 1111, 2222, 3333 ]
})

myPromise.allSettled([p1, p2, p3]).then(res =&amp;gt; {
  console.log(&amp;quot;res:&amp;quot;, res) // res: [ { status: &#39;fulfilled&#39;, value: 1111 }, { status: &#39;rejected&#39;, reason: 2222 }, { status: &#39;fulfilled&#39;, value: 3333 } ]
})

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promiserace-promiseany-方法设计&#34;&gt;Promise.race &amp;amp;&amp;amp; Promise.any 方法设计&lt;/h2&gt;
&lt;p&gt;两个方法都是直接执行第一个可以执行Promise，区别在于：race执行到第一个就可以返回，any则需要等待一个resolve才可以返回，否则返回reject:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;class myPromise {
    // ...同上
    static race(promises) {
        return new myPromise((resolve, reject) =&amp;gt; {
            promises.forEach(promise =&amp;gt; {
                // promise.then(res =&amp;gt; {
                //   resolve(res)
                // }, err =&amp;gt; {
                //   reject(err)
                // })
                promise.then(resolve, reject)
            })
        })
    }

    static any(promises) {
        // resolve必须等到有一个成功的结果
        // reject所有的都失败才执行reject
        const reasons = []
        return new myPromise((resolve, reject) =&amp;gt; {
            promises.forEach(promise =&amp;gt; {
                promise.then(resolve, err =&amp;gt; {
                    // 如果有一个Promise执行成功，则执行resolve
                    reasons.push(err)
                    if (reasons.length === promises.length) {
                        reject(new AggregateError(reasons))
                    }
                })
            })
        })
    }
}

const p1 = new myPromise((resolve) =&amp;gt; {
  setTimeout(() =&amp;gt; { resolve(1111) }, 1000)
})

const p2 = new myPromise((resolve, reject) =&amp;gt; {
  setTimeout(() =&amp;gt; { reject(2222) }, 2000)
})

const p3 = new myPromise((resolve) =&amp;gt; {
  setTimeout(() =&amp;gt; { resolve(3333) }, 3000)
}).

myPromise.race([p1, p2, p3]).then(res =&amp;gt; {
    console.log(res); // 111
})

myPromise.any([p1, p2, p3]).then(res =&amp;gt; {
    console.log(res); // 111
})
&lt;/code&gt;&lt;/pre&gt;
">JavaScript｜手写Promise</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/LGIXxDcQC/"" data-c="
          &lt;h2 id=&#34;promise-之前实现异步的弊端&#34;&gt;Promise 之前实现异步的弊端&lt;/h2&gt;
&lt;p&gt;首先看一个例子，再没有Promise之前，实现一个网络异步请求：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function requestData(url, successCallback, failtureCallback) {
    // 模拟网络请求
    setTimeout(() =&amp;gt; {
        // 获取请求结果
        // url 传入的是 ricky 则请求成功，否则请求失败
        if (url === &#39;ricky&#39;) {
            let res = {
                name: &#39;ricky&#39;,
                age: 18
            };
            successCallback(res);
        } else {
            let error = &#39;请求失败&#39;;
            failtureCallback(error);
        }
    }, 3000);
}

requestData(&#39;ricky&#39;, (res) =&amp;gt; {
    console.log(res);
} , (error) =&amp;gt; {
    console.log(error);
} );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种实现方法有很多弊端：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是我们自己封装的requestData,那么我们在封装的时候必须要自己设计好callback名称, 并且使用好&lt;/li&gt;
&lt;li&gt;如果我们使用的是别人封装的requestData或者一些第三方库, 那么我们必须去看别人的源码或者文档, 才知道它这个函数需要怎么去获取到结果&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;什么是-promise&#34;&gt;什么是 Promise&lt;/h2&gt;
&lt;p&gt;当我们需要给予调用者一个承诺：待会儿我会给你回调数据时，就可以创建一个Promise的对象；&lt;/p&gt;
&lt;p&gt;在通过new创建Promise对象时，我们需要传入一个回调函数，我们称之为executor&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个回调函数会被立即执行，并且给传入另外两个回调函数resolve、reject；&lt;/li&gt;
&lt;li&gt;当我们调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数；&lt;/li&gt;
&lt;li&gt;当我们调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过Promise改进的异步请求方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function requestData(url) {
    // 模拟网络请求
    return new Promise((resolve, reject) =&amp;gt; {
        setTimeout(() =&amp;gt; {
            // 获取请求结果
            // url 传入的是 ricky 则请求成功，否则请求失败
            if (url === &#39;ricky&#39;) {
                let res = {
                    name: &#39;ricky&#39;,
                    age: 18
                };
                resolve(res);
            } else {
                let error = &#39;请求失败&#39;;
                reject(error);
            }
        }, 3000);
    });
}

requestData(&#39;ricky&#39;).then((res) =&amp;gt; 
    console.log(res), (err) =&amp;gt; 
    console.log(err)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promise-三种状态&#34;&gt;Promise 三种状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pending: 初始状态，表示Promise对象正在处理状态，还未完成&lt;/li&gt;
&lt;li&gt;fulfilled: 表示Promise对象已经成功处理，当执行resolve方法时，Promise对象的状态就会变为fulfilled&lt;/li&gt;
&lt;li&gt;rejected: 表示Promise对象已经处理失败，当执行reject方法时，Promise对象的状态就会变为rejected&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const promise = new Promise((resolve, reject) =&amp;gt; {
    // 调用resolve方法, then 传入回调执行
    resolve(&#39;successCallback&#39;)
    // 调用reject方法, catch 传入回调执行
    reject(&#39;errorCallback&#39;)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;resolve-传参区别&#34;&gt;resolve 传参区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果resolve传入一个普通的值或者对象，那么这个值会作为then回调的参数；&lt;/li&gt;
&lt;li&gt;如果resolve传入一个Promise对象，那么这个Promise对象的状态就会被设置为当前Promise对象的状态；&lt;/li&gt;
&lt;li&gt;如果resolve传入一个有then方法的对象，那么这个对象的then方法就会被调用，并且传入的参数就是当前Promise对象的状态；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 传入Promise对象
const newPromise = new Promise((resolve, reject) =&amp;gt; {
  reject(&amp;quot;err message&amp;quot;)
})

new Promise((resolve, reject) =&amp;gt; {
  // pending -&amp;gt; fulfilled
  resolve(newPromise)
}).then(res =&amp;gt; {
  console.log(&amp;quot;res:&amp;quot;, res)
}, err =&amp;gt; {
  console.log(&amp;quot;err:&amp;quot;, err) // err: err message
})

// 传入有then方法的对象
new Promise((resolve, reject) =&amp;gt; {
  // pending -&amp;gt; fulfilled
  const obj = {
    then: function(resolve, reject) {
      // resolve(&amp;quot;resolve message&amp;quot;)
      reject(&amp;quot;reject message&amp;quot;)
    }
  }
  resolve(obj)
}).then(res =&amp;gt; {
  console.log(&amp;quot;res:&amp;quot;, res)
}, err =&amp;gt; {
  console.log(&amp;quot;err:&amp;quot;, err) // err: reject message
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;then-方法&#34;&gt;then 方法&lt;/h2&gt;
&lt;p&gt;then是Promise对象上的方法，在Promise原型上的Promise.prototype.then&lt;/p&gt;
&lt;h3 id=&#34;两个参数&#34;&gt;两个参数&lt;/h3&gt;
&lt;p&gt;then方法接受两个参数，分别是resolve和reject，当Promise对象的状态变为fulfilled时，会执行resolve，当Promise对象的状态变为rejected时，会执行reject&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;promise.then(res =&amp;gt; {
    console.log(res);
}, err =&amp;gt; {
    console.log(err);
})

// 等价于
promise.then(res =&amp;gt; {
    console.log(res);
}).catch(err =&amp;gt; {
    console.log(err);
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多次调用&#34;&gt;多次调用&lt;/h3&gt;
&lt;p&gt;Promise对象的then方法可以被多次调用，每次调用我们都可以传入对应的fulfilled回调；当Promise的状态变成fulfilled的时候，这些回调函数都会被执行；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const promise = new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        resolve(&#39;success&#39;)
    }, 1000);
})

promise.then(res1 =&amp;gt; {
    console.log(&#39;res1:&#39;, res1);
})

promise.then(res2 =&amp;gt; {
    console.log(&#39;res2:&#39;, res2);
})

promise.then(res3 =&amp;gt; {
    console.log(&#39;res3:&#39;, res3);
})
// 上述三个结果都在同一时间打印
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;then方法的返回值&#34;&gt;then方法的返回值&lt;/h3&gt;
&lt;p&gt;then方法的返回值是一个新的Promise对象，这个新的Promise对象的状态和原来的Promise对象保持一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// resolve情况
promise.then(res =&amp;gt; {
    console.log(&#39;res:&#39;, res); // res: success
    return &#39;res success&#39;
}).then(res =&amp;gt; console.log(res), err =&amp;gt; console.log(err)) // res success
// reject情况
promise.then(res =&amp;gt; {
    console.log(&#39;res:&#39;, res); // res: success
    throw &#39;res err&#39;
}).then(res =&amp;gt; console.log(res), err =&amp;gt; console.log(err)) // res err
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;catch-方法&#34;&gt;catch 方法&lt;/h2&gt;
&lt;p&gt;catch方法是then方法的另一个版本，用于指定rejected的回调函数，当Promise对象的状态变为rejected时，会执行rejected&lt;/p&gt;
&lt;h3 id=&#34;多次调用-2&#34;&gt;多次调用&lt;/h3&gt;
&lt;p&gt;Promise对象的catch也可以进行多次调用，每次调用都会执行对应的回调函数；当Promise的状态变成rejected的时候，这些回调函数都会被执行；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 同样会在promise对象的状态变为rejected的时候同时执行
promise.catch(err =&amp;gt; console.log(&amp;quot;err1:&amp;quot; err))
promise.catch(err =&amp;gt; console.log(&amp;quot;err2:&amp;quot; err))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;catch返回值&#34;&gt;catch返回值&lt;/h3&gt;
&lt;p&gt;catch方法的返回值也是一个新的Promise对象，这个新的Promise对象的状态和原来的Promise对象保持一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;promise.catch(err =&amp;gt; {
    console.log(&#39;err:&#39;, err); // err: err message
    return err
}).then(res =&amp;gt; {
    console.log(&#39;res:&#39;, res); // 执行此处
}).catch(err =&amp;gt; {
    console.log(err);
})

promise.catch(err =&amp;gt; {
    console.log(&#39;err:&#39;, err); // err: err message
    throw err
}).then(res =&amp;gt; {
    console.log(&#39;res:&#39;, res);
}).catch(err =&amp;gt; {
    console.log(err); // 执行此处
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;finally-方法&#34;&gt;finally 方法&lt;/h2&gt;
&lt;p&gt;finally方法是then方法的另一个版本，用于指定无论Promise对象最后状态如何，都会执行的回调函数。finally方法是不接收参数的，因为无论前面是fulfilled状态，还是reject状态，它都会执行。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;promise.then(res =&amp;gt; {
    console.log(&#39;res:&#39;, res); // res: success
}).catch(err =&amp;gt; {
    console.log(&#39;err:&#39;, err);
}).finally(() =&amp;gt; {
    console.log(&#39;finally&#39;); // finally
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;resolve-reject-方法&#34;&gt;resolve &amp;amp; reject 方法&lt;/h2&gt;
&lt;p&gt;有时候我们已经有一个现成的内容了，希望将其转成Promise来使用，这个时候我们可以使用 Promise.resolve/Promise.reject 方法来完成。&lt;/p&gt;
&lt;p&gt;Promise.resolve的用法相当于new Promise，并且执行resolve操作，可以传递除了普通值或对象、Promise和thenable对象作为参数。&lt;/p&gt;
&lt;p&gt;Promise.reject的用法也相当于new Promise，并且执行reject操作，可以传递任何形态的参数，这些参数都会直接作为reject状态的参数传递到catch。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;Promise.resolve(&#39;success&#39;) 

// 相当于

new Promise((resolve, reject) =&amp;gt; {
    resolve(&#39;success&#39;)
})

Promise.reject(&#39;err&#39;)

// 相当于

new Promise((resolve, reject) =&amp;gt; {
    reject(&#39;err&#39;)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promiseall方法&#34;&gt;Promise.all方法&lt;/h2&gt;
&lt;p&gt;Promise.all方法用于将多个Promise对象，包装成一个新的Promise对象。&lt;/p&gt;
&lt;p&gt;新的Promise状态由包裹的所有Promise共同决定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当所有的Promise状态变成fulfilled状态时，新的Promise状态为fulfilled，并且会将所有Promise的返回值组成一个数组；&lt;/li&gt;
&lt;li&gt;当有一个Promise状态为reject时，新的Promise状态为reject，并且会将第一个reject的返回值作为参数；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const r1 = new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        resolve(&#39;r1 success&#39;)
    }, 1000);
})

const r2 = new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        resolve(&#39;r2 success&#39;)
    }, 1500);
})

const r3 = new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        resolve(&#39;r3 success&#39;)
    }, 2000);
})

const e1 = new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        reject(&#39;e1 error&#39;)
    }, 1000);
})

const e2 = new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
        reject(&#39;e2 error&#39;)
    }, 2000);
})

Promise.all([r1, r2, r3]).then(res =&amp;gt; {
    console.log(res); // [ &#39;r1 success&#39;, &#39;r2 success&#39;, &#39;r3 success&#39; ]
})

Promise.all([r1, r2, r3, e1, e2]).then(res =&amp;gt; {
    console.log(res);
}).catch(err =&amp;gt; {
    console.log(err); // e1 error
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promiseallsettled-方法&#34;&gt;Promise.allSettled 方法&lt;/h2&gt;
&lt;p&gt;all方法有一个缺点：如果一个Promise变成reject状态，那么其他的Promise也会变成reject状态，并且不会再执行then方法。无法获取已经resolved状态的Promise。ES11中新增了allSettled方法，用于解决这个问题。该方法会在所有的Promise都有结果（settled），无论是fulfilled，还是reject时，都有最终的状态，并且这个Promise的结果一定是fulfilled的。&lt;/p&gt;
&lt;p&gt;返回的Promise的结果是一个数组，数组中的每一项都是一个Promise的结果，包含status状态以及对应的value值，数组的顺序与传入的Promise数组的顺序一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;Promise.allSettled([r1, r2, r3, e1, e2]).then(res =&amp;gt; {
    console.log(res); // [ { status: &#39;fulfilled&#39;, value: &#39;r1 success&#39; }, { status: &#39;fulfilled&#39;, value: &#39;r2 success&#39; }, { status: &#39;fulfilled&#39;, value: &#39;r3 success&#39; }, { status: &#39;rejected&#39;, reason: &#39;e1 error&#39; }, { status: &#39;rejected&#39;, reason: &#39;e2 error&#39; } ]
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promiserace方法&#34;&gt;Promise.race方法&lt;/h2&gt;
&lt;p&gt;如果有一个Promise有了结果，我们就希望决定最终新Promise的状态，那么可以使用race方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;Promise.race([r1, r2, r3]).then(res =&amp;gt; {
    console.log(res); // r1 success
}) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promiseany方法&#34;&gt;Promise.any方法&lt;/h2&gt;
&lt;p&gt;any方法是ES12中新增的方法，和race方法是类似的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;any方法会等到一个fulfilled状态，才会决定新Promise的状态&lt;/li&gt;
&lt;li&gt;如果所有的Promise都是reject的，那么也会等到所有的Promise都变成rejected状态&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;Promise.any([r1, r2, r3, e1, e2]).then(res =&amp;gt; {
    console.log(res); // &#39;r1 success&#39;
})

Promise.any([e1, e2]).then(res =&amp;gt; {
    console.log(res);
}) 
// 报错：Error: All promises were rejected
&lt;/code&gt;&lt;/pre&gt;
">JavaScript｜Promise使用详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/369HPigUO/"" data-c="
          &lt;h2 id=&#34;认识微服务&#34;&gt;认识微服务&lt;/h2&gt;
&lt;p&gt;微服务其实是一种架构风格，我们在开发一个应用的时候这个应用应该是由一组小型服务组成，每个小型服务都运行在自己的进程内；小服务之间通过 HTTP 的方式进行互联互通。&lt;/p&gt;
&lt;h3 id=&#34;扩展性&#34;&gt;扩展性&lt;/h3&gt;
&lt;p&gt;在单体应用中，如果要对模块进行扩展，那么需要对所有模块进行扩展。比如一个电商系统，我可能只需要扩展秒杀服务，但是在单体应用下进行扩展时其他功能也会扩展，会造成大量的资源浪费。而利用微服务可以只扩展响应服务即可。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;每一个服务都是一个 web 应用，我们可以对它进行独立的部署。就比如说这个服务它的访问压力比较大，我们就可以对他进行水平的扩展。就比如说关于他这一组的服务都访问压力比较大，我们可以给他们放在一组，把他归类在一组进行水平的扩展。这样带来的一个性能的优化是最佳的。并且他们的容错率是要比我们之前的单体应用的容错率是要更高的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9adb47302d.jpg&#34; alt=&#34;62f9adb47302d&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;隔离性强&#34;&gt;隔离性强&lt;/h3&gt;
&lt;p&gt;在我们单体应用当中，比如说我一个不相关的一个功能，它出现了 OOM 内存溢出，那么会导致我整个应用都不可用了。&lt;/p&gt;
&lt;p&gt;那么在我们的微服务架构当中，由于我们所有的这个服务都是单独的一个 web 应用都是单独一个进程。那么假如说我是一个这个电商系统，比方说是一个电商系统，比如说积分服务它挂掉了，那么它是不影响我继续去进行购买的，不影响我商品浏览，然后下单支付等等这些主要的流程操作的。我的整个应用依然能够正常的使用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9ace963dd4.jpg&#34; alt=&#34;62f9ace963dd4&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;微服务带来的问题&#34;&gt;微服务带来的问题&lt;/h2&gt;
&lt;p&gt;那么我们一个微服务架构，我们可以看到经过拆分，经过更细粒度更彻底的一个拆分之后，我们的这个服务会变得非常非常的多，每一个节点都是一个服务，并且经过水平的扩展、负载均衡之后，它们之间的一个调用链路会变得更加的错综的复杂。&lt;/p&gt;
&lt;p&gt;一个业务功能之中，一般都会涉及到好几个功能模块。那么经过我们的微服务一拆分之后，有可能就会变到变成几个微服务，甚至十几个微服务。那么一一负载均衡。那甚至涉及到几十个微服务之间的相互交友。那么这么多微服务之间的调用肯定会出现一系列的问题。那么我们怎么去解决这些问题呢？&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9b3253c072.jpg&#34; alt=&#34;62f9b3253c072&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;服务治理&#34;&gt;服务治理&lt;/h3&gt;
&lt;p&gt;首先是这么多服务，如何进行管理？比如说我的订单服务，要去调用我的库存服务，有可能还要调用商品服务，然后有可能还要去调用积分服务等等。&lt;/p&gt;
&lt;p&gt;那么这个时候我要去调用这些服务，我是不是得知道他们的一个远程服务的地址，因为不同的服务都是部署在不同的服务器，他们可能都有不同的一个 IP。那么我要调用他们是不是得知道他们的一个 IP 然后进行远程的调用？他们这些 IP 是不是会频繁的变化。就比如说库存，那么今天他的这个访问压力比较大，那么我给他换一台这个性能不是这么好的服务器，我给他换一台 IP 就变了。然后我商品可能我今天压力比较大，我给他换一台性能比较好的服务器。或者说我今天我商品压力比较大，我给他水平扩展几个，那么 IP 又多了几个。那么这些远程服务地址的 IP 我都维护在订单这里的话是不是相当麻烦，因为他们会频繁地变化。所以说在我们的微服务架构当中，就引入了一个微服务治理组件，叫做注册中心。那么这个注册中心它就可以去管理我们所有的服务，我们会将这些服务都注册到这个注册中心当中。&lt;/p&gt;
&lt;p&gt;去注册的时候，我们提供一个名字，比如说订单是 order ，比如说商品是 product ，那么订单我去调用商品的时候，我只要知道这个商品服务的名字（product），就可以直接去调用这个服务。这样就有效的去管理了我们这些服务。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9b54b3cf0c.jpg&#34; alt=&#34;62f9b54b3cf0c&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;通讯&#34;&gt;通讯&lt;/h3&gt;
&lt;p&gt;服务拆分后，服务之间的通信就不能像单体应用那样能够通过函数调用的方法进行调用了，因为函数调用是基于进程的，所以我们的服务之间是不能直接通信的。所以我们需要一个通信的框架，来实现我们的服务之间的通信。RPC和Rest是微服务最常见的两种协议，微服务内部通信一般采用RPC或者Rest进行通信，对于客户端来说主要采取Rest来进行交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rest&lt;/strong&gt;：严格的说接口很规范，操作对象即为资源，对资源的四种操作(post、get、put、delete)，并且参数都放在 URL 上。不严格的说 Http+json、Http+xml，常见的 http api 都可以称为 Rest 接口。在微服务中，可以选用 springBoot&lt;br&gt;
restTemplate 或者 feign 进行 Rest 接口的开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RPC&lt;/strong&gt;：常说的远程方法调用，就是像调用本地方法一样调用远程方法，通信协议大多采用二进制方式。RPC通常基于TCP实现，常用框架例如dubbo，netty、mina、thrift。&lt;/p&gt;
&lt;p&gt;两者之间的差异如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9b9e00b4f2.jpg&#34; alt=&#34;62f9b9e00b4f2&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;微服务网关&#34;&gt;微服务网关&lt;/h3&gt;
&lt;p&gt;不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端会多次请求不同的微服务，增加了客户端的复杂性&lt;/li&gt;
&lt;li&gt;存在跨域请求，在一定场景下处理相对复杂&lt;/li&gt;
&lt;li&gt;认证复杂，每个服务都需要独立认证&lt;/li&gt;
&lt;li&gt;难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施&lt;/li&gt;
&lt;li&gt;某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，我们需要通过配置微服务网关来实现客户端的访问。微服务网关是一个网关，它可以将一个或多个微服务集成到一个应用中，并且可以将这些微服务之间的调用进行转发，从而实现微服务之间的调用。&lt;/p&gt;
&lt;p&gt;也就是在我们调用微服务的时候，它会为我们路由到不同的一个组件到路由到不同的一个服务当中去，从而为我们去把守我们整个微服务的一个大门。微服务也是中心化的，但是它不是强行的要求你去使用。&lt;/p&gt;
&lt;p&gt;就比如说你也可以点对点的直接去访问我某一个服务，这是没有问题的。并且假如说我网关突然挂掉了，我也可以采用降级的方式降级去访问我这个服务，也就是说我不去访问网关了，我去访问我具体的那个服务。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fc91c397a33.jpg&#34; alt=&#34;62fc91c397a33&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;容错策略&#34;&gt;容错策略&lt;/h3&gt;
&lt;p&gt;在微服务中，每一个服务或者部署微服务的集群并非完全可靠的，如果一个服务挂掉了，那么可能会影响整个调用链路的正常运行，这时候我们需要实现容错策略，来解决这个问题：&lt;/p&gt;
&lt;p&gt;容错的设计是为了解决这些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个依赖服务出现故障不会严重破坏用户体验&lt;/li&gt;
&lt;li&gt;一个依赖服务出现故障不会影响到其他服务&lt;/li&gt;
&lt;li&gt;一个依赖服务出现故障不会影响到系统的可用性&lt;/li&gt;
&lt;li&gt;系统能过具备自动处理故障的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用的微服务容错策略包括如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;隔离：线程池隔离和信号隔离&lt;/li&gt;
&lt;li&gt;超时：超过最大响应时间则释放进程&lt;/li&gt;
&lt;li&gt;限流：限制服务的调用频率&lt;/li&gt;
&lt;li&gt;熔断：熔断服务，当服务出现故障时，将服务降级到熔断状态，熔断状态下不再调用服务，直到服务恢复正常为止&lt;/li&gt;
&lt;li&gt;降级：当服务出现故障时，提供其他服务的替代服务&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fc97d1927be.jpg&#34; alt=&#34;62fc97d1927be&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;链路追踪&#34;&gt;链路追踪&lt;/h3&gt;
&lt;p&gt;在微服务中，一个外部请求往往涉及到多个服务之间的调用，这些调用可能会出现跨越多个模块、多个中间件、多个服务器……如果一个调用出现问题，我们需要对各个服务进行排查，这需要花费大量的时间精力去排查，所以我们需要一个方法来追踪调用的链路来方便我们对请求调用进行追溯。&lt;/p&gt;
&lt;p&gt;衡量一个接口，我们一般会看三个指标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口的 RT（Route-Target）是什么？&lt;/li&gt;
&lt;li&gt;接口是否有异常响应?&lt;/li&gt;
&lt;li&gt;接口请求慢在哪里?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般在系统发生问题时，比如系统异常或者系统性能出现问题时，通常都是从系统记录的日志文件中找出蛛丝马脚，而对于微服务架构下的分布式部署，日志文件的分散，想从日志中查找问题工作量很大。对于用户某一次请求调用后端哪些服务，每个服务执行情况，想从日志中获得更是不可能的事。&lt;/p&gt;
&lt;p&gt;对于传统的监控告警平台也紧针对平台资源的监控包括cpu、内存、网络带宽情况等，对业务微服务应用的指标（平均响应时间、慢端点情况等）的监控显得无从下手。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fc9f650411b.jpg&#34; alt=&#34;62fc9f650411b&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fc9f264e765.jpg&#34; alt=&#34;62fc9f264e765&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;相关资料推荐&#34;&gt;相关资料推荐&lt;/h2&gt;
&lt;p&gt;这个文档对理解微服务和分布式架构有很大的帮助：&lt;br&gt;
&lt;a href=&#34;http://icyfenix.cn/&#34;&gt;凤凰架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里云提供了脚手架和实验室还有教程，可以边动手边学习：&lt;br&gt;
&lt;a href=&#34;https://start.aliyun.com/&#34;&gt;知行动手实验室&lt;/a&gt;&lt;/p&gt;
">微服务｜概念认识与相关问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/ylCQIx8xP/"" data-c="
          &lt;p&gt;很多前端 JavaScript 框架，包含但不限于（Angular，React，Vue）都拥有自己的响应式方法，而这些方法其实都是基于监听对象来实现的，这里我们来看看监听对象实现响应式的原理。&lt;/p&gt;
&lt;h2 id=&#34;objectdefineproperty-监听对象&#34;&gt;Object.defineProperty 监听对象&lt;/h2&gt;
&lt;p&gt;如果需要监听对象的属性变化，可以使用&lt;strong&gt;Object.defineProperty&lt;/strong&gt;的存储属性描述符的方法来监听。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const obj = {
  a: 1,
  b: 2,
  c: 3
}

// 监听一个属性的变化
Object.defineProperty(obj, &#39;a&#39;, {
  set(val) {
    console.log(&#39;a set&#39;, val)
  },
  get() {
    console.log(&#39;a get&#39;)
    return this.a
  }
})
&amp;lt;!-- more --&amp;gt;
// 监听所有属性的变化
Object.keys(obj).forEach(key =&amp;gt; {
    let val = obj[key]
    Object.defineProperty(obj, key, {
        get() {
            console.log(key, &#39;get&#39;)
            return val
        },
        set(newVal) {
            console.log(key, &#39;set&#39;, newVal)
            val = newVal
        },
    })
});

console.log(obj.a) // a get 1
obj.a = 2 // a set 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但通过Object.defineProperty会带来很多问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果需要监听对象的增删操作，这个方法就会失效&lt;/li&gt;
&lt;li&gt;定义属性时，所有的普通属性都会强行变成属性描述符&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;存储数据描述符设计的初衷并不是为了去监听一个完整的对象。&lt;/p&gt;
&lt;h2 id=&#34;proxy的基本使用&#34;&gt;Proxy的基本使用&lt;/h2&gt;
&lt;p&gt;在ES6中，新增了&lt;strong&gt;Proxy类&lt;/strong&gt;，用于为对象创建一个代理：&lt;br&gt;
如果我们希望监听一个对象的相关操作，可以先创建一个代理对象(Proxy)，然后将相关操作都在代理对象上完成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const obj = {
  a: 1,
  b: 2,
  c: 3
}

const proxy = new Proxy(obj, {
    get(target, key) {
        console.log(&#39;get&#39;, key)
        return target[key]
    },
    set(target, key, val) {
    console.log(&#39;set&#39;, key, val)
    target[key] = val
    },
    has(target, key) {
        console.log(&#39;has&#39;, key)
        return key in target
    },
    deleteProperty(target, key) {
        console.log(&#39;delete&#39;, key)
        delete target[key]
    }
})

console.log(proxy.a); // get a 1
proxy.a = 2; // set a 2
console.log(&#39;b&#39; in proxy); // has b true
delete proxy.c // delete c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Proxy除了可以代理对象外，还能代理函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function foo() {
  
}

const proxy = new Proxy(foo, {
    apply(target, thisArg, argArray) {
        console.log(&#39;apply&#39;)
        return target.apply(thisArg, argArray)
    },
    construct(target, argArray) {
        console.log(&#39;construct&#39;)
        return new target(...argArray)
    },
})

proxy.apply({}, [1, 2]) // apply
new proxy(&#39;1&#39;,&#39;2&#39;) // construct
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Proxy有很多捕获器方法，具体可以查阅MDN文档&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy&#34;&gt;proxy&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;reflect基本使用&#34;&gt;Reflect基本使用&lt;/h2&gt;
&lt;p&gt;Reflect也是ES6新增的一个API，它是一个对象，它主要提供了很多操作JavaScript对象的方法，有点像Object中操作对象的方法：比如Reflect.getPrototypeOf(target)类似于 Object.getPrototypeOf()； Reflect.defineProperty(target, propertyKey, attributes)类似于Object.defineProperty()……&lt;/p&gt;
&lt;p&gt;为什么要有Reflect呢？早期ECMA规范中没有考虑到这种对&lt;strong&gt;对象本身&lt;/strong&gt;的操作如何设计会更加规范，所以将这些API放到了Object上面。但是&lt;strong&gt;Object作为一个构造函数，这些操作实际上放到它身上并不合适&lt;/strong&gt;。另外还包含一些类似于 in、delete操作符，让JS看起来是会有一些奇怪的。所以在ES6中新增了Reflect，让我们这些操作都集中到了Reflect对象上。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods&#34;&gt;比较Reflect和Object&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect&#34;&gt;Reflect API&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 将之前代理转换成Reflect使用
const obj = {
  a: 1,
  b: 2,
  c: 3
}

const proxy = new Proxy(obj, {
    get(target, key, receiver) {
        console.log(&#39;get&#39;, key)
        return Reflect.get(target, key, receiver)
    },
    set(target, key, val, receiver) {
        console.log(&#39;set&#39;, key, val)
        return Reflect.set(target, key, val, receiver)
    },
    has(target, key) {
        console.log(&#39;has&#39;, key)
        return Reflect.has(target, key)
    },
    deleteProperty(target, key) {
        console.log(&#39;delete&#39;, key)
        return Reflect.deleteProperty(target, key)
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;receiver的作用&#34;&gt;Receiver的作用&lt;/h3&gt;
&lt;p&gt;receiver的参数，它的作用是什么呢？如果我们的源对象（obj）有setter、getter的访问器属性，那么可以通过receiver来改变里面的this。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function Student(name, age) {
    this.name = name
    this.age = age
}

function Teacher() {}

const teacher = Reflect.construct(Student, [&#39;Tom&#39;, 18], Teacher)
console.log(teacher); // Teacher { name: &#39;Tom&#39;, age: 18 }
console.log(teacher instanceof Teacher) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;响应式原理&#34;&gt;响应式原理&lt;/h2&gt;
&lt;h3 id=&#34;响应式的定义&#34;&gt;响应式的定义&lt;/h3&gt;
&lt;p&gt;响应式是指，当一个对象的属性发生变化时，会自动触发对应的方法。&lt;/p&gt;
&lt;p&gt;变量响应式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let a = 10
// 需要执行的代码
console.log(a)
console.log(a * 2)
// 当a发生变化时上面代码需要再次执行
a = 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对象响应式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let obj = {
    a: 1,
    b: 2,
    c: 3
}

console.log(obj.a); // obj.a 改变时需要再次执行
console.log(obj.b); // obj.b 改变时需要再次执行
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;响应式函数的封装&#34;&gt;响应式函数的封装&lt;/h3&gt;
&lt;p&gt;通过创建一个数组收集变量触发需要执行的方法，然后在每次变量发生变化时，遍历数组，调用所有变量的响应式方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let fns = []
function watchFn(fn) {
    fns.push(fn)
}

const obj = {
    a: 1,
    b: 2,
    c: 3
}

watchFn(function() {
    console.log(obj.a)
})

watchFn(function() {
    console.log(obj.b)
}
// 变量改变时触发该函数
fns.forEach(fn =&amp;gt; fn())
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;依赖收集封装&#34;&gt;依赖收集封装&lt;/h3&gt;
&lt;p&gt;上述的方法在对多个对象做监听的时候，每创建一个对象都需要创建一个数组和方法，这样会比较麻烦。可以通过将该方法封装成一个类去实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;class Dep {
    constructor() {
        this.subs = []
    }
    addSub(sub) {
        this.subs.push(sub)
    }
    notify() {
        this.subs.forEach(sub =&amp;gt; sub.update())
    }
}

const obj = {
    a: 1,
    b: 2,
    c: 3
}

const dep = new Dep()

dep.addSub(function() {
    console.log(obj.a)
})

dep.addSub(function() {
    console.log(obj.b)
})

// 变量改变时触发该函数
dep.notify()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;自动监听对象的变化&#34;&gt;自动监听对象的变化&lt;/h3&gt;
&lt;p&gt;收集好依赖函数后，对象变化时如何触发相关依赖？我们可以通过proxy来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 沿用上个例子的代码
const proxy = new Proxy(obj, {
    get(target, key, receiver) {
        return Reflect.get(target, key, receiver)
    },
    set(target, key, val, receiver) {
        Reflect.set(target, key, val, receiver)
        dep.notify()
    }
})

proxy.a = 10 // 触发dep.notify() -&amp;gt; 10 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;依赖的管理&#34;&gt;依赖的管理&lt;/h3&gt;
&lt;p&gt;我们目前是创建了一个Depend对象，用来管理对于obj变化需要监听的响应函数：但是实际开发中我们会有不同的对象，另外会有不同的属性需要管理；我们如何可以使用一种数据结构来管理不同对象的不同依赖关系呢？&lt;/p&gt;
&lt;p&gt;在前面关于ES6的文章中我提到过WeakMap，并且在学习WeakMap的时候我讲到了后面通过WeakMap如何管理这种响应式的数据依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 依赖封装
class Depend {
  constructor() {
      this.reactiveFns = []
  }
  addDepend(reactiveFn) {
      this.reactiveFns.push(reactiveFn)
  }
  notify() {
      this.reactiveFns.forEach(reactiveFn =&amp;gt; reactiveFn())
  }
}

// 响应式函数封装
let activeReactFn = null
function watchFn(reactiveFn) {
  activeReactFn = reactiveFn
  reactiveFn()
  activeReactFn = null
}

// 封装一个获取depend函数
const targetMap = new WeakMap()
function getDepend(target, key) {
  // 根据target获取map
  let map = targetMap.get(target)
  if (!map) {
    map = new Map()
    targetMap.set(target, map)
  }
  // 根据target获取map中的depend对象
  let depend = map.get(key) 
  if (!depend) {
      depend = new Depend()
      map.set(key, depend)
  }
  return depend
}

// 对象案例
const obj = {
  name: &#39;张三&#39;,
  age: 18
}

// 监听代理
const objProxy = new Proxy(obj, {
  get: function (target, key, receiver) {
      // 获取depend对象
      const depend = getDepend(target, key)
      // 添加响应函数
      depend.addDepend(activeReactFn)
      // 返回值
      return Reflect.get(target, key, receiver)
  },
  set: function (target, key, val, receiver) {
      Reflect.set(target, key, val, receiver)
      // 获取depend对象
      const depend = getDepend(target, key)
      // 响应函数
      depend.notify()
  }
})

watchFn(function() {
  console.log(&#39;React Name&#39;)
  console.log(objProxy.name)
})

watchFn(function() {
  console.log(&#39;React Age&#39;)
  console.log(objProxy.age)
})

objProxy.name = &#39;李四&#39; // 只会触发 React Name 李四，不会触发 React Age 18
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;依赖管理重构&#34;&gt;依赖管理重构&lt;/h3&gt;
&lt;p&gt;上述的方法可以针对对象的某个变量完成响应式，但是如果响应式函数中变量被调用两次，那么这个函数会被收集两次，可以通过Set来解决这个问题，还可以将get的收集依赖方法放在Dep内部，避免混淆：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 对上述两个方法进行改进
// 依赖封装
class Depend {
  constructor() {
        this.reactiveFns = new Set()
  }
  addDepend() {
        if (activeReactiveFn)
        this.reactiveFns.add(activeReactiveFn)
  }
  notify() {
        this.reactiveFns.forEach(reactiveFn =&amp;gt; reactiveFn())
  }
}

// 监听代理
const objProxy = new Proxy(obj, {
  get: function (target, key, receiver) {
      // 获取depend对象
      const depend = getDepend(target, key)
      // 添加响应函数
      depend.addDepend()
      // 返回值
      return Reflect.get(target, key, receiver)
  },
  set: function (target, key, val, receiver) {
      Reflect.set(target, key, val, receiver)
      // 获取depend对象
      const depend = getDepend(target, key)
      // 响应函数
      depend.notify()
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实现vue3vue2响应式&#34;&gt;实现Vue3/Vue2响应式&lt;/h3&gt;
&lt;p&gt;通过上面的原理，再利用闭包的特性，可以实现Vue的响应式方法：&lt;/p&gt;
&lt;p&gt;Vue3是通过Proxy实现响应式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// vue3 reactive
function reactive(obj) {
    return new Proxy(obj, {
        get: function (target, key, receiver) {
            // 获取depend对象
            const depend = getDepend(target, key)
            // 添加响应函数
            depend.addDepend()
            // 返回值
            return Reflect.get(target, key, receiver)
        },
        set: function (target, key, val, receiver) {
            Reflect.set(target, key, val, receiver)
            // 获取depend对象
            const depend = getDepend(target, key)
            // 响应函数
            depend.notify()
        }
    })
}

const info = reactive({
    name: &#39;张三&#39;,
    age: 18
})

watchFn(function() {
    console.log(&#39;React Name&#39;)
    console.log(info.name)
})

info.name = &#39;李四&#39; // React Name 李四
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Vue2是通过Object.defineProperty实现响应式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// vue2 reactive
function reactive(obj) {
    Object.keys(obj).forEach(key =&amp;gt; {
        let value = obj[key]
        Object.defineProperty(obj, key, {
        get: function (target, key, receiver) {
            // 获取depend对象
            const depend = getDepend(target, key)
            // 添加响应函数
            depend.addDepend()
            // 返回值
            return Reflect.get(target, key, receiver)
            },
        set: function (target, key, val, receiver) {
            Reflect.set(target, key, val, receiver)
            // 获取depend对象
            const depend = getDepend(target, key)
            // 响应函数
            depend.notify()
            }
        })
    })
    return obj
}

const info = reactive({
    name: &#39;张三&#39;,
    age: 18
})

watchFn(function() {
    console.log(&#39;React Name&#39;)
    console.log(info.name)
})

info.name = &#39;李四&#39; // React Name 李四
&lt;/code&gt;&lt;/pre&gt;
">JavaScript｜监听对象与响应式原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/vvOUWDU7T/"" data-c="
          &lt;h2 id=&#34;题目介绍&#34;&gt;题目介绍&lt;/h2&gt;
&lt;p&gt;给你一个字符串 s，找到 s 中最长的回文子串。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;babad&amp;quot;
输出：&amp;quot;bab&amp;quot;
解释：&amp;quot;aba&amp;quot; 同样是符合题意的答案。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;cbbd&amp;quot;
输出：&amp;quot;bb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;br&gt;
s 仅由数字和英文字母组成&lt;/p&gt;
&lt;h3 id=&#34;tags&#34;&gt;Tags&lt;/h3&gt;
&lt;p&gt;string | dynamic-programming&lt;/p&gt;
&lt;h3 id=&#34;companies&#34;&gt;Companies&lt;/h3&gt;
&lt;p&gt;amazon | bloomberg | microsoft&lt;/p&gt;
&lt;h2 id=&#34;题解&#34;&gt;题解&lt;/h2&gt;
&lt;p&gt;这道题是一道经典的动态规划题，需要用到动态规划的思想。&lt;/p&gt;
&lt;p&gt;首先是判断回文串，通过比较中心的两个字符是否相等来判断。可以在利用双指针来实现，先从两端开始遍历，如果两个字符相等，则继续向中心移动，不相等则返回false，遍历结束返回true。因为第二个指针相对于第一个指针是镜像的，所以第二个指针可以可以直接用&lt;code&gt;字符串长度 - 第一个指针位置 - 1&lt;/code&gt;实现。&lt;/p&gt;
&lt;p&gt;其次是对整体的字符串进行遍历，找出最长的字符串。从第二个开始遍历，当然要进行一个边界条件判断，只有一个字符的时候，直接返回即可。这里也是利用双指针进行遍历，第一个指针位置从头遍历到尾，下一个指针从头遍历到第一个指针的位置之前的一位，获取一个临时字符串进行判断，如果临时字符串是回文串，则更新最长回文串。这里可以这样优化，将第二个指针放在最大最大回文串长度之前，这样可以减少遍历的次数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/*
 * @lc app=leetcode.cn id=5 lang=javascript
 *
 * [5] 最长回文子串
 */

// @lc code=start
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    // 回文串判断
    function judge(tmp) {
        const len = tmp.length;
        const mid = Math.floor(len / 2);
        // 奇偶字符串都遍历一半就好了，中间的字符可以无视
        for (let i = 0; i &amp;lt; mid; i++) {
            if (tmp[i] != tmp[len - 1 - i]) return false;
        }
        return true;
    }

    let len = s.length;
    // 边界条件，只有一个字符的时候，直接返回即可
    if (len &amp;lt;= 1) return s;
    // 存储最长回文串，第一项为长度第二项为字符串
    let maxRes = [1, s[0]];
    // 从第二个开始遍历
    for (let i = 1; i &amp;lt; len;i++) {
        for (let j = 0; j &amp;lt; i; j++) {
            let dif = i - j + 1;
            // 如果截取的字符串长度小于最大长度，则跳过
            if (dif &amp;lt;= maxRes[0]) break;
            let tmpArray = s.slice(j, i + 1);
            // 判断回文串，如果是回文串，则更新最长回文串
            if(judge(tmpArray) &amp;amp;&amp;amp; dif &amp;gt; maxRes[0]) {
                maxRes[0] = dif;
                maxRes[1] = tmpArray;
            }
        }
    }
    return maxRes[1];
};
&lt;/code&gt;&lt;/pre&gt;
">LeetCode 05.最长回文子串 动态规划</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/tbAaAqNsf/"" data-c="
          &lt;p&gt;ES7~ES12是 ES6 的补充，里面有很多比较灵活的用法可以在日常中使用，如果对 ES6 不太熟悉的可以看看这里：&lt;a href=&#34;https://ricky.shineteens.com/post/j9qm98nhv/&#34;&gt;JavaScript｜ES6日常用法详解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;es7-array-includes&#34;&gt;ES7 - Array Includes&lt;/h2&gt;
&lt;p&gt;在ES7之前，如果我们想判断一个数组中是否包含某个元素，需要通过 indexOf 获取结果，并且判断是否为 -1。 在ES7中，我们可以通过includes来判断一个数组中是否包含一个指定的元素，根据情况，如果包含则返回 true， 否则返回false。&lt;br&gt;
&lt;code&gt;arr.includes(valueToFind[, fromIndex])&lt;/code&gt;&lt;br&gt;
fromIndex(可选): 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const arr = [1, 2, 3, 4, 5];
console.log(arr.includes(3)); // true
console.log(arr.includes(6)); // false
console.log(arr.includes(3, 3)); // false
console.log(arr.includes(3, -1)); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;es7-指数乘方-exponentiation运算符&#34;&gt;ES7 –指数(乘方) exponentiation运算符&lt;/h2&gt;
&lt;p&gt;在ES7之前，计算数字的乘方需要通过 Math.pow 方法来完成。 在ES7中，增加了 ** 运算符，可以对数字来计算乘方。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(2 ** 3); // 8
console.log(2 ** -3); // 0.125
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es8-object-values&#34;&gt;ES8 Object values&lt;/h2&gt;
&lt;p&gt;之前我们可以通过 Object.keys 获取一个对象所有的key，在ES8中提供了 Object.values 来获取所有的value值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const obj = {
  a: 1,
  b: 2,
  c: 3
};

console.log(Object.values(obj)); // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es8-object-entries&#34;&gt;ES8 Object Entries&lt;/h2&gt;
&lt;p&gt;通过Object.entries可以获取到一个数组，数组中会存放可枚举属性的键值对数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const obj = {
  a: 1,
  b: 2,
  c: 3
};

console.log(Object.entries(obj)); // [[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es8-string-padstart和padend&#34;&gt;ES8 String PadStart和PadEnd&lt;/h2&gt;
&lt;p&gt;某些字符串我们需要对其进行前后的填充，来实现某种格式化效果，ES8中增加了 padStart 和 padEnd 方法，分别是对字符串的首尾进行填充的。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const str = &#39;hello&#39;;
console.log(str.padStart(10, &#39;hi&#39;)); // &#39;hihello&#39;
console.log(str.padEnd(10, &#39;hi&#39;)); // &#39;hellohi&#39;

// 小场景：对银行卡实现位数隐藏
const card = &#39;1234 1234 1234 1234&#39;;
const lastFour = card.slice(-4);
const masked = lastFour.padStart(card.length, &#39;*&#39;);

console.log(masked); // &#39;************1234&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es8-trailing-commas&#34;&gt;ES8 - Trailing Commas&lt;/h2&gt;
&lt;p&gt;在 ES8 中，我们可以通过在函数参数的最后一个元素后面添加逗号来让 JavaScript 忽略最后一个参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function log(a, b, c,) {
  console.log(a, b, c);
}

log(1, 2, 3); // 1 2 3
log(1, 2, 3, 4); // 1 2 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es10-flat-flatmap&#34;&gt;ES10 - flat flatMap&lt;/h2&gt;
&lt;p&gt;flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。&lt;/p&gt;
&lt;p&gt;flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。&lt;/p&gt;
&lt;p&gt;注意一：flatMap是先进行map操作，再做flat的操作；&lt;br&gt;
注意二：flatMap中的flat相当于深度为1；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const arr = [1, 2, 3, [4, 5], 6, [7, [8, 9]]];

console.log(arr.flat()); // [1, 2, 3, 4, 5, 6, 7, [8, 9]]
console.log(arr.flat(2)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

const arr2 = [&#39;a b c&#39;, &#39;d e f&#39;, &#39;g h i&#39;];
console.log(arr2.flatMap(x =&amp;gt; x.split(&#39; &#39;))); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es10-object-fromentries&#34;&gt;ES10 - Object fromEntries&lt;/h2&gt;
&lt;p&gt;ES8提供了对象转换方法Object.fromEntries，可以将一个键值对数组转换为对象，如果有entries怎么转换成对象呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const entries = [[&#39;name&#39;, &#39;张三&#39;], [&#39;age&#39;, 18]];
const obj = Object.fromEntries(entries);
console.log(obj); // {name: &#39;张三&#39;, age: 18}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es10-trimstart-trimend&#34;&gt;ES10 - trimStart trimEnd&lt;/h2&gt;
&lt;p&gt;去除一个字符串首尾的空格，我们可以通过trim方法，如果单独去除前面或者后面呢？&lt;br&gt;
ES10中给我们提供了trimStart和trimEnd；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const str = &#39;  hello  &#39;;
console.log(str.trimStart()); // &#39;hello  &#39;
console.log(str.trimEnd()); // &#39;  hello&#39;
console.log(str.trim()); // &#39;hello&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es11-bigint&#34;&gt;ES11 - BigInt&lt;/h2&gt;
&lt;p&gt;BigInt是一个新的数据类型，它可以表示一个大的整数，比如 JavaScript 中的整数只能表示到 2^53 之间，BigInt 可以表示到 2^1024 之间。BitInt的表示方法是在数值的后面加上n。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const int = 2 ** 53;
console.log(int) // 9007199254740992
console.log(int + 1); // 9007199254740992 无法直接加1，因为这个数超过了2的53次方

const bigInt = BigInt(9007199254740993);
console.log(bigInt); // 9007199254740993n
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es11-nullish-coalescing-operator&#34;&gt;ES11 - Nullish Coalescing Operator&lt;/h2&gt;
&lt;p&gt;ES11，Nullish Coalescing Operator增加了空值合并操作符：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const a = undefined;

const r1 = a ?? &#39;default&#39;;
console.log(r1); // &#39;default&#39;

const r2 = a || &#39;default&#39;;
console.log(r2); // &#39;default&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es11-optional-chaining&#34;&gt;ES11 - Optional Chaining&lt;/h2&gt;
&lt;p&gt;ES11，Optional Chaining增加了对象属性的可选调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const obj = {
  a: {
    b: {
      c: &#39;hello&#39;
    }
  }
};

if (obj.a &amp;amp;&amp;amp; obj.a.b &amp;amp;&amp;amp; obj.a.b.c) {
  console.log(obj.a.b.c); // &#39;hello&#39;
}

console.log(obj?.a?.b?.c); // &#39;hello&#39;
console.log(obj?.a?.b?.d); // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es11-global-this&#34;&gt;ES11 - Global This&lt;/h2&gt;
&lt;p&gt;在之前我们希望获取JavaScript环境的全局对象，不同的环境获取的方式是不一样的：比如在浏览器中可以通过this、window来获取，在Node中我们需要通过global来获取……那么在ES11中对获取全局对象进行了统一的规范：globalThis：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;console.log(global); // &amp;lt;ref *1&amp;gt; Object [global]  {...}
console.log(this); // Window {...}
console.log(globalThis); // Window {...}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es12-finalizationregistry&#34;&gt;ES12 - FinalizationRegistry&lt;/h2&gt;
&lt;p&gt;FinalizationRegistry是一个新的对象，用于管理对象的清理工作，它可以在可以让你在对象被垃圾回收时请求一个回调。&lt;br&gt;
FinalizationRegistry 提供了这样的一种方法：当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。（清理回调有时被称为 finalizer ）; 你可以通过调用register方法，注册任何你想要清理回调的对象，传入该对象和所含的值;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;const registry = new FinalizationRegistry(
  (target) =&amp;gt; {
    console.log(&#39;对象被销毁&#39;, target); // &amp;lt;ref *2&amp;gt; Object {...}
  }
);

const obj = {name: &#39;张三&#39;};
registry.register(obj, &#39;hello&#39;);

obj = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es12-weakrefs&#34;&gt;ES12 - WeakRefs&lt;/h2&gt;
&lt;p&gt;WeakRefs是一个新的对象，用于管理对象的弱引用，如果我们默认将一个对象赋值给另外一个引用，那么这个引用是一个强引用：如果我们希望是一个弱引用的话，可以使用WeakRef；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javaScript&#34;&gt;const obj = {name: &#39;张三&#39;};

const weakRef = new WeakRef(obj);

weakRef.name = &#39;李四&#39;;

console.log(obj.name); // 张三
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;es12-logical-assignment-operators&#34;&gt;ES12 - logical assignment operators&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;||= 逻辑或赋值运算&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let message = &amp;quot;hello world&amp;quot;
message = message || &amp;quot;default value&amp;quot; // &amp;quot;hello world&amp;quot;
message ||= &amp;quot;default value&amp;quot; // &amp;quot;hello world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&amp;amp;&amp;amp;= 逻辑与赋值运算&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let message = &amp;quot;hello world&amp;quot;
message = message &amp;amp;&amp;amp; &amp;quot;default value&amp;quot; // &amp;quot;default value&amp;quot;
message &amp;amp;&amp;amp;= &amp;quot;default value&amp;quot; // &amp;quot;default value&amp;quot;

let info = { name: &#39;张三&#39; };
info &amp;amp;&amp;amp;= info.name; // &amp;quot;张三&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;??= 逻辑或赋值运算&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;let message = &amp;quot;hello world&amp;quot;
message ??= &amp;quot;default value&amp;quot; // &amp;quot;hello world&amp;quot;
let blank = &#39;&#39;
blank ??= &amp;quot;default value&amp;quot; // &amp;quot;default value&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
">JavaScript｜ES7~ES12常见基础用法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/7cQbwosME/"" data-c="
          &lt;h2 id=&#34;单体架构&#34;&gt;单体架构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f5fddcc6f67.png&#34; alt=&#34;1660288475283.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;单体架构即将所有的业务放在一个项目中开发，作为一个应用部署，这样的架构比较简单，但是不能满足复杂的业务需求。早期互联网产品因为流量小所以靠单体应用也能维持业务，但现在随着业务更加复杂单体应用已经满足不了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;比如说一个电商系统，里面会包含很多用户管理，商品管理，订单管理，物流管理等等很多模块，我们会把它们做成一个web项目，然后部署到一台tomcat服务器上。&lt;/p&gt;
&lt;p&gt;单体架构优点：单体架构比较简单，部署和维护成本低。&lt;/p&gt;
&lt;p&gt;单体架构缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单体架构不能满足复杂的业务需求，需要更多的资源和时间来开发复杂的应用。&lt;/li&gt;
&lt;li&gt;模块之间紧密耦合，单点容错率低&lt;/li&gt;
&lt;li&gt;无法很好地针对不同模块进行性能优化和扩展&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f605e44f950.png&#34; alt=&#34;1660290532080.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;垂直应用架构&#34;&gt;垂直应用架构&lt;/h2&gt;
&lt;p&gt;随着访问量的逐渐增大，单一应用只能依靠增加节点来应对，但是这时候会发现并不是所有的模块都会有比较大的访问量。还是以上面的电商为例子，用户访问量的增加可能影响的只是用户和订单模块，但是对消息模块的影响就比较小. 那么此时我们希望只多增加几个订单模块，而不增加消息模块. 此时单体应用就做不到了，垂直应用就应运而生了。&lt;/p&gt;
&lt;p&gt;垂直应用架构是一种更加灵活的架构，它将业务模块划分成多个独立的项目，每个项目都是一个独立的应用，这样的架构比较灵活。&lt;/p&gt;
&lt;p&gt;例如一个单体应用的电商系统可以拆分成：电商系统(用户管理 商品管理 订单管理)、后台系统(用户管理 订单管理 客户管理)、CMS系统(广告管理 营销管理)&lt;/p&gt;
&lt;p&gt;这样拆分完毕之后，一旦用户访问量变大，只需要增加电商系统的节点就可以了，而无需增加后台和CMS的节点。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统拆分实现了流量分担，解决了并发问题，而且可以针对不同模块进行优化和水扩展&lt;/li&gt;
&lt;li&gt;一个系统的问题不会影响到其他系统，提高容错率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统之间相互独立，无法进行相互调用&lt;/li&gt;
&lt;li&gt;系统之间相互独立，会有重复的开发任务&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f606dde9df5.png&#34; alt=&#34;1660290781607.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;分布式架构&#34;&gt;分布式架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f5fe172fffc.png&#34; alt=&#34;1660288534744.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当垂直应用越来越多，重复的业务代码就会越来越多。这时候，我们就思考可不可以将重复的代码抽取出来，做成统一的业务层作为独立的服务，然后由前端控制层调用不同的业务层服务呢？&lt;/p&gt;
&lt;p&gt;这就产生了新的分布式系统架构。它将把工程拆分成表现层和服务层两个部分：&lt;/p&gt;
&lt;p&gt;服务层中包含业务逻辑，例如数据库操作，网络请求，文件读写等等。&lt;/p&gt;
&lt;p&gt;表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。&lt;/p&gt;
&lt;p&gt;优点：分布式架构可以满足复杂的业务需求，并且抽取公共功能为服务层，提高代码复用性&lt;/p&gt;
&lt;p&gt;缺点：系统间耦合度变高，调用关系复杂，难以维护&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f60adf9df52.png&#34; alt=&#34;1660291807335.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;soa架构&#34;&gt;SOA架构&lt;/h2&gt;
&lt;p&gt;在分布式架构下，当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加&lt;br&gt;
一个调度中心对集群进行实时管理。&lt;/p&gt;
&lt;p&gt;此时，用于资源调度和治理中心(SOA Service Oriented Architecture，面向服务的架构)是关键。&lt;/p&gt;
&lt;p&gt;优点: 使用注册中心解决了服务间调用关系的自动调节&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务间会有依赖关系，一旦某个环节出错会影响较大( 服务雪崩 )&lt;/li&gt;
&lt;li&gt;服务关系复杂，运维、测试部署困难&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f60f2ccf2c7.jpg&#34; alt=&#34;62f60f2ccf2c7&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;微服务架构&#34;&gt;微服务架构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f610e8e18a5.png&#34; alt=&#34;1660293352644.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;微服务架构在某种程度上是面向服务的架构SOA继续发展的下一步，它更加强调服务的&amp;quot;彻底拆分&amp;quot;。&lt;/p&gt;
&lt;p&gt;微服务架构特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发&lt;/li&gt;
&lt;li&gt;面向服务：微服务对外暴露业务接口&lt;/li&gt;
&lt;li&gt;自治：团队独立、技术独立、数据独立、部署独立&lt;/li&gt;
&lt;li&gt;隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展&lt;/li&gt;
&lt;li&gt;微服务之间采用tcp协议相互调用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：架构非常复杂，运维、监控、部署难度提高&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f61115cfe14.png&#34; alt=&#34;1660293397706.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">微服务｜系统应用架构演变</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/J9qM98Nhv/"" data-c="
          &lt;p&gt;ES6全称ECMAScript 6.0 ，是JavaScript 的下一个版本标准。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。&lt;/p&gt;
&lt;p&gt;在前文中提到了ES6的新特性——class语法糖的使用。本文来讲讲除了class外ES6～ES12其他的新的特性，如果没有读的可以去看看：&lt;a href=&#34;https://ricky.shineteens.com/post/u7zwdeg-m/&#34;&gt;JavaScript｜Class定义类&lt;/a&gt;。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;字面量的增强&#34;&gt;字面量的增强&lt;/h2&gt;
&lt;p&gt;ES6中对&lt;strong&gt;对象字面量&lt;/strong&gt;进行了增强，主要包括三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;属性的简写&lt;/li&gt;
&lt;li&gt;方法的简写&lt;/li&gt;
&lt;li&gt;计算属性名&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-javaScript&#34;&gt;var name = &#39;ricky&#39;
var age = 18

var obj = {
    // 属性的简写
    name,
    age,
    // 方法的简写
    foo: function() { // 一般写法
        console.log(this);
    },
    bar() { // 简写
        console.log(this);
    },
    bar2: ()=&amp;gt; { // 箭头函数
        console.log(this);
    }
    // 计算属性名
    [name+233]: &#39;Hello, world!&#39;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解构&#34;&gt;解构&lt;/h2&gt;
&lt;h3 id=&#34;数组解构&#34;&gt;数组解构&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var names = [&amp;quot;abc&amp;quot;, &amp;quot;cba&amp;quot;, &amp;quot;nba&amp;quot;]

// 对数组的解构: []
var [item1, item2, item3] = names
console.log(item1, item2, item3) // abc cba nba

// 解构后面的元素
var [, , itemz] = names
console.log(itemz) // nba

// 解构出一个元素,后面的元素放到一个新数组中
var [itemx, ...newNames] = names
console.log(itemx, newNames) // abc [&#39;cba&#39;, &#39;nba&#39;]

// 解构的默认值
var [itema, itemb, itemc, itemd = &amp;quot;aaa&amp;quot;] = names
console.log(itemd) // aaa
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对象解构&#34;&gt;对象解构&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = {
  name: &amp;quot;Ricky&amp;quot;,
  age: 18,
  height: 1.88
}

// 对象的解构: {}
var { name, age, height } = obj
console.log(name, age, height) // Ricky 18 1.88

// 解构后赋予其他变量名
var { name: newName } = obj
console.log(newName) // Ricky

// 设置默认值
var { address: newAddress = &amp;quot;广州市&amp;quot; } = obj
console.log(newAddress) // 广州市


function foo(info) {
  console.log(info.name, info.age)
}

foo(obj) // Ricky 18

function bar({name, age}) {
  console.log(name, age)
}

bar(obj) // Ricky 18
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;letconst的使用&#34;&gt;let/const的使用&lt;/h2&gt;
&lt;p&gt;在ES5中，我们使用var来声明变量，从ES6开始我们可以通过let/const来声明。&lt;/p&gt;
&lt;p&gt;let关键字：从直观的角度来说，let和var是没有太大的区别的，都是用于声明一个变量。&lt;/p&gt;
&lt;p&gt;const关键字： 它表示保存的数据一旦被赋值，就不能被修改； 但是如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容。&lt;/p&gt;
&lt;h3 id=&#34;作用域提升&#34;&gt;作用域提升&lt;/h3&gt;
&lt;p&gt;let、const和var的另一个重要区别是作用域提升：我们知道var声明的变量是会进行作用域提升的；但是如果我们使用let声明的变量，在声明之前访问会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(a); // undifined

var a = &#39;Hello, world!&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(a); // ReferenceError: Cannot access &#39;a&#39; before initialization

let a = &#39;Hello, world!&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些变量会被创建在包含他们的词法环境被实例化时，但是是不可以访问它们的，直到词法绑定被求值。从这里可以看出let、const没有进行作用域提升，但是会在解析阶段被创建出来。&lt;/p&gt;
&lt;h3 id=&#34;变量保存&#34;&gt;变量保存&lt;/h3&gt;
&lt;p&gt;我们知道通过var声明的变量会被保存在window中，但let/const是不会给window添加属性的。在ECMA标准有这样一个描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每一个执行上下文会被关联到一个变量环境 (variable object, VO)，在源代码中的变量和函数声明会被作为属性添加到VO中。对于函数来说，参数也会被添加到VO中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;每一个执行上下文会关联到一个变量环境 (VariableEnvironment) 中，在执行代码中变量和函数的声明会作为环境记录 (Environment Record) 添加到变量环境中。对于函数来说，参数也会被作为环境记录添加到变量环境中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以通过let/const声明的变量会被添加到变量环境中，但不是window对象上。在v8中通过VariableMap的hashmap来实现变量存储。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://nas.shineteens.com:9999/i/2022/08/10/62f3758c370c7.png&#34; alt=&#34;62f3758c370c7&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;块级作用域&#34;&gt;块级作用域&lt;/h2&gt;
&lt;p&gt;在ES5中只有两个东西会形成作用域：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局作用域&lt;/li&gt;
&lt;li&gt;函数作用域&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在ES6中新增了块级作用域，并且通过let、const、function、class声明的标识符是具备块级作用域的限制的，但块级作用域内不函数可以被外部访问，因为引擎会对函数进行特殊处理：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javaScript&#34;&gt;{
  let foo = &amp;quot;why&amp;quot;
  function demo() {
    console.log(&amp;quot;demo function&amp;quot;)
  }
  class Person {}
}

console.log(foo) // foo is not defined
// 不同的浏览器有不同实现的(大部分浏览器为了兼容以前的代码, 让function是没有块级作用域)
demo() // demo function
var p = new Person() // Person is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;块级作用域案例——多个按钮监听点击：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;button&amp;gt;button1&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;button2&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;button3&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;button4&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;
const btns = document.getElementsByTagName(&#39;button&#39;)
for (let i = 0; i &amp;lt; btns.length; i++) {
  btns[i].onclick = function() {
    console.log(&amp;quot;第&amp;quot; + i + &amp;quot;个按钮被点击&amp;quot;)
  }
}
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;暂时性死区&#34;&gt;暂时性死区&lt;/h3&gt;
&lt;p&gt;是在一个代码中，使用let、const声明的变量，在声明之前，变量都是不可以访问的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo = &#39;foo&#39;;

if (1) {
    console.log(foo); // ReferenceError: Cannot access &#39;foo&#39; before initialization
    let foo = &#39;bar&#39;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;模版字符串&#34;&gt;模版字符串&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;${...}&lt;/code&gt;可以实现模版字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javaScript&#34;&gt;// ES6之前拼接字符串和其他标识符
const name = &amp;quot;Ricky&amp;quot;
const age = 18
const height = 1.88
// ES6提供模板字符串 ``
const message = `my name is ${name}, age is ${age}, height is ${height}`
console.log(message) // my name is Ricky, age is 18, height is 1.88

// 能够实现运算
const info = `age double is ${age * 2}`
console.log(info) // 36

// 能够实现函数
function doubleAge() {
  return age * 2
}

const info2 = `double age is ${doubleAge()}`
console.log(info2) // 36
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个不怎么常用的方法：标签模块字符串&lt;/p&gt;
&lt;p&gt;第一个参数依然是模块字符串中整个字符串, 只是被切成多块,放到了一个数组中&lt;br&gt;
第二个参数是模块字符串中, 第一个 ${}&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javaScript&#34;&gt;function foo(m, n, x) {
  console.log(m, n, x)
}

foo`Hello World` // [ &#39;Hello World&#39; ] undefined undefined

const name = &amp;quot;Ricky&amp;quot;
const age = 18
// [&#39;Hello&#39;, &#39;Wo&#39;, &#39;rld&#39;]
foo`Hello${name}Wo${age}rld` // [ &#39;Hello&#39;, &#39;Wo&#39;, &#39;rld&#39; ] Ricky 18
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;函数默认值&#34;&gt;函数默认值&lt;/h2&gt;
&lt;p&gt;可以在创建函数的时候很方便地为参数设置默认值，但最好有默认值的参数放在最后;&lt;br&gt;
另外默认值会改变函数的length的个数，默认值以及后面的参数都不计算在length之内了.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javaScript&#34;&gt;// 1.ES6可以给函数参数提供默认值
function foo(m = &amp;quot;aaa&amp;quot;, n = &amp;quot;bbb&amp;quot;) {
  console.log(m, n)
}

foo() // aaa bbb 
foo(0, &amp;quot;&amp;quot;) // 0 

// 2.对象参数和默认值以及解构
function printInfo({name, age} = {name: &amp;quot;Ricky&amp;quot;, age: 18}) {
  console.log(name, age)
}

printInfo({name: &amp;quot;kobe&amp;quot;, age: 40}) // kobe 40

// 另外一种写法
function printInfo1({name = &amp;quot;Ricky&amp;quot;, age = 18} = {}) {
  console.log(name, age)
}

printInfo1() // Ricky 18

// 3.有默认值的形参最好放到最后
function bar(x, y, z = 30) {
  console.log(x, y, z)
}

bar(10, 20) // 10 20 30
bar(undefined, 10, 20) // undefined 10 20

// 4.有默认值的函数的length属性
function baz(x, y, z, m, n = 30) {
  console.log(x, y, z, m, n)
}

function baz1(x, y, z, m, n) {
  console.log(x, y, z, m, n)
}

console.log(baz.length) // 4
console.log(baz1.length) // 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;函数剩余参数&#34;&gt;函数剩余参数&lt;/h2&gt;
&lt;p&gt;ES6中引用了rest parameter，可以将不定数量的参数放入到一个数组中：如果最后一个参数是 ... 为前缀的，那么它会将剩余的参数放到该参数中，并且作为一个数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javaScript&#34;&gt;function fun(m, n, ...args) {
    console.log(m, n);
    console.log(args);
}

fun(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;);  //a b [ &#39;c&#39;, &#39;d&#39; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与arguments区别：剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参；arguments对象不是一个真正的数组，而rest参数是一个真正的数组，可以进行数组的所有操作；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javaScript&#34;&gt;function fun1(m, n) {
  console.log(m, n);
  console.log(arguments);
}

fun1(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;); // a b [Arguments] { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, &#39;3&#39;: &#39;d&#39; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;箭头函数&#34;&gt;箭头函数&lt;/h2&gt;
&lt;p&gt;箭头函数没有显示原型，不能作为构造函数，即不能new:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const foo = () =&amp;gt; {
    console.log(&#39;foo&#39;);
}

console.log(foo.prototype); // undefined
var f = new foo(); // TypeError: foo is not a constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;展开语法&#34;&gt;展开语法&lt;/h2&gt;
&lt;p&gt;可以在函数调用/数组构造时，将数组表达式或者string在语法层面展开，还可以在构造字面量对象时, 将对象表达式按key-value的方式展开：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const str = &#39;Hello&#39;;
console.log(...str); // H e l l o

const arr = [1, 2, 3];
const arr1 = [...arr, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]

const obj = {a: 1, b: 2};
const obj1 = {...obj, c: 3, d: 4}; // {a: 1, b: 2, c: 3, d: 4}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数值表示&#34;&gt;数值表示&lt;/h2&gt;
&lt;p&gt;在ES6中规范了二进制和八进制的写法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const binary = 0b11111111; // 二进制 -&amp;gt; 十进制: 255
const octal = 0o377; // 八进制 -&amp;gt; 十进制: 255
const hex = 0xFF; // 十六进制 -&amp;gt; 十进制: 255
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在ES2021新增特性：数字过长时，可以使用_作为连接符：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const bigNum = 123_456_789_123; // 123456789123
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;symbol作为属性名&#34;&gt;Symbol作为属性名&lt;/h2&gt;
&lt;p&gt;Symbol是一种新的基本数据类型，可以用来描述对象的属性名，在ES6之前，对象的属性名都是字符串形式，那么很容易造成属性名的冲突。比如原来有一个对象，我们希望在其中添加一个新的属性和值，但是我们在不确定它原来内部有什么内容的情况下，很容易造成冲突，从而覆盖掉它内部的某个属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const key1 = Symbol(&#39;key&#39;);
const key2 = Symbol(&#39;key&#39;);

console.log(key1 === key2); // false

const obj = {
    [key1]: &#39;value1&#39;,
    [key2]: &#39;value2&#39;
}

// Symbol只能通过[key]访问
console.log(obj[key1], obj[key2]); // value1 value2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;setmap&#34;&gt;Set&amp;amp;Map&lt;/h2&gt;
&lt;p&gt;在ES6之前，我们存储数据的结构主要有两种：数组、对象。 在ES6中新增了另外两种数据结构：Set、Map，以及它们的另外形式WeakSet、WeakMap。&lt;/p&gt;
&lt;h3 id=&#34;set&#34;&gt;Set&lt;/h3&gt;
&lt;p&gt;Set是一个新增的数据结构，可以用来保存数据，类似于数组，但是和数组的区别是元素不能重复。创建Set我们需要通过Set构造函数（暂时没有字面量创建的方式）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const set = new Set();

// 添加元素
set.add(1);
set.add(2);
set.add(3);
set.add(1);

console.log(set); // Set(3) { 1, 2, 3 }

// 删除元素
set.delete(1);

console.log(set); // Set(2) { 2, 3 }

// 判断是否存在元素
console.log(set.has(1)); // false
console.log(set.has(2)); // true

// 清空Set
set.clear();

console.log(set); // Set(0) {}

// 遍历Set: 可以forEach和for of
const set1 = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])

set1.forEach(item =&amp;gt; {
    console.log(item); // a b c d
}

for (let value of set1) {
    console.log(value); // a b c d
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见用法——数组去重：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5];

const set = new Set(arr);

const newArr = Array.from(set);

console.log(newArr); // 1 2 3 4 5 6 7 8 9 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;weakset&#34;&gt;WeakSet&lt;/h3&gt;
&lt;p&gt;WeakSet是新增和Set类似的数据结构，可以用来保存对象，但是和Set不同的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WeakSet中只能存放对象类型，不能存放基本数据类型&lt;/li&gt;
&lt;li&gt;WeakSet的每个元素都是弱引用，即垃圾回收机制不考虑WeakSet对该元素的引用，因此，如果元素所在的内存被回收，该元素也会被回收。&lt;/li&gt;
&lt;li&gt;WeakSet不能遍历：因为WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁。所以存储到WeakSet中的对象是没办法获取的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个作用——防止通过非构造方法创建出来的对象调用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javaScript&#34;&gt;const set = new WeakSet();

class Person {
  constructor(name) {
      this.name = name;
      set.add(this)
  }
  sayHi() {
      if (!set.has(this)) throw new Error(&#39;不能调用非构造方法创建出来的对象&#39;)；
      console.log(`Hi, I am ${this.name}`);
  }
}；

const person1 = new Person(&#39;张三&#39;);
person1.sayHi(); // Hi, I am 张三

person1.sayHi.call({name: &#39;李四&#39;}); // Error: 不能调用非构造方法创建出来的对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;map&#34;&gt;Map&lt;/h3&gt;
&lt;p&gt;Map是一个新增的数据结构，可以用来保存键值对，类似于对象，但是和对象的区别是键不能重复，而且可以用其他类型作为键。创建Map我们需要通过Map构造函数（暂时没有字面量创建的方式）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]]);

// 添加元素
map.set(&#39;d&#39;, 4);

console.log(map); // Map(4) { &#39;a&#39; =&amp;gt; 1, &#39;b&#39; =&amp;gt; 2, &#39;c&#39; =&amp;gt; 3, &#39;d&#39; =&amp;gt; 4 }

// 可以设置其他类型的键
map.set({ name: &#39;a&#39; }, 5); // Map(5) { &#39;a&#39; =&amp;gt; 1, &#39;b&#39; =&amp;gt; 2, &#39;c&#39; =&amp;gt; 3, &#39;d&#39; =&amp;gt; 4, { name: &#39;a&#39; } =&amp;gt; 5 }

// 查找元素
console.log(map.get(&#39;a&#39;)); // 1

// 删除元素
map.delete(&#39;a&#39;);

console.log(map); // Map(4) { &#39;b&#39; =&amp;gt; 2, &#39;c&#39; =&amp;gt; 3, &#39;d&#39; =&amp;gt; 4 , { name: &#39;a&#39; } =&amp;gt; 5 }

// 判断是否存在元素
console.log(map.has(&#39;a&#39;)); // false
console.log(map.has(&#39;b&#39;)); // true

// 清空Map
map.clear();

console.log(map); // Map(0) {}

// 遍历Map: 可以forEach和for of
const map1 = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]])

map1.forEach((value, key) =&amp;gt; {
    console.log(key, value); // a 1 b 2 c 3
}

for (let [key, value] of map1) {
    console.log(key, value); // a 1 b 2 c 3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;weakmap&#34;&gt;WeakMap&lt;/h3&gt;
&lt;p&gt;WeakMap是新增的数据结构，可以用来保存对象，但是和Map不同的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WeakMap中只能存放对象类型，不能存放基本数据类型&lt;/li&gt;
&lt;li&gt;WeakMap的每个元素都是弱引用，即垃圾回收机制不考虑WeakMap对该元素的引用，因此，如果元素所在的内存被回收，该元素也会被回收。&lt;/li&gt;
&lt;li&gt;WeakMap不能遍历：因为WeakMap只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁。所以存储到WeakMap中的对象是没办法获取的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以通过WeakMap来实现响应式原理，将对象和方法存储在一起，当对象的属性发生变化时，可以自动触发对应的方法，而对象销毁的时候WeakMap也会销毁：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 应用场景(vue3响应式原理)
const obj1 = {
  name: &amp;quot;Ricky&amp;quot;,
  age: 18
}

function obj1NameFn1() {
  console.log(&amp;quot;obj1NameFn1被执行&amp;quot;)
}

function obj1NameFn2() {
  console.log(&amp;quot;obj1NameFn2被执行&amp;quot;)
}

function obj1AgeFn1() {
  console.log(&amp;quot;obj1AgeFn1&amp;quot;)
}

function obj1AgeFn2() {
  console.log(&amp;quot;obj1AgeFn2&amp;quot;)
}

const obj2 = {
  name: &amp;quot;kobe&amp;quot;,
  height: 1.88,
  address: &amp;quot;广州市&amp;quot;
}

function obj2NameFn1() {
  console.log(&amp;quot;obj1NameFn1被执行&amp;quot;)
}

function obj2NameFn2() {
  console.log(&amp;quot;obj1NameFn2被执行&amp;quot;)
}

// 1.创建WeakMap
const weakMap = new WeakMap()

// 2.收集依赖结构
// 2.1.对obj1收集的数据结构
const obj1Map = new Map()
obj1Map.set(&amp;quot;name&amp;quot;, [obj1NameFn1, obj1NameFn2])
obj1Map.set(&amp;quot;age&amp;quot;, [obj1AgeFn1, obj1AgeFn2])
weakMap.set(obj1, obj1Map)

// 2.2.对obj2收集的数据结构
const obj2Map = new Map()
obj2Map.set(&amp;quot;name&amp;quot;, [obj2NameFn1, obj2NameFn2])
weakMap.set(obj2, obj2Map)

// 3.如果obj1.name发生了改变
// Proxy/Object.defineProperty
obj1.name = &amp;quot;james&amp;quot;
const targetMap = weakMap.get(obj1)
const fns = targetMap.get(&amp;quot;name&amp;quot;)
fns.forEach(item =&amp;gt; item()) // obj1NameFn1被执行 obj1NameFn2被执行
&lt;/code&gt;&lt;/pre&gt;
">JavaScript｜ES6日常用法详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/U7Zwdeg-m/"" data-c="
          &lt;h2 id=&#34;认识class和class的构造函数&#34;&gt;认识class和class的构造函数&lt;/h2&gt;
&lt;p&gt;在之前我讲原型的文章中，按构造函数创建的类不仅和普通的函数相似，还不容易理解。在ES6中，我们可以使用class来定义类，class的本质其实是构造函数的语法糖而已。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  say() {
    console.log(`${this.name} is ${this.age} years old.`);
  }
}

var person = new Person(&#39;Tom&#39;, 18);

person.say(); // Tom is 18 years old.

console.log(person); // Person { name: &#39;Tom&#39;, age: 18 }
console.log(person.__proto__); // {}
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;p&gt;在Babel中会被转换成构造函数的代码，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var Person = /*#__PURE__*/function () {
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }

  var _proto = Person.prototype;

  _proto.say = function say() {
    console.log(this.name + &amp;quot; is &amp;quot; + this.age + &amp;quot; years old.&amp;quot;);
  };

  return Person;
}();

var person = new Person(&#39;Tom&#39;, 18);
person.say(); // Tom is 18 years old.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;class方法和方法拦截&#34;&gt;class方法和方法拦截&lt;/h2&gt;
&lt;p&gt;class中的方法可以通过静态方法来实现，也可以通过实例方法来实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var names = [&amp;quot;abc&amp;quot;, &amp;quot;cba&amp;quot;, &amp;quot;nba&amp;quot;]

class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
    this._address = &amp;quot;广州市&amp;quot;
  }

  // 普通的实例方法
  // 创建出来的对象进行访问
  // var p = new Person()
  // p.eating()
  eating() {
    console.log(this.name + &amp;quot; eating~&amp;quot;)
  }

  running() {
    console.log(this.name + &amp;quot; running~&amp;quot;)
  }

  // 类的访问器方法
  get address() {
    console.log(&amp;quot;拦截访问操作&amp;quot;)
    return this._address
  }

  set address(newAddress) {
    console.log(&amp;quot;拦截设置操作&amp;quot;)
    this._address = newAddress
  }

  // 类的静态方法(类方法)
  // Person.createPerson()
  static randomPerson() {
    var nameIndex = Math.floor(Math.random() * names.length)
    var name = names[nameIndex]
    var age = Math.floor(Math.random() * 100)
    return new Person(name, age)
  }
}

var p = new Person(&amp;quot;Ricky&amp;quot;, 18)
p.eating() // Ricky eating~
p.running() // Ricky running~

console.log(p.address) // 拦截访问操作 // 广州市
p.address = &amp;quot;北京市&amp;quot; // 拦截设置操作
console.log(p.address) // 拦截访问操作 // 北京市

// console.log(Object.getOwnPropertyDescriptors(Person.prototype))

for (var i = 0; i &amp;lt; 50; i++) {
  console.log(Person.randomPerson()) // Person { name: &#39;cba&#39;, age: 52, _address: &#39;广州市&#39; } ... x100
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;class中的继承&#34;&gt;class中的继承&lt;/h2&gt;
&lt;p&gt;在ES6中新增extends关键字，可以方便的帮助我们实现继承。&lt;/p&gt;
&lt;p&gt;还有super关键字，这个super关键字有不同的使用方式：注意：在子（派生）类的构造函数中使用this或者返回默认对象之前，必须先通过super调用父类的构造函数！super的使用位置有三个：子类的构造函数、实例方法、静态方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Person {
  constructor(name, age) {
    this.name = name
    this.age = age
  }

  say() {
    console.log(this.name + &amp;quot; is &amp;quot; + this.age + &amp;quot; years old.&amp;quot;)
  }
}

class Student extends Person {
  constructor(name, age, grade) {
    super(name, age)
    this.grade = grade
  }
  say() {
    super.say()
    console.log(&amp;quot;I am a student. My grade is &amp;quot; + this.grade)
  }
}

var s = new Student(&amp;quot;Ricky&amp;quot;, 18, &amp;quot;一年级&amp;quot;)

s.say() // Ricky is 18 years old. I am a student. My grade is 一年级
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;继承内置类型&#34;&gt;继承内置类型&lt;/h3&gt;
&lt;p&gt;可以通过继承内置类型来实现继承，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;
class superArray extends Array {
    lastItem() {
        return this[this.length - 1]
    }
}

var arr = new superArray(1, 2, 3)
console.log(arr.lastItem()) // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;类的混入&#34;&gt;类的混入&lt;/h3&gt;
&lt;p&gt;混入是一种特殊的继承，它可以将多个类的特性混入到目标类中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Person {

}

function mixinRunner(BaseClass) {
  class NewClass extends BaseClass {
    running() {
      console.log(&amp;quot;running~&amp;quot;)
    }
  }
  return NewClass
}

function mixinEater(BaseClass) {
  return class extends BaseClass {
    eating() {
      console.log(&amp;quot;eating~&amp;quot;)
    }
  }
}

// 在JS中类只能有一个父类: 单继承
class Student extends Person {

}

var NewStudent = mixinEater(mixinRunner(Student))
var ns = new NewStudent()
ns.running()
ns.eating()

&lt;/code&gt;&lt;/pre&gt;
">JavaScript｜Class定义类</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/3kIqfwJzc/"" data-c="
          &lt;h2 id=&#34;对象是否有属于自己的属性&#34;&gt;对象是否有属于自己的属性&lt;/h2&gt;
&lt;p&gt;通过hasOwnProperty()方法判断对象是否有属于自己的属性，而不是原型的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = {
    name: &#39;obj&#39;,
};

var obj1 = Object.create(obj, {
    age: {
        value: 18,
        enumerable: true,
        configurable: true,
        writable: true,
    },
});

console.log(obj1); // { age: 18 }
console.log(obj1.hasOwnProperty(&#39;age&#39;)); // true
console.log(obj1.hasOwnProperty(&#39;name&#39;)); // false
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;判断属性在对象或者原型链上&#34;&gt;判断属性在对象或者原型链上&lt;/h2&gt;
&lt;p&gt;通过in/for in可以判断属性在对象或者原型链上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(&#39;age&#39; in obj1); // true
for (var i in obj1) {
    console.log(i); // age name
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;检测构造函数的pototype是否出现在某个实例对象的原型链上&#34;&gt;检测构造函数的pototype，是否出现在某个实例对象的原型链上&lt;/h2&gt;
&lt;p&gt;通过instanceof判断构造函数的prototype是否出现在某个实例对象的原型链上，但不能用于实例对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function inheritPrototype(SubType, SuperType) {
  SubType.prototype = Object.create(SuperType.prototype)
  Object.defineProperty(SubType.prototype, &amp;quot;constructor&amp;quot;, {
    enumerable: false,
    configurable: true,
    writable: true,
    value: SubType
  })
}


function Person() {

}

function Student() {

}

inheritPrototype(Student, Person)

var stu = new Student()

console.log(stu instanceof Student) // true
console.log(stu instanceof Person) // true
console.log(stu instanceof Object) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;检测某个对象是否出现在某个实例对象的原型链上&#34;&gt;检测某个对象，是否出现在某个实例对象的原型链上&lt;/h2&gt;
&lt;p&gt;通过isPrototypeOf判断某个对象，是否出现在某个实例对象的原型链上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person() {

}

var p = new Person()

console.log(p instanceof Person) // true
console.log(Person.prototype.isPrototypeOf(p)) // true

// 
var obj = {
  name: &amp;quot;why&amp;quot;,
  age: 18
}

var info = Object.create(obj)

console.log(info instanceof obj) // trows a TypeError
console.log(obj.isPrototypeOf(info)) // true
&lt;/code&gt;&lt;/pre&gt;
">JavaScript｜原型判断</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/BvjHWHJ0N/"" data-c="
          &lt;h2 id=&#34;javascript中的面向对象&#34;&gt;JavaScript中的面向对象&lt;/h2&gt;
&lt;p&gt;首先看下面的代码：我们应该怎么称呼这个Person？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person() {

}

var p1 = new Person();
var p2 = new Person();
&lt;/code&gt;&lt;/pre&gt;
&lt;!-- more --&gt;
&lt;p&gt;在JavaScript中，Person是一个函数，它的prototype属性指向一个对象，这个对象的属性包含了Person的所有属性和方法。&lt;/p&gt;
&lt;p&gt;在其他语言的编程范式来看，Person是一个类，这个对象的属性包含了Person的所有属性和方法。&lt;/p&gt;
&lt;h2 id=&#34;面向对象的特点&#34;&gt;面向对象的特点&lt;/h2&gt;
&lt;p&gt;面向对象有三大特性：封装、继承、多态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装：将对象的属性和方法封装在一个对象中，这样就可以避免对象之间的耦合。&lt;/li&gt;
&lt;li&gt;继承：将一个对象的属性和方法复制到另一个对象中，这样就可以让子类继承父类的属性和方法。&lt;/li&gt;
&lt;li&gt;多态：不同的对象有不同的表现，这样就可以让对象的表现不依赖于它的类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;继承的好处：能够将重复的代码抽离到父类中，子类可以直接继承父类，不需要重复定义。&lt;/p&gt;
&lt;h2 id=&#34;javascript原型链&#34;&gt;JavaScript原型链&lt;/h2&gt;
&lt;p&gt;从对象上获取属性，如果对象中没有该属性和方法，则从对象的原型链上获取。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = {
    name: &#39;obj&#39;,
};

obj.__proto__.getName = function() {
    return &#39;Name is obj&#39;;
}

console.log(obj.getName());  // Name is obj
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62ea26a22203e.jpg&#34; alt=&#34;62ea26a22203e&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;原型链的尽头是Object.prototype，Object.prototype的原型是null。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 普通object
var obj = {
    name: &#39;obj&#39;,
};

console.log(obj.__proto__); // [Object: null prototype] {}
console.log(obj.__proto__.__proto__.__proto__);  // null
// 字符串
var ss = &#39;ss&#39;

console.log(ss.__proto__); // [String: null prototype] {}

console.log(ss.__proto__.__proto__) ; // [Object: null prototype] {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[Object: null prototype] {} 的特殊性，该对象有原型属性，但是它的原型属性已经指向的是null，也就是已经是顶层原型了，而该对象上有很多默认的属性和方法。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62ea289cd1f27.jpg&#34; alt=&#34;62ea289cd1f27&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;利用javascript实现继承&#34;&gt;利用JavaScript实现继承&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62ea3de23df06.jpg&#34; alt=&#34;62ea3de23df06&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;javascript原型链继承法&#34;&gt;JavaScript原型链继承法&lt;/h3&gt;
&lt;p&gt;利用上述提到的原型链的原理，可以实现继承。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 父类: 公共属性和方法
function Person() {
  this.name = &amp;quot;Ricky&amp;quot;
  this.friends = []
}

Person.prototype.eating = function() {
  console.log(this.name + &amp;quot; eating~&amp;quot;)
}

// 子类: 特有属性和方法
function Student() {
  this.sno = 111
}

var p = new Person()
Student.prototype = p

Student.prototype.studying = function() {
  console.log(this.name + &amp;quot; studying~&amp;quot;)
}


// name/sno
var stu = new Student()

console.log(stu.name) // Ricky
stu.eating() // Ricky eating~

stu.studying() // Ricky studying~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过原型链实现继承会有一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们通过直接打印对象是看不到这个属性的；&lt;/li&gt;
&lt;li&gt;这个属性会被多个对象共享，如果这个对象是一个引用类型，那么就会造成问题；&lt;/li&gt;
&lt;li&gt;不能给Person传递参数，因为这个对象是一次性创建的（没办法定制化）；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 原型链实现继承的弊端:
// 1.第一个弊端: 打印stu对象, 继承的属性是看不到的
console.log(stu) // [Object: Student prototype] {}

// 2.第二个弊端: 创建出来两个stu的对象
var stu1 = new Student()
var stu2 = new Student()

// 直接修改对象上的属性, 是给本对象添加了一个新属性
stu1.name = &amp;quot;kobe&amp;quot;
console.log(stu2.name) // Ricky

// 获取引用, 修改引用中的值, 会相互影响
stu1.friends.push(&amp;quot;kobe&amp;quot;)

console.log(stu1.friends) // [kobe]
console.log(stu2.friends) // [kobe]

// 3.第三个弊端: 在前面实现类的过程中都没有传递参数
var stu3 = new Student(&amp;quot;lilei&amp;quot;, 112)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;借用构造函数实现继承&#34;&gt;借用构造函数实现继承&lt;/h3&gt;
&lt;p&gt;为了解决原型链继承中存在的问题，开发人员提供了一种新的技术: constructor stealing(有很多名称: 借用构造函 数或者称之为经典继承或者称之为伪造对象)&lt;/p&gt;
&lt;p&gt;方式：在子类型构造函数的内部调用父类型构造函数，例如call, apply, bind等方法。&lt;/p&gt;
&lt;p&gt;强调: 借用构造函数也是有弊端:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一个弊端: Person函数至少被调用了两次&lt;/li&gt;
&lt;li&gt;第二个弊端: stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 父类: 公共属性和方法
function Person(name, age, friends) {
  // this = stu
  this.name = name
  this.age = age
  this.friends = friends
}

Person.prototype.eating = function() {
  console.log(this.name + &amp;quot; eating~&amp;quot;)
}

// 子类: 特有属性和方法
function Student(name, age, friends, sno) {
  Person.call(this, name, age, friends)
  // this.name = name
  // this.age = age
  // this.friends = friends
  this.sno = 111
}

var p = new Person()
Student.prototype = p

Student.prototype.studying = function() {
  console.log(this.name + &amp;quot; studying~&amp;quot;)
}


// name/sno
var stu = new Student(&amp;quot;jame&amp;quot;, 18, [&amp;quot;kobe&amp;quot;], 111)

console.log(stu.name)
stu.eating()

stu.studying()


// 原型链实现继承已经解决的弊端
// 1.第一个弊端: 打印stu对象, 继承的属性是看不到的
console.log(stu)

// 2.第二个弊端: 创建出来两个stu的对象
var stu1 = new Student(&amp;quot;jame&amp;quot;, 18, [&amp;quot;lilei&amp;quot;], 111)
var stu2 = new Student(&amp;quot;kobe&amp;quot;, 30, [&amp;quot;jame&amp;quot;], 112)

// 但如果直接修改对象上的属性, 是给本对象添加了一个新属性
stu1.name = &amp;quot;kite&amp;quot;
console.log(stu2.name) // kobe

// 获取引用, 修改引用中的值, 会相互影响
stu1.friends.push(&amp;quot;lucy&amp;quot;)

console.log(stu1.friends)
console.log(stu2.friends)

// // 3.第三个弊端: 在前面实现类的过程中都没有传递参数
// var stu3 = new Student(&amp;quot;lilei&amp;quot;, 112)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;原型类继承&#34;&gt;原型类继承&lt;/h3&gt;
&lt;p&gt;这种继承方法不是通过构造函数来实现的，也能实现重复利用另一个对象的属性方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var copy = {
  name: &amp;quot;kobe&amp;quot;,
  age: 18,
  friends: [&amp;quot;lilei&amp;quot;, &amp;quot;jame&amp;quot;]
}

// Object.setPrototypeOf()方法
function createObject1(obj) {
  var newObj = {}
  Object.setPrototypeOf(newObj, obj)
  return newObj
}
var stu1 = createObject1(copy)
console.log(stu1.__proto__ === copy) // true

// 函数原型赋值方法
function createObject2(obj) {
  funnction F() {}
  F.prototype = obj
  return new F()
}
var stu2 = createObject2(copy)
console.log(stu2.__proto__ === copy) // true

// ECMAScript5中的Object.create()方法
var stu3 = Object.create(copy)
console.log(stu3.__proto__ === copy) // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;寄生式继承&#34;&gt;寄生式继承&lt;/h3&gt;
&lt;p&gt;寄生式继承的思路是结合原型类继承和工厂模式的一种方式：即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var personObj = {
  running: function() {
    console.log(&amp;quot;running&amp;quot;)
  }
}

function createStudent(name) {
  var stu = Object.create(personObj)
  stu.name = name
  stu.studying = function() {
    console.log(&amp;quot;studying~&amp;quot;)
  }
  return stu
}

var stuObj1 = createStudent(&amp;quot;kobe&amp;quot;)
var stuObj2 = createStudent(&amp;quot;james&amp;quot;)

console.log(stuObj1.name) // kobe
stuObj1.running() // running
stuObj1.studying() // studying~
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;寄生组合式继承&#34;&gt;寄生组合式继承&lt;/h3&gt;
&lt;p&gt;寄生式继承解决了原型属性继承的问题，但constructor指向的是父类的构造函数，而不是子类的构造函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(name, age, friends) {
  this.name = name
  this.age = age
  this.friends = friends
}

Person.prototype.running = function() {
  console.log(&amp;quot;running~&amp;quot;)
}

Person.prototype.eating = function() {
  console.log(&amp;quot;eating~&amp;quot;)
}


function Student(name, age, friends, sno, score) {
  Person.call(this, name, age, friends)
  this.sno = sno
  this.score = score
}

Student.prototype.studying = function() {
  console.log(&amp;quot;studying~&amp;quot;)
}

Student.prototype = Object.create(Person.prototype);

var stu = new Student(&amp;quot;Ricky&amp;quot;, 18, [&amp;quot;kobe&amp;quot;], 111, 100)
console.log(stu) //  Person {name: &amp;quot;Ricky&amp;quot;, age: 18, friends: Array(1), sno: 111, score: 100}
stu.studying() // studying~
stu.running() // running~
stu.eating() // eating~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以利用Object.defineProperty()方法来将constructor指向子类的构造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(Student.prototype, &amp;quot;constructor&amp;quot;, {
  enumerable: false,
  value: Student,
  writable: true,
  configuable: true
})

console.log(stu) //  Student {name: &amp;quot;Ricky&amp;quot;, age: 18, friends: Array(1), sno: 111, score: 100}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现大量这种组合继承，可以通过实现一个工厂函数来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function inheritPrototype(SubType, SuperType) {
  SubType.prototype = Object.create(SuperType.prototype)
  Object.defineProperty(SubType.prototype, &amp;quot;constructor&amp;quot;, {
    enumerable: false,
    configurable: true,
    writable: true,
    value: SubType
  })
}

inheritPrototype(Student, Person)

console.log(stu.constructor.name) // Student
&lt;/code&gt;&lt;/pre&gt;
">JavaScript | 原型链与继承</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/CkpK7rqXL/"" data-c="
          &lt;h2 id=&#34;认识对象的原型&#34;&gt;认识对象的原型&lt;/h2&gt;
&lt;p&gt;JavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。&lt;/p&gt;
&lt;p&gt;那么这个对象有什么用呢？&lt;br&gt;
当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作；&lt;br&gt;
这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它；&lt;br&gt;
如果对象中没有该属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性；&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;获取对象的原型&#34;&gt;获取对象的原型&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;obj = {
    name: &#39;John&#39;,
    age: 30,
}

console.log(obj.__proto__); // [Object: null prototype] {}
console.log(Object.getPrototypeOf(obj)); // [Object: null prototype] {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;原型作用&#34;&gt;原型作用&lt;/h2&gt;
&lt;p&gt;当我们从一个对象中获取某一个属性时, 它会触发 [[get]] 操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在当前对象中去查找对应的属性, 如果找到就直接使用&lt;/li&gt;
&lt;li&gt;如果没有找到, 那么会沿着它的原型去查找 [[prototype]]&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;函数的原型-prototype&#34;&gt;函数的原型 prototype&lt;/h2&gt;
&lt;p&gt;所有的函数都有一个prototype的属性:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person() {
    this.name = &#39;John&#39;;
    this.age = 30;
}

console.log(Person.prototype); // [Object: null prototype] {}
// 因为它是一个函数，才有了这个特殊的属性，而不是因为它是一个对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;new-操作符&#34;&gt;new 操作符&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在内存中创建一个新对象&lt;/li&gt;
&lt;li&gt;将新对象的原型指向构造函数的prototype属性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person() {

}

var p1 = new Person()
var p2 = new Person()

console.log(p1.__proto__ === p2.__proto__); // true
console.log(p1.__proto__ === Person.prototype); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62e7cb8bd9d5e.jpg&#34; alt=&#34;62e7cb8bd9d5e&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;constructor-属性&#34;&gt;constructor 属性&lt;/h2&gt;
&lt;p&gt;事实上原型对象上面是有一个属性的：constructor，默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person() {

}

p1 = new Person();

console.log(Person.prototype); // [Object: null prototype] {}
console.log(p1.__proto__.constructor); // [Function: Person]
console.log(p1.__proto__.constructor.name); // Person
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用getOwnPropertyDescriptors方法可以获取到所有的属性和属性描述符&lt;br&gt;
通过这种方法我们可以发现constructor属性是一个属性描述符，它有一个value属性，指向当前的函数对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(Object.getOwnPropertyDescriptors(foo.prototype)) // {constructor: {value: [Function: Person], writable: true, enumerable: false, configurable: true}}

Object.defineProperty(foo.prototype, &amp;quot;constructor&amp;quot;, {
  enumerable: true,
  configurable: true,
  writable: true,
  value: &amp;quot;哈哈哈哈&amp;quot;
})
console.log(foo.prototype) // {constructor: &amp;quot;哈哈哈哈&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;原型对象的constructor&#34;&gt;原型对象的constructor&lt;/h3&gt;
&lt;p&gt;如果我们需要在原型上添加多种属性，那么可以重新定义整个原型对象，这样就可以添加多个属性了；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person() {

}

Person.prototype = {
    name: &#39;John&#39;,
    age: 30,
    sayHello: function() {
        console.log(&#39;Hello&#39;);
    }
};

var p1 = new Person();

console.log(p1.name, p1.age); // John 30
p1.sayHello(); // Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每创建一个函数, 就会同时创建它的prototype对象, 这个对象也会自动获取constructor属性；而我们这里相当于给prototype重新赋值了一个对象, 那么这个新对象的constructor属性, 会指向Object构造函数, 而不是Person构造函数了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;console.log(f1.constructor) // [Function: Object]

// 真实开发中我们可以通过Object.defineProperty方式添加constructor
Object.defineProperty(Person.prototype, &amp;quot;constructor&amp;quot;, {
  enumerable: false,
  configurable: true,
  writable: true,
  value: Person
})

console.log(f1.constructor) ; // [Function: Person]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;利用原型和构造函数创建对象&#34;&gt;利用原型和构造函数创建对象&lt;/h2&gt;
&lt;p&gt;上一篇中我讲到通过构造函数创建对象时，会创造出重复的函数，这里我们可以通过原型对象来创建对象，这样就不会创造出重复的函数了；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.sayHello = function() {
    console.log(this.name + &#39;Hello&#39;);
}

Person.prototype.sayGoodbye = function() {
    console.log(this.name + &#39;Goodbye&#39;);
}

var p1 = new Person(&#39;John&#39;, 30);
var p2 = new Person(&#39;Mary&#39;, 25);

p1.sayHello(); // JohnHello
p2.sayGoodbye(); //MaryGoodbye
&lt;/code&gt;&lt;/pre&gt;
">JavaScript｜对象原型的理解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/jvcyCW48G/"" data-c="
          &lt;h2 id=&#34;面向对象概念&#34;&gt;面向对象概念&lt;/h2&gt;
&lt;p&gt;对象是JavaScript中一个非常重要的概念，这是因为对象可以将多个相关联的数据封装到一起，更好的描述一个事物：&lt;br&gt;
比如我们可以描述一辆车：Car，具有颜色（color）、速度（speed）、品牌（brand）、价格（price），行驶（travel）等等；&lt;br&gt;
比如我们可以描述一个人：Person，具有姓名（name）、年龄（age）、身高（height），吃东西（eat）、跑步（run）等等；&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62dfa9c9e7a25.jpg&#34; alt=&#34;62dfa9c9e7a25&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;用对象来描述事物，更有利于我们将现实的事物，抽离成代码中某个数据结构：所以有一些编程语言就是纯面向对象的编程语言，比Java；你在实现任何现实抽象时都需要先创建一个类，根据类再去创建对象；&lt;/p&gt;
&lt;h2 id=&#34;javascript的面向对象&#34;&gt;JavaScript的面向对象&lt;/h2&gt;
&lt;p&gt;JavaScript其实支持多种编程范式的，包括函数式编程和面向对象编程：&lt;/p&gt;
&lt;p&gt;JavaScript中的对象被设计成一组属性的无序集合，像是一个哈希表，有key和value组成； key是一个标识符名称，value可以是任意类型，也可以是其他对象或者函数类型； 如果值是一个函数，那么我们可以称之为是对象的方法；&lt;/p&gt;
&lt;h2 id=&#34;创建js对象的方法&#34;&gt;创建JS对象的方法&lt;/h2&gt;
&lt;h3 id=&#34;单个对象创建的方法&#34;&gt;单个对象创建的方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 方法一：
var obj = {
    name: &#39;foo&#39;,
    age: 18,
};

// 方法二：
var obj = new Object();
obj.name = &#39;foo&#39;;
obj.age = 18;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多个对象创建的方法&#34;&gt;多个对象创建的方法&lt;/h3&gt;
&lt;h4 id=&#34;工厂模式&#34;&gt;工厂模式&lt;/h4&gt;
&lt;p&gt;可以通过上述方式创建，但如果需要创建相同属性的多个对象，可以使用工厂模式；&lt;br&gt;
工厂模式其实是一种常见的设计模式，通常我们会有一个工厂方法，通过该工厂方法我们可以产生想要的对象；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 工厂模式：
function createPerson(name, age) {
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}

var person1 = createPerson(&#39;foo&#39;, 18);
var person2 = createPerson(&#39;bar&#39;, 20);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;构造函数&#34;&gt;构造函数&lt;/h4&gt;
&lt;p&gt;构造函数也称之为构造器（constructor），通常是我们在创建对象时会调用的函数；在其他面向的编程语言里面，构造函数是存在于类中的一个方法，称之为构造方法；但是JavaScript中的构造函数有点不太一样；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function foo() {
  console.log(&amp;quot;foo~, 函数体代码&amp;quot;)
}

// foo就是一个普通的函数
foo() // foo~, 函数体代码

// 换一种方式来调用foo函数: 通过new关键字去调用一个函数, 那么这个函数就是一个构造函数了
var f1 = new foo // foo~, 函数体代码
console.log(f1) // [Function: foo]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一个函数被使用new操作符调用了，那么它会执行如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在内存中创建一个新的对象（空对象）；&lt;/li&gt;
&lt;li&gt;这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性；；&lt;/li&gt;
&lt;li&gt;构造函数内部的this，会指向创建出来的新对象；&lt;/li&gt;
&lt;li&gt;执行函数的内部代码（函数体代码）；&lt;/li&gt;
&lt;li&gt;如果构造函数没有返回非空对象，则返回创建出来的新对象；&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 规范: 构造函数的首字母一般是大写
function Person(name, age, height, address) {
  this.name = name
  this.age = age
  this.height = height
  this.address = address

  this.eating = function() {
    console.log(this.name + &amp;quot;在吃东西~&amp;quot;)
  }

  this.running = function() {
    console.log(this.name + &amp;quot;在跑步&amp;quot;)
  }
}


var p1 = new Person(&amp;quot;张三&amp;quot;, 18, 1.88, &amp;quot;广州市&amp;quot;) // 创建一个新的对象
var p2 = new Person(&amp;quot;李四&amp;quot;, 20, 1.98, &amp;quot;北京市&amp;quot;)

console.log(p1) // Person {name: &amp;quot;张三&amp;quot;, age: 18, height: 1.88, address: &amp;quot;广州市&amp;quot;}
console.log(p2)
p1.eating() // 张三在吃东西~
p2.eating()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;操作js对象的方法&#34;&gt;操作JS对象的方法&lt;/h2&gt;
&lt;p&gt;普通的属性操作方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// 设置属性：
obj.name = &#39;bar&#39;;
// 获取属性：
console.log(obj.name);
// 删除属性：
delete obj.name;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据属性描述符&#34;&gt;数据属性描述符&lt;/h3&gt;
&lt;p&gt;属性操作的控制：通过属性描述符可以精准的添加或修改对象的属性，属性描述符需要使用 Object.defineProperty 来对属性进行添加或者修改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperty(obj, &#39;name&#39;, {
    value: &#39;bar&#39;,
    writable: true, // 可写
    enumerable: true, // 可枚举, 可以通过for in循环获取到, 如果设置为false, 则不能通过for in循环获取到, 也不能console.log(obj)获取到
    configurable: true , // 可配置，可以删除属性
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造函数缺点：每次创建一个新的对象，都需要&lt;strong&gt;重新创建一个函数对象实例&lt;/strong&gt;，会占用大量的内存；&lt;/p&gt;
&lt;h3 id=&#34;存取属性描述符&#34;&gt;存取属性描述符&lt;/h3&gt;
&lt;p&gt;存取属性描述符：1.隐藏某一个私有属性被希望直接被外界使用和赋值 2.如果我们希望截获某一个属性它访问和设置值的过程时, 也会使用存储属性描述符&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;obj = {
    _name: &#39;foo&#39;,
}

function foo(value){
    console.log(&#39;get value&#39;, value);
}

function bar(value){
    console.log(&#39;set value&#39;, value);
}

Object.defineProperty(obj, &#39;name&#39;, {
    enumerable: true,
    configurable: true,
    // value: &#39;foo&#39;,  //使用存取属性描述符的话，只能使用getter和setter来控制属性的访问和赋值
    // writable: true, // 同上
    get: function() {
        foo(this._name);
        return this._name;
    },
    set: function(value) {
        bar(value);
        this._name = value;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;同时定义多个属性描述符&#34;&gt;同时定义多个属性描述符&lt;/h3&gt;
&lt;p&gt;Object.defineProperties() 方法直接在一个对象上定义多个新的属性或修改现有属性，并且返回该对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Object.defineProperties(obj, {
    name: {
        value: &#39;foo&#39;,
        writable: true,
        enumerable: true,
        configurable: true,
    },
    age: {
        value: 18,
        writable: true,
        enumerable: true,
        configurable: true,
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取某一个属性的属性描述符&#34;&gt;获取某一个属性的属性描述符&lt;/h3&gt;
&lt;p&gt;获取对象的属性描述符：getOwnPropertyDescriptor, getOwnPropertyDescriptors&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var obj = {
  // 私有属性(js里面是没有严格意义的私有属性)
  _age: 18,
  _eating: function() {}
}

Object.defineProperties(obj, {
  name: {
    configurable: true,
    enumerable: true,
    writable: true,
    value: &amp;quot;foo&amp;quot;
  },
  age: {
    configurable: true,
    enumerable: true,
    get: function() {
      return this._age
    },
    set: function(value) {
      this._age = value
    }
  }
})

// 获取某一个特性属性的属性描述符
console.log(Object.getOwnPropertyDescriptor(obj, &amp;quot;name&amp;quot;))
console.log(Object.getOwnPropertyDescriptor(obj, &amp;quot;age&amp;quot;))

// 获取对象的所有属性描述符
console.log(Object.getOwnPropertyDescriptors(obj))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;object的方法对对象限制&#34;&gt;Object的方法对对象限制&lt;/h3&gt;
&lt;p&gt;禁止对象扩展新属性：preventExtensions&lt;br&gt;
给一个对象添加新的属性会失败（在严格模式下会报错）；&lt;/p&gt;
&lt;p&gt;密封对象，不允许配置和删除属性：seal&lt;br&gt;
实际是调用preventExtensions p并且将现有属性的configurable:false&lt;/p&gt;
&lt;p&gt;冻结对象，不允许修改现有属性： freeze&lt;br&gt;
实际上是调用seal p并且将现有属性的writable: false&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;    Object.freeze() // 冻结对象，不能再修改属性值，不能再删除属性，不能再添加属性，不能再修改属性的可枚举性，不能再修改属性的可配置性，不能再修改属性的可写性
    Object.seal() // 将对象封闭，不能再修改属性值，不能再删除属性，不能再添加属性，可以修改属性的可枚举性，可以修改属性的可配置性，可以修改属性的可写性
    Object.preventExtensions() // 阻止对象增加新的属性，不能再修改属性值，不能再删除属性，可以修改属性的可枚举性，可以修改属性的可配置性，可以修改属性的可写性
    Object.isFrozen() // 判断对象是否被冻结
&lt;/code&gt;&lt;/pre&gt;
">JavaScript｜对象创建与属性控制</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/yY0lLI5Ye/"" data-c="
          &lt;p&gt;上一篇写了如何用群晖原生的VPN Server搭建OpenVPN回家，这一篇讲讲客户端怎么配置才能连接OpenVPN，并且通过配置能够使用OpenVPN转发某个网段，屏蔽某些ip和网段。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://openvpn.net/vpn-client/&#34;&gt;OpenVPN Connect Client | Our Official VPN Client | OpenVPN&lt;/a&gt;&lt;br&gt;
首先从官网下载OpenVPN的客户端，并安装。&lt;/p&gt;
&lt;p&gt;安装好后我们直接用地址和用户名密码连接是连接不成功的，所以我们需要从群晖上把OpenVPN的配置文件下载下来，并且配置好。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de4c8d53af4.jpg&#34; alt=&#34;62de4c8d53af4&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;导出配置文件后我们直接点击即可添加到客户端，但其实这个配置文件并没有配置好地址，如果我们直接导入是修改不了地址的，所以需要在配置文件上修改地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de4ec3a3c27.jpg&#34; alt=&#34;62de4ec3a3c27&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;修改好地址后，直接导入配置文件，输入用户名和密码即可连接。连接好后，进入你设置的vpn动态ip地址+5000端口号，即可进入群晖页面，同时可以访问其他的端口号进入其他服务，不需要在路由器设置虚拟服务器来转发端口了，什么ssh、ftp、http等等开起来。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de4f82b622a.jpg&#34; alt=&#34;62de4f82b622a&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;教程到此结束了！才怪呢，如果我们辛辛苦苦配置的OpenVPN只是转发群晖的端口那就没啥意思了，我们可以通过转发服务器的LAN来使我们直接访问家里的局域网地址，这样就可以访问家里的所有服务了。比如说挂个树莓派啥的，就不用一层层转发了，非常方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de50e6a46b5.jpg&#34; alt=&#34;62de50e6a46b5&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
首先我们需要在VPN面板那边打上这个小勾勾，然后再点击应用，这样服务器就可以支持转发LAN了。&lt;/p&gt;
&lt;p&gt;然后，在配置文件补充要转发的网段，比如说我们的网段是192.168.0.0，子网掩码是255.255.255.0，可以这样设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;route 192.168.0.0 255.255.255.0 vpn_gateway
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;某些地址我们并不想转发，比如在我们公司的局域网也是192.168.0.0那个网段，192.168.0.254是我需要经常访问的地址，所以可以单独把不需要转发的地址进行屏蔽：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;route 192.168.0.254 255.255.255.255 net_gateway
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;整体的配置如图所示：&lt;br&gt;
&lt;img src=&#34;https://www.hualigs.cn/image/62de529ab80c9.jpg&#34; alt=&#34;62de529ab80c9&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;将配置删除后重新导入，再登陆即可。&lt;br&gt;
现在访问一下内网地址，比如群晖在我家地址是：192.168.0.108:5000&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de5338b8528.jpg&#34; alt=&#34;62de5338b8528&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以正常访问，但是如果我们要访问其他的服务，比如说通过RDP访问我家那个小主机，也是OK的:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de53d88eab9.jpg&#34; alt=&#34;62de53d88eab9&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;看一下公司仓库是不是也能正常访问，看样子也是ok的，说明VPN成功屏蔽了该ip的转发:&lt;br&gt;
&lt;img src=&#34;https://www.hualigs.cn/image/62de547277733.jpg&#34; alt=&#34;62de547277733&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">OpenVPN｜在局域网里头，才有家的感觉</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/QQ96ZDO07/"" data-c="
          &lt;p&gt;之前为了方便自己远程玩我的黑群，开了动态DNS和ssh来远程玩，但发现有几次登DSM提示有人尝试ssh登但被封禁了，虽然ip封禁+强密码挺安全的，但我还是担心万一这玩意有漏洞被登了就麻烦了。再加上我到时候毕设还得在上面搭建各种花里胡哨的服务，例如数据库啊，Redis之类的，总不可能开一个服务还得映射一个端口不是吗？而且还涉及到多个设备的玩耍，还得给其他设备做虚拟服务器转发，又麻烦又不安全，索性搭一个VPN服务来方便我一键回家。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;DSM貌似不提供VPN套件了，但官网还是有这个套件的下载地址，可以手动安装一下&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.synology.com/en-global/support/download&#34;&gt;Download Center | Synology Inc.&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de4084ae1a4.jpg&#34; alt=&#34;62de4084ae1a4&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;按照图片上搜索对应的型号，然后拉下去选择Packages，即可看到相关套件：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de40bdafa3a.jpg&#34; alt=&#34;62de40bdafa3a&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de410024390.jpg&#34; alt=&#34;62de410024390&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;下载好后在套件中心手动安装，这一步挺简单的，一步步走就是了&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de41a4c86ba.jpg&#34; alt=&#34;62de41a4c86ba&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;安装完成后直接在套件中心打开，你可以发现这个套件支持三种VPN协议，为啥选用OpenVPN呢？首先是它是三者中最安全的协议，其次是它不容易被BAN，我好不容易搞的公网Ip到时候说没就没了就不好了。在面板启用OpenVPN服务器就行了&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de423db4fec.jpg&#34; alt=&#34;62de423db4fec&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;像我第一次并没有启动成功，提示没有配置中间证书，我找了半天都没找到这个VPN的选项有这个证书配置，后来才发现它的意思是我之前配置群晖地址的ssl证书没有选择中间证书，在那边选好就可以应用了，具体位置在这里，嫌麻烦的可以直接用群晖自己的证书，但连接的时候可能会警告，有域名并申请了证书的就用自己的吧。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62de43700016f.jpg&#34; alt=&#34;62de43700016f&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这里一般把私钥和证书提交了就可以用SSL，但没有配置中间证书的话是用不了VPN的。如果是在腾讯云DNSPOD那边申请的证书的话，需要再下载一个根证书作为中间证书上传。&lt;/p&gt;
&lt;p&gt;所有的配置完毕后，即可开启OpenVPN回家了，下一节再讲讲客户端怎么配置VPN才能优雅回家。&lt;/p&gt;
">OpenVPN｜在群晖上搭建OpenVPN一键回家</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/6IUZEiiSX/"" data-c="
          &lt;h1 id=&#34;callapplybind是做什么的&#34;&gt;call,apply,bind是做什么的&lt;/h1&gt;
&lt;p&gt;call、apply、bind是函数的一种特殊形式，它们的作用是调用函数，并且把函数的参数传递给它。call、apply、bind的实现原理是一样的，都是通过构造函数来实现的。这三种形式的第一个参数，都是函数的调用者，即谁调用了这个函数，从而决定this指向谁。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;下面通过一个例子来说明call、apply、bind的用法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function foo(a, b, c) {
  console.log(this, a, b, c);
}
foo(1, 2, 3); // window 1 2 3
foo.call({ name: &#39;bar&#39; });, 1, 2, 3); // { name: &#39;bar&#39; }, 1, 2, 3;
foo.call(null, 1, 2, 3); // null, 1, 2, 3
foo.apply({ name: &#39;bar&#39; }, [1, 2, 3]); // { name: &#39;bar&#39; }, 1, 2, 3;
foo.apply(null, [1, 2, 3]); // null, 1, 2, 3
foo.bind({ name: &#39;bar&#39; })(1, 2, 3); // { name: &#39;bar&#39; }, 1, 2, 3;
foo.bind(null)(1, 2, 3); // null, 1, 2, 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;call-apply-bind的实现原理&#34;&gt;call、apply、bind的实现原理&lt;/h1&gt;
&lt;p&gt;通过上面的例子我们大概可以了解call、apply、bind的实现方法，即this指向第一个函数，剩余的参数绑定到函数的arguments上。知道了这些我们就可以很方便地手写call、apply、bind的实现了。&lt;br&gt;
首先我们先来实现call的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Function.prototype.mycall = function(thisArg, ...args) {
  // 在这里可以去执行调用的那个函数(foo)
  // 问题: 得可以获取到是哪一个函数执行了mycall
  // 1.获取需要被执行的函数
  var fn = this

  // 2.对thisArg转成对象类型(防止它传入的是非对象类型)
  thisArg = (thisArg !== null &amp;amp;&amp;amp; thisArg !== undefined) ? Object(thisArg): window

  // 3.调用需要被执行的函数
  thisArg.fn = fn
  var result = thisArg.fn(...args)
  delete thisArg.fn

  // 4.将最终的结果返回出去
  return result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单的验证一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function testmycall(a, b) {
    console.log(this, a + b);
}

testmycall(1, 2); // window 3
testmycall.mycall(&#39;mycall&#39;, 1 , 2); // mycall 3
testmycall.call(&#39;call&#39;, 1 , 2); // call 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;弄懂了call的实现方法，我们就可以很方便的手写apply、bind的实现了。其实主要的区别就是call的其他参数就是函数的参数，而apply的第二个参数是函数的参数转成数组，bind的回调函数就是函数的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;Function.prototype.myapply = function(thisArg, args) {
    var fn = this;

    thisArg = (thisArg !== undefined &amp;amp;&amp;amp; thisArg !== null) ? Object(thisArg) :window;

    thisArg.fn = fn;
    
    args = args || [];
    var res = thisArg.fn(...args);
    delete thisArg.fn;

    return res;
}

testmycall.myapply(&#39;myapply&#39;, [111, 222]); // myapply 333
testmycall.apply(&#39;apply&#39;, [111, 222]); // apply 333

Function.prototype.mybind = function(thisArg, ...args) {
    var fn = this;

    thisArg = (thisArg !== undefined &amp;amp;&amp;amp; thisArg !== null) ? Object(thisArg) :window;

    return function proxyFn(...newArgs) {
        thisArg.fn = fn;
        var res = thisArg.fn(...args, ...newArgs);
        delete thisArg.fn;
    }
}

var testbind = testmycall.bind(&#39;bind&#39;, 123, 456);
testbind(111, 222); // bind 333

var testmybind = testmycall.mybind(&#39;mybind&#39;, 111);
testmybind(222); // mybind 333
&lt;/code&gt;&lt;/pre&gt;
">手撕call、apply、bind，相关实现和原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/MPDWmrn41/"" data-c="
          &lt;h1 id=&#34;引言&#34;&gt;引言&lt;/h1&gt;
&lt;p&gt;前段时间我实习的时候把项目的构建工具升级到Vite，感觉体验确实比基于Webpack5的Vue-Cli3丝滑了不少，那么我们来一起探索一下Vite相对于Vue-Cli3好在哪吧。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;vite-相对于webpack的好处&#34;&gt;Vite 相对于Webpack的好处&lt;/h1&gt;
&lt;p&gt;Webpack本质上是一个JavaScript应用的静态编译工具，开发的时候可以启动本地服务器实时预览，但这个过程还是需要对整个项目进行打包，所以非常缓慢。&lt;/p&gt;
&lt;p&gt;对于开发中文件热更新也会有相同的问题，所有涉及到文件和依赖的更新都需要重新编译，这样会导致开发效率下降。&lt;/p&gt;
&lt;p&gt;Vite 只启动静态页面的服务，对文件代码不会进行打包，服务器会根据客户端的请求来处理不同的模块，实现了真正的按需加载。&lt;/p&gt;
&lt;p&gt;对于热更新问题，Vite升级了热更新机制，对当前的文件进行编译，然后把编译后的文件写入到缓存中，客户端直接读取缓存中的文件，不需要再次编译。&lt;/p&gt;
&lt;p&gt;综上，vite 具有了&lt;strong&gt;快速冷启动、按需编译、模块热更新&lt;/strong&gt;等优良特质。&lt;/p&gt;
&lt;h1 id=&#34;vite工作原理&#34;&gt;Vite工作原理&lt;/h1&gt;
&lt;p&gt;在根目录下的index.html中，有这么一段：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62d4cc334d901.jpg&#34; alt=&#34;62d4cc334d901&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过**type=&#39;module&#39;**改变了js的引入方式，使js能够通过import引入其他的js模块。通过这种方式能够使得开发过程中不需要打包即可引入js模块，且能够按需加载。&lt;/p&gt;
&lt;p&gt;在引入需要npm打包的模块时，Vite会进行一个预打包的操作：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62d4cea19e9d9.jpg&#34; alt=&#34;image-20220718110808880&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;预打包的意义是将第三方模块打包后放在vite的一个裸模块地址，以方便引入。&lt;/p&gt;
&lt;p&gt;在加载vue文件的时候，vite会将vue文件解析成一个js文件，以此来加载vue的内容：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62d4cfcb04fe1.jpg&#34; alt=&#34;image-20220718111311148&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;根据这些方法，我们可以看到vite的工作原理是这样的：&lt;br&gt;
通过启动一个服务器，加载首页，并在首页中设置**type=&#39;module&#39;**改变了js的引入方式，并通过模块地址替换的方法引入了第三方模块，这样就实现了按需加载。对于Vue文件，vite会利用SFC的方法解析js并渲染Dom文件，以此来加载vue的内容。&lt;br&gt;
有了这些原理，我们就可以动手实现一个简单的Vite了。具体不在文章中赘述了，感兴趣的可以看我实现的项目方法。&lt;br&gt;
&lt;a href=&#34;https://github.com/veithly/MyVite&#34;&gt;我自己实现的Vite项目&lt;/a&gt;&lt;/p&gt;
">Vite原理和好处</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/d4uf5Rh_t/"" data-c="
          &lt;h1 id=&#34;dom&#34;&gt;DOM&lt;/h1&gt;
&lt;p&gt;vue和React框架应用广泛，封装了DOM操作，但DOM操作一直都会前端工程师的基础、必备知识，只会Vue而不懂DOM操作的前端程序员，不会长久&lt;/p&gt;
&lt;h2 id=&#34;本质&#34;&gt;本质&lt;/h2&gt;
&lt;p&gt;html语言解析出来的树结构&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c2590acf.jpg&#34; alt=&#34;20220311Na22I3&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;可以通过js获取浏览器的dom节点&#34;&gt;可以通过js获取浏览器的dom节点&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const div1 = document.getElementById(&#39;div1&#39;)
console.log(&#39;div1&#39;, div1)

const divList = document.getElementsByTagName(&#39;div&#39;) // 集合
console.log(&#39;divList.length&#39;, divList.length)
console.log(&#39;divList[1]&#39;, divList[1])

const containerList = document.getElementsByClassName(&#39;container&#39;) // 集合
console.log(&#39;containerList.length&#39;, containerList.length)
console.log(&#39;containerList[1]&#39;, containerList[1])

const pList = document.querySelectorAll(&#39;p&#39;)
console.log(&#39;pList&#39;, pList)

const pList = document.querySelectorAll(&#39;p&#39;)
const p1 = pList[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;通过property和attribute修改节点属性&#34;&gt;通过property和attribute修改节点属性&lt;/h2&gt;
&lt;p&gt;property：修改对象属性，不会体现到html结构中&lt;br&gt;
attribute：修改html属性，会改变html结构&lt;br&gt;
两者都有可能引起DOM重新渲染&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// property 形式
p1.style.width = &#39;100px&#39;
console.log( p1.style.width )
p1.className = &#39;red&#39;
console.log( p1.className )
console.log(p1.nodeName)
console.log(p1.nodeType) // 1

// attribute
p1.setAttribute(&#39;data-name&#39;, &#39;imooc&#39;)
console.log( p1.getAttribute(&#39;data-name&#39;) )
p1.setAttribute(&#39;style&#39;, &#39;font-size: 50px;&#39;)
console.log( p1.getAttribute(&#39;style&#39;) )
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;新建-移动节点&#34;&gt;新建、移动节点&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const div1 = document.getElementById(&#39;div1&#39;)
const div2 = document.getElementById(&#39;div2&#39;)

// 新建节点
const newP = document.createElement(&#39;p&#39;)
newP.innerHTML = &#39;this is newP&#39;
// 插入节点
div1.appendChild(newP)

// 移动节点
const p1 = document.getElementById(&#39;p1&#39;)
div2.appendChild(p1)

// 获取父元素
console.log( p1.parentNode )

// 获取子元素列表
const div1ChildNodes = div1.childNodes
console.log( div1.childNodes )
const div1ChildNodesP = Array.prototype.slice.call(div1.childNodes).filter(child =&amp;gt; {
    if (child.nodeType === 1) {
        return true
    }
    return false
})
console.log(&#39;div1ChildNodesP&#39;, div1ChildNodesP)

div1.removeChild( div1ChildNodesP[0] )
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dom性能优化&#34;&gt;dom性能优化&lt;/h2&gt;
&lt;p&gt;DOM操作非常“昂贵”，避免频繁的DOM操作&lt;br&gt;
对DOM查询做缓存&lt;br&gt;
将频繁操作改为一次性操作&lt;/p&gt;
&lt;h3 id=&#34;缓存dom查询&#34;&gt;缓存dom查询&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// 不缓存DOM查询结果
for (let i = 0;i &amp;lt; document.getElementsByTagName(&#39;p&#39;).length;i++){
  // 每次循环都会计算length，频繁进行DOM查询
}

// 缓存DOM查询结果
const Plist = document.getElementsByTagName(&#39;p&#39;);
const length = Plist.length;
for (let i = 0;i &amp;lt; length;i++) {
  // 缓存length，只进行一次dom查询
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;将频繁的操作改成一次性操作&#34;&gt;将频繁的操作改成一次性操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const list = document.getElementById(&#39;list&#39;)

// 创建一个文档片段，此时还没有插入到 DOM 结构中
const frag = document.createDocumentFragment()

for (let i  = 0; i &amp;lt; 20; i++) {
    const li = document.createElement(&#39;li&#39;)
    li.innerHTML = `List item ${i}`

    // 先插入文档片段中
    frag.appendChild(li)
}

// 都完成之后，再统一插入到 DOM 结构中
list.appendChild(frag)

console.log(list)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;bom&#34;&gt;BOM&lt;/h1&gt;
&lt;h2 id=&#34;浏览器信息查看&#34;&gt;浏览器信息查看&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;//navigator
const ua = navigator.userAgent
const isChrome = ua.indexOf(&#39;Chrome&#39;)
console.log (isChrome)
//screen
console.log(screen.width)
console.log (screen.height)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;地址信息查看&#34;&gt;地址信息查看&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;//location
console.log(location.href)
console.log(location.protocol)//&#39;http:&#39;https:
console.log(location.pathname)//&#39;/learn/199&#39;
console.log(location.search)// ? ...
console.log(location.hash) // # ...
//history
history.back() //后退
history.forward() //前进
&lt;/code&gt;&lt;/pre&gt;
">javascript webapi</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/IYITuNTSJ/"" data-c="
          &lt;h1 id=&#34;单线程和异步&#34;&gt;单线程和异步&lt;/h1&gt;
&lt;h2 id=&#34;js单线程&#34;&gt;JS单线程&lt;/h2&gt;
&lt;p&gt;JS是单线程语言，只能同时做一件事。&lt;/p&gt;
&lt;p&gt;浏览器和node.js已支持JS启动进程，如Web Worker&lt;/p&gt;
&lt;p&gt;JS和DOM渲染共用同一个线程，因为JS可修改DOM结构&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;异步原因&#34;&gt;异步原因&lt;/h2&gt;
&lt;p&gt;遇到等待（网络请求，定时任务）不能卡住&lt;/p&gt;
&lt;p&gt;需要异步&lt;/p&gt;
&lt;p&gt;回调callback函数形式&lt;/p&gt;
&lt;h2 id=&#34;异步和同步&#34;&gt;异步和同步&lt;/h2&gt;
&lt;p&gt;基于JS是单线程语言&lt;br&gt;
异步不会阻塞代码执行&lt;br&gt;
同步会阻塞代码执行&lt;/p&gt;
&lt;p&gt;异步 （callback 回调函数）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;console.log(100)
setTimeout(() =&amp;gt; {
    console.log(200)
}, 1000) // 最后打印
console.log(300)
console.log(400)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同步&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;console.log(100)
alert(200) // 点击ok才能打印300
console.log(300)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;应用场景&#34;&gt;应用场景&lt;/h1&gt;
&lt;p&gt;网络请求，如ajax图片加载&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;console.log(&#39;start&#39;)
$.get(&#39;./data.json&#39;,function(data){
  console.log(data)
})
console.log(&#39;end&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定时任务，如setTimeout&lt;/p&gt;
&lt;h1 id=&#34;promise&#34;&gt;Promise&lt;/h1&gt;
&lt;h2 id=&#34;callback-hell回调地狱&#34;&gt;callback hell回调地狱&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;//获取第一份数据
$.get(url1, (data1) =&amp;gt; {
  console.log(data1);
  //获取第二份数据
  $.get(url2, (data2) =&amp;gt; {
    console.log(data2);
    //获取第三份数据
    $get(url3, (data3) =&amp;gt; {
      console.log(data3);
      //还可能获取更多的数据})
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;promise封装ajax&#34;&gt;Promise封装ajax&lt;/h2&gt;
&lt;h3 id=&#34;封装&#34;&gt;封装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;getData = (url) =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    $.ajax({
      url,
      success(data) {
        resolve(data);
      },
      error(err) {
        reject(err);
      },
    });
  });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const url1 = &amp;quot;/data1.json&amp;quot;;
const url2 = &amp;quot;/data2.json&amp;quot;;
const url3 = &amp;quot;/data3.json&amp;quot;;

getData(url1)
  .then((data1) =&amp;gt; {
    console.log(data1);
    return getData(url2);
  })
  .then((data2) =&amp;gt; {
    console.log(data2);
    return getData(url3);
  })
  .then((data3) =&amp;gt; {
    console.log(data3);
  })
  .catch((err) =&amp;gt; console.error(err));
&lt;/code&gt;&lt;/pre&gt;
">javascript异步</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/gExSGHVAQ/"" data-c="
          &lt;h1 id=&#34;class和继承&#34;&gt;Class和继承&lt;/h1&gt;
&lt;h2 id=&#34;class&#34;&gt;class&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;class Student {
    constructor(name, number) {
        this.name = name;
        this.number = number;
    }
    sayHi() {
        console.log(
            `Name:${this.name}, Id:${this.number}`
        )
    }
}

&amp;lt;!-- more --&amp;gt;

const Ricky = new Student(&amp;quot;Ricky&amp;quot;,100)
console.log(Ricky.name)
Ricky.sayHi()
//Ricky
//Name:Ricky, Number:100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;继承&#34;&gt;继承&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// 父类
class People {
  constructor(name) {
    this.name = name;
  }
  eat() {
    console.log(`${this.name} eat something`);
  }
}

// 子类
class Student extends People {
  constructor(name, number) {
    super(name);
    this.number = number;
  }
  sayHi() {
      console.log(`hi,${this.name},your number is ${this.number}`)
  }
}

const me = new Student(&amp;quot;RS&amp;quot;,100)
me.sayHi()
me.eat()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;hi,RS,your number is 100&lt;br&gt;
RS eat something&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;类型判断&#34;&gt;类型判断&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;me instanceof Student // true
me instanceof People // true
me instanceof Object // true
typeof me // object
typeof Student // function 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;原型和原型链&#34;&gt;原型和原型链&lt;/h2&gt;
&lt;h3 id=&#34;原型&#34;&gt;原型&lt;/h3&gt;
&lt;p&gt;隐式原型和显示原型&lt;/p&gt;
&lt;p&gt;每个class都有显示原型prototype&lt;br&gt;
每个实例都有隐式原型_proto_&lt;br&gt;
实例的_proto_指向对应class的prototype&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;me.__proto__ === Student.prototype //true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取属性xialuo.name或执行方法xialuo.sayhi()时&lt;br&gt;
先在自身属性和方法寻找&lt;br&gt;
如果找不到则自动去_proto_中查找&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c2536b2f.jpg&#34; alt=&#34;20220311sjyGYm&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;原型链&#34;&gt;原型链&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c256afed.jpg&#34; alt=&#34;202203116lh5b6&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;如何准确判断一个变量是不是数组&#34;&gt;如何准确判断一个变量是不是数组？&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;a instanceof Array
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;class的原型本质怎么理解&#34;&gt;class的原型本质，怎么理解？&lt;/h2&gt;
&lt;p&gt;原型和原型链图示&lt;/p&gt;
&lt;p&gt;属性和方法执行规则&lt;/p&gt;
&lt;h2 id=&#34;手写一个简易的jquery考虑插件和扩展性&#34;&gt;手写一个简易的jQuery，考虑插件和扩展性&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;class jQuery {
  constructor(selector) {
    const result = document.querySelectorAll(selector);
    const length = result.length;
    for (let i = 0; i &amp;lt; length; i++) {
      this[i] = result[i];
    }
    this.length = length;
    this.selector = selector;
    // 类似于数组
  }

  get(index) {
    return this[index];
  }

  each(fn) {
    for (let i = 0; i &amp;lt; this.length; i++) {
      const elem = this[i];
      fn(elem);
    }
  }

  on(type, fn) {
    return this.each((elem) =&amp;gt; {
      elem.addEventListener(type, fn, false);
    });
  }
}

// 插件
jQuery.prototype.dialog = function (info) {
  alert(info);
};

// 造轮子
class myJquery extends jQuery {
  constructor(selector) {
    super(selector);
  }
  methods() {}
}
&lt;/code&gt;&lt;/pre&gt;
">原型和原型链</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/jI2_ld7dF/"" data-c="
          &lt;h1 id=&#34;作用域&#34;&gt;作用域&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c2533940.jpg&#34; alt=&#34;作用域&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;全局作用域&#34;&gt;全局作用域&lt;/h2&gt;
&lt;p&gt;window对象，document对象&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;函数作用域&#34;&gt;函数作用域&lt;/h2&gt;
&lt;p&gt;在函数中定义的变量&lt;/p&gt;
&lt;h2 id=&#34;块级作用域&#34;&gt;块级作用域&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;if (1) {
	let x = 100
}
console.log(x) // 报错
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建10个a标签点击时弹出对应序号&#34;&gt;创建10个&lt;a&gt;标签，点击时弹出对应序号&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// 错误写法：i是全局作用域，点击事件发生时i已经是10了
let i,a;
for(i=0;i&amp;lt;10;i++){
  a = document.createElement(&#39;a&#39;)
  a.innerHTML = i + &#39;&amp;lt;br&amp;gt;&#39;
	// 点击时才会执行，此时的i已经为10
  a.addEventListener(&#39;click&#39;, function(e){
    e.preventDefault();
    alert(i)
  })
  document.body.appendChild(a)
}
// 正确写法
let a;
for(let i=0;i&amp;lt;10;i++){
  a = document.createElement(&#39;a&#39;)
  a.innerHTML = i + &#39;&amp;lt;br&amp;gt;&#39;
	// 点击时才会执行，此时的i已经为10
  a.addEventListener(&#39;click&#39;, function(e){
    e.preventDefault();
    alert(i)
  })
  document.body.appendChild(a)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;闭包&#34;&gt;闭包&lt;/h1&gt;
&lt;p&gt;自由变量的查找，是在函数定义的地方，向上级作用域查找不是在执行的地方！！！&lt;/p&gt;
&lt;h2 id=&#34;函数作为返回值&#34;&gt;函数作为返回值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;function create() {
  let a = 100;
  return function() {
    console.log(a)
  }
}
let fn = create()
let a = 200
fn() // 100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;函数作为参数&#34;&gt;函数作为参数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;function print(fn) {
  let a = 200
  fn()
}
let a = 100
function fn() {
  console.log(a)
}
print(fn) // 100
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;闭包隐藏数据只提供api&#34;&gt;闭包隐藏数据，只提供API&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const createCache = () =&amp;gt; {
  const data = {};
  return {
    set : (key,val) =&amp;gt; {
      data[key] =  val
    },
    get : (key) =&amp;gt; {
      return data[key]
    }
  }
}

const c = createCache()
c.set(&#39;a&#39;,100)
console.log(c.get(&#39;a&#39;)) // 100
console.log(c.data) // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;this&#34;&gt;this&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;当做普通函数被调用&lt;/li&gt;
&lt;li&gt;使用call apply bind&lt;/li&gt;
&lt;li&gt;作为对象方法调用&lt;/li&gt;
&lt;li&gt;在class的方法中调用&lt;/li&gt;
&lt;li&gt;箭头函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;this取什么样的值是在函数执行时决定而不是函数定义时。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;function fn() {
  console.log(this)
}
fn() // window
fn.call({x:100}) // {x:100}
const fn2 = fn.bind({x:200}) 
fn2() // {x:200}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在宏任务时this指向window&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const Zhangshan = {
  name: &amp;quot;Zhangshan&amp;quot;,
  sayhi() {
    console.log(this)
  },
  waitSayhi() {
    setTimeout(function() {
      console.log(this)      
    } )
  }
}
Zhangshan.sayhi() // object Zhangshan
Zhangshan.waitSayhi() // window
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箭头函数永远指向上一级&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const Zhangshan = {
  name: &amp;quot;Zhangshan&amp;quot;,
  sayhi() {
    console.log(this)
  },
  waitSayhi() {
    setTimeout(() =&amp;gt; {
      console.log(this)      
    } )
  }
}
Zhangshan.sayhi() // object Zhangshan
Zhangshan.waitSayhi() // object Zhangshan
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;手写bind&#34;&gt;手写bind&lt;/h3&gt;
&lt;p&gt;**&lt;code&gt;bind()&lt;/code&gt;**方法创建一个新的函数，在 &lt;code&gt;bind()&lt;/code&gt;被调用时，这个新函数的 &lt;code&gt;this&lt;/code&gt;被指定为 &lt;code&gt;bind()&lt;/code&gt;的第一个参数，而其余参数将作为新函数的参数，供调用时使用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&#34;&gt;Function.prototype.bind() - JavaScript | MDN&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;// 模拟bind
Function.prototype.bind1 = function() {
  // 将参数拆解成数组
  const args = Array.prototype.slice.call(arguments);
  // 获取 this (数组第一项)
  const t = args.shift();
  // fn1.bind(...)中的fn1
  const self = this;
  // 返回一个函数
  return function(){
    return self.apply(t,args)
  }
}

function fn1(a, b, c) {
  console.log(&amp;quot;this&amp;quot;, this);
  console.log(a, b, c);
  return &amp;quot;this is fn1&amp;quot;;
}

const fn2 = fn1.bind1({ x: 100 }, 10, 20, 30);
const res = fn2();
console.log(res);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;this { x: 100 }&lt;br&gt;
10 20 30&lt;br&gt;
this is fn1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
">作用域与闭包问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/o_m2XgTX-/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;console.log([1,2,3,4,5].splice(1,2,3,4,5));
console.log([1,2,3,4,5].slice(1,2,3,4,5));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下代码输出&lt;br&gt;
&lt;code&gt;[2,3]和[2]&lt;/code&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;splice与slice区别&#34;&gt;splice与slice区别&lt;/h2&gt;
&lt;p&gt;slice方法实现了从原数组中截取一部分返回新的数组&lt;/p&gt;
&lt;p&gt;slice(start, end)&lt;strong&gt;不包含end&lt;/strong&gt;,如果start,end为负数则表示从数组最后一个索引向前计算&lt;/p&gt;
&lt;p&gt;&lt;em&gt;返回值：所截取的数组对象&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;所以问题一的结果为[2].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题二：[1,2,3,4,5].splice(1,2,3,4,5)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;splice方法实现了从原数组中删除或插入一部分内容&lt;/p&gt;
&lt;p&gt;splice(index, howmany, item1, ...itemx )&lt;/p&gt;
&lt;p&gt;index表示从当前索引开始删除，&lt;/p&gt;
&lt;p&gt;howmany代表删除元素的个数&lt;/p&gt;
&lt;p&gt;items 要添加到索引的新元素&lt;/p&gt;
&lt;p&gt;&lt;em&gt;返回值：如果从原数组中删除了元素，则但返回含有被删除的数组对象&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;root元素的高-通过getcomputedstylerootheight计算-为&#34;&gt;root元素的高 (通过getComputedStyle(root).height计算) 为？&lt;/h2&gt;
&lt;p&gt;70px&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&amp;quot;root&amp;quot; style=&amp;quot;border:1px solid red;&amp;quot;&amp;gt;
    &amp;lt;div style=&amp;quot;width:10px;height:10px;margin:10px;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div style=&amp;quot;width:10px;height:10px;margin:20px;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有border形成BFC，两个子组件margin重叠，取大&lt;/p&gt;
&lt;p&gt;如果块元素的 margin-top 与它的第一个子元素的 margin-top 之间没有 border、padding等来分隔，或者块元素的 margin-bottom与它最后一个子元素的 margin-bottom 之间没有 border、padding、height、min-height、max-height 分隔，那么&lt;strong&gt;外边距会塌陷&lt;/strong&gt;。子元素多余的外边距会被父元素的外边距截断。&lt;/p&gt;
&lt;h2 id=&#34;bfcblock-formatting-context格式化上下文是web页面中盒模型布局的css渲染模式指一个独立的渲染区域或者说是一个隔离的独立容器-形成bfc的条件有&#34;&gt;BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。&lt;strong&gt;形成BFC的条件有&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;display 为以下其中之一的值 inline-block，table-cell，table-caption、flex&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;浮动元素，float 除 none 以外的值&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;overflow 除了 visible 以外的值（hidden，auto，scroll）&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;绝对定位元素，position（absolute，fixed）&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.notion.so/CSS-BFC-IFC-GFC-FFC-4a6a13a5270e48f6a8504f5bc0141667&#34;&gt;CSS 盒模型、BFC、IFC、GFC、FFC&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;下边关于https描述正确的是&#34;&gt;下边关于https描述正确的是:&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;客户端会对服务器下发的证书进行域名校验&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;HTTPS 协议是由 HTTP 加上 &lt;a href=&#34;https://baike.baidu.com/item/TLS/2979545&#34;&gt;TLS&lt;/a&gt;/SSL 协议构建的可进行加密传输、身份认证的网络协议，主要通过&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/326874&#34;&gt;数字证书&lt;/a&gt;、&lt;a href=&#34;https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/2816213&#34;&gt;加密算法&lt;/a&gt;、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。设计目标主要有三个。&lt;/p&gt;
&lt;p&gt;（1）数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 [4]  。&lt;/p&gt;
&lt;p&gt;（2）数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 [4]  。&lt;/p&gt;
&lt;p&gt;（3）身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 [4]  。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双向的身份认证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081&#34;&gt;客户端&lt;/a&gt;和&lt;a href=&#34;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AF/6492316&#34;&gt;服务端&lt;/a&gt;在传输数据之前,会通过基于&lt;a href=&#34;https://baike.baidu.com/item/X.509/2817050&#34;&gt;X.509&lt;/a&gt;证书对双方进行身份认证 。具体过程如下 [3]  :&lt;/p&gt;
&lt;p&gt;客户端发起 SSL 握手消息给服务端要求连接。&lt;/p&gt;
&lt;p&gt;服务端将证书发送给客户端。&lt;/p&gt;
&lt;p&gt;客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。&lt;/p&gt;
&lt;p&gt;服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的&lt;a href=&#34;https://baike.baidu.com/item/%E5%85%AC%E9%92%A5/6447788&#34;&gt;公钥&lt;/a&gt;，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。&lt;/p&gt;
&lt;h2 id=&#34;下边关于xss描述正确的是&#34;&gt;下边关于XSS描述正确的是&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;XSS又名跨站脚本攻击，是利用服务器查询漏洞，在提交数据中注入sql语句，从而破坏网站数据&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;防范XSS攻击只要前端对数据进行Base64就可以解决&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XSS攻击需要也服务器对接口进行防护&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;XSS攻击仅在表单提交时使用&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A选项：xss（cross-site-scripting）攻击指的是攻击者往 web 页面里&lt;strong&gt;插入恶意 html 标签或者 javascript 代码&lt;/strong&gt; ；&lt;/p&gt;
&lt;p&gt;B选项：首先代码里对用户输入的地方和变量都需要&lt;strong&gt;仔细检查长度和对 “&amp;lt;&amp;gt; , ; . ”等字进行过滤&lt;/strong&gt;；其次任何内容写到页面之前&lt;strong&gt;都必须加 encode&lt;/strong&gt;，避免不小心把 html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 ；&lt;/p&gt;
&lt;p&gt;D选项：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器汇总，而不是用户原本以为的信任站点 ；&lt;/p&gt;
&lt;h2 id=&#34;以下运行结果&#34;&gt;以下运行结果:&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;for(var i = 0; i &amp;lt; 10; i++) {

    setTimeout(function() {

        console.log(i);

    }, 1000);

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10个10&lt;/p&gt;
&lt;p&gt;for循环执行内部函数的时候i到9，然后终止时i加到10后不累加了，所以通过宏任务可知console.log十次十&lt;/p&gt;
&lt;h2 id=&#34;在跨域请求中下列请求头中哪种content-type一定会触发cors预检查&#34;&gt;在跨域请求中，下列请求头中哪种content-type一定会触发cors预检查&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;text/plain&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;multipart/form-data&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;application/x-www-form-unlencoded&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;application/json&lt;/code&gt;&lt;/strong&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;触发预检请求的三类条件&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认情况下，跨域请求只支持GET,HEAD,POST方法，如果不是这三个请求方法（比如：PUT、DELETE、CONNECT、OPTIONS、TRACE和PATCH），那么将触发预检请求&lt;/li&gt;
&lt;li&gt;默认情况下，浏览器跨域请求时，会自动添加的请求头（HOST,Referer,Connection、Accept、User-Agent,Accept-Languange,Accept-Encoding,Accept-Charset和Content-Type）,这些请求中还有其他请求头时，那么将触发预检请求。&lt;/li&gt;
&lt;li&gt;如1、2所说的情况排除在外的条件下，跨域请求是，浏览器支持的Content-Type值为application/x-www-form-urlencoded，multipart/form-data和text/plain。如果是其他数据类型(如application/json,text/xml...)，那么将触发预检请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;关于position定位下列说法正确的是&#34;&gt;关于position定位，下列说法正确的是&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;relative，absolute, fixed都会脱离当前文档流，并相对于当前位置设置偏移量&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;absolute元素如果其父级设置了fixed属性，则其会相对于浏览器窗口设置偏移&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;z-index属性对元素position属性为relative，absolute, fixed都可以做层级设置&lt;/code&gt;&lt;/strong&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;relative元素以它原来的位置为基准偏移，在其移动后，原来的位置不再占据空间&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;absolute的元素，如果它的父容器设置了position属性，并且position的属性值为absolute或者relative，那么就会依据父容器进行偏移&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;relative元素以它原来的位置为基准偏移，在其移动后，原来的位置不再占据空间&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fixed元素，可定位于相对于浏览器窗口的指定坐标，它始终是以 body 为依据&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;relative元素是参照父级的原始点为原始点，无父级则以BODY的原始点为原始点，配合TOP、RIGHT、BOTTOM、LEFT进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;absolute:只有上级标签有position：absolute/relative属性，才能作为它的父级，否则以body为参考;&lt;br&gt;
relative:偏移的top，right，bottom，left 的值都以它原来的位置为基准偏移，移动后的元素在原来的位置仍会占空间；&lt;/p&gt;
&lt;p&gt;设置了fixed属性的元素，才是相对于视口进行定位偏移的，&lt;/p&gt;
&lt;p&gt;设置了absolute属性的元素，是以离他最近的开启定位的祖先元素为基准，进行偏移。&lt;/p&gt;
&lt;p&gt;这里在fixed元素中的absolute元素，会相对于fixed元素进行定位偏移，不是视口&lt;/p&gt;
&lt;h2 id=&#34;请选择console打印的正确值&#34;&gt;请选择console打印的正确值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;Object.prototype.foo = &#39;Object&#39;;
Function.prototype.foo = &#39;Function&#39;;
function Animal () {};
var cat = new Animal();
console.log(cat.foo);
console.log(Animal.foo);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Object Function&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;构造函数Animal是由 new Function() 创建的一个对象，因此Animal的__proto__属性指向的是Function.prototype；又因函数本身又是一个对象，因此Animal.prototype是指向Object.prototype;cat是由Animal创建出来的实例，cat.__proto__指向Animal.prototype.&lt;/p&gt;
&lt;h2 id=&#34;下列哪个属性不会引起浏览器重排reflow&#34;&gt;下列哪个属性不会引起浏览器重排（reflow）:&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt; @**keyframes** animate {
    0%{
        transform: translate(0,0);
    }
    25%{
        transform: translate(200px,0);
    }
    50%{
        transform: translate(200px,200px);
    }
    75%{
        transform: translate(0,200px);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;.hide {
    visibility:hidden;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;回流：当render tree 的一部分或全部的元素因改变了自身的&lt;strong&gt;宽高，布局，显示或隐藏&lt;/strong&gt;，或者元素内部的文字结构发生变化 导致需要重新构建页面的时候，回流就产生了。&lt;/li&gt;
&lt;li&gt;重绘：当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的&lt;strong&gt;外观风格&lt;/strong&gt;的时候，就会产生重绘。例如你改变了元素的background-color....&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回流必将引起重绘，而重绘不一定会引起回流。&lt;/p&gt;
&lt;h2 id=&#34;下列会导致页面回流reflow的操作有&#34;&gt;下列会导致页面回流reflow的操作有&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;添加或者删除可见的DOM元素&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;仅修改DOM元素的字体颜色、背景色&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resize浏览器窗口&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;设置可见元素为display: none&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;读取元素的属性offsetWidth和offsetHeight&lt;/code&gt; ✓&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加或者删除可见的DOM元素；&lt;/li&gt;
&lt;li&gt;元素位置改变；&lt;/li&gt;
&lt;li&gt;元素尺寸改变——边距、填充、边框、宽度和高度&lt;/li&gt;
&lt;li&gt;内容变化，比如用户在input框中输入文字，文本或者图片大小改变而引起的计算值宽度和高度改变&lt;/li&gt;
&lt;li&gt;页面渲染初始化&lt;/li&gt;
&lt;li&gt;浏览器窗口尺寸改变——resize事件发生时&lt;/li&gt;
&lt;li&gt;计算 offsetWidth 和 offsetHeight 属性&lt;/li&gt;
&lt;li&gt;设置 style 属性的值&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;关于javascript以下选项描述错误的是&#34;&gt;关于javascript，以下选项描述错误的是&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;在原型上扩展的可枚举方法，会被for in循环出来&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;通过hasOwnProperty可判断一个对象以及其原型链上是否具有指定名称的属性&lt;/code&gt; x&lt;/p&gt;
&lt;p&gt;&lt;code&gt;每个函数对象都有prototype属性，返回对象类型原型的引用&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;For循环是按顺序的，for in 循环是不一定按顺序的&lt;/code&gt; x&lt;/p&gt;
&lt;p&gt;&lt;code&gt;for...of 循环可遍历普通对象，如{a:&#39;1&#39;, b:2}&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有继承了 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object&#34;&gt;Object&lt;/a&gt; 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in&#34;&gt;in&lt;/a&gt; 运算符不同，该方法忽略掉那些从原型链上继承到的属性。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in&#34;&gt;for...in&lt;/a&gt; 语句以任意顺序迭代对象的&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&#34;&gt;可枚举属性&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;for...of语句&lt;/strong&gt;在&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols&#34;&gt;可迭代对象&lt;/a&gt; 上创建一个迭代循环，目前所有的内置可迭代对象如下：&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String&#34;&gt;String&lt;/a&gt;、&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array&#34;&gt;Array&lt;/a&gt;、&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray&#34;&gt;TypedArray&lt;/a&gt;、&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map&#34;&gt;Map&lt;/a&gt; 和 &lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set&#34;&gt;Set&lt;/a&gt;，它们的原型对象都实现了 @@iterator 方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;for...in语句&lt;/strong&gt;以任意顺序遍历一个对象的除&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol&#34;&gt;Symbol&lt;/a&gt;以外的&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&#34;&gt;可枚举&lt;/a&gt;属性，包括继承的可枚举属性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;下列关于js事件的描述中正确的有&#34;&gt;下列关于js事件的描述中，正确的有&lt;/h2&gt;
&lt;p&gt;**&lt;code&gt;事件冒泡**是指当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;**&lt;code&gt;不支持冒泡的事件有**blur、focus、load、resize、mouseleave&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;事件委托不依赖于事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;通过addEventListener方法给Dom添加事件监听，addEventListener形参中的第三个参数控制是捕获传递触发还是冒泡传递触发。&lt;/code&gt; ✓&lt;/p&gt;
&lt;h2 id=&#34;css中哪些属性可以继承&#34;&gt;&lt;strong&gt;css中哪些属性可以继承&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;font-size&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;&lt;code&gt;margin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;border&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;color&lt;/code&gt; ✓&lt;/p&gt;
&lt;p&gt;1、字体系列属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;font：组合字体&lt;/li&gt;
&lt;li&gt;font-family：规定元素的字体系列&lt;/li&gt;
&lt;li&gt;font-weight：设置字体的粗细&lt;/li&gt;
&lt;li&gt;font-size：设置字体的尺寸&lt;/li&gt;
&lt;li&gt;font-style：定义字体的风格&lt;/li&gt;
&lt;li&gt;font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。&lt;/li&gt;
&lt;li&gt;font-stretch：允许你使文字变宽或变窄。所有主流浏览器都不支持。&lt;/li&gt;
&lt;li&gt;font-size-adjust：为某个元素规定一个 aspect 值，字体的小写字母 &amp;quot;x&amp;quot; 的高度与&amp;quot;font-size&amp;quot; 高度之间的比率被称为一个字体的 aspect 值。这样就可以保持首选字体的 x-height。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、文本系列属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;text-indent：文本缩进&lt;/li&gt;
&lt;li&gt;text-align：文本水平对齐&lt;/li&gt;
&lt;li&gt;line-height：行高&lt;/li&gt;
&lt;li&gt;word-spacing：增加或减少单词间的空白（即字间隔）&lt;/li&gt;
&lt;li&gt;letter-spacing：增加或减少字符间的空白（字符间距）&lt;/li&gt;
&lt;li&gt;text-transform：控制文本大小写&lt;/li&gt;
&lt;li&gt;direction：规定文本的书写方向&lt;/li&gt;
&lt;li&gt;color：文本颜色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3、元素可见性：visibility&lt;/p&gt;
&lt;p&gt;4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout&lt;/p&gt;
&lt;p&gt;5、列表属性：list-style-type、list-style-image、list-style-position、list-style&lt;/p&gt;
&lt;p&gt;6、生成内容属性：quotes&lt;/p&gt;
&lt;p&gt;7、光标属性：cursor&lt;/p&gt;
&lt;p&gt;8、页面样式属性：page、page-break-inside、windows、orphans&lt;/p&gt;
&lt;p&gt;9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation&lt;/p&gt;
&lt;p&gt;所有元素可以继承的属性：&lt;/p&gt;
&lt;p&gt;1、元素可见性：visibility、opacity2、光标属性：cursor&lt;/p&gt;
&lt;p&gt;内联元素可以继承的属性:&lt;/p&gt;
&lt;p&gt;1、字体系列属性2、除text-indent、text-align之外的文本系列属性&lt;/p&gt;
&lt;p&gt;块级元素可以继承的属性:&lt;/p&gt;
&lt;p&gt;1、text-indent、text-align&lt;/p&gt;
&lt;h2 id=&#34;请选择结果为真的表达式&#34;&gt;请选择结果为真的表达式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;null == undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;undefined === undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;null == null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;null === null&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;=== 判断规则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果类型不同，就[不相等]&lt;/li&gt;
&lt;li&gt;如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断）&lt;/li&gt;
&lt;li&gt;如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。&lt;/li&gt;
&lt;li&gt;如果两个值都是true，或者都是false，那么[相等]。&lt;/li&gt;
&lt;li&gt;如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。&lt;/li&gt;
&lt;li&gt;如果两个值都是null，或者都是undefined，那么[相等]。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;== 判断规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果两个值类型相同，进行 === 比较。&lt;/li&gt;
&lt;li&gt;如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果一个是null、一个是undefined，那么[相等]。&lt;/li&gt;
&lt;li&gt;如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。&lt;/li&gt;
&lt;li&gt;如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。&lt;/li&gt;
&lt;li&gt;如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。&lt;/li&gt;
&lt;li&gt;任何其他组合，都[不相等]。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现一个函数输入一个字符串返回该字符串出现最多的字母&#34;&gt;实现一个函数，输入一个字符串，返回该字符串出现最多的字母&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;const fn = (str) =&amp;gt; {
    let obj = {};
    for (let i=0;i&amp;lt;str.length;i++){
        if (!obj[str[i]]) obj[str[i]] = 1;
        else obj[str[i]]++;
    }
    let maxItem = 0;
    let index = 0;
    for (item in obj) {
        if (obj[item]&amp;gt;maxItem){
            maxItem = obj[item];
            index = item
        } 
    }
    return index;
}
var arr = readline().split(&#39;,&#39;);
console.log(fn(arr[0]));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编写查询函数返回数字字符串中最大的公共前缀字符串&#34;&gt;编写查询函数返回数字字符串中最大的公共前缀字符串&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;var arr = readline().split(&#39;,&#39;);
const maxStr = (arr) =&amp;gt; {
  let longest = arr[0];
  for (let i = 1; i &amp;lt; arr.length; i++) {
    for (let j = 0; j &amp;lt; Math.min(longest.length, arr[i].length); j++) {
      if (longest[j] != arr[i][j]) {
        longest = longest.slice(0,j);
      }
    }
  }
  return longest;
};
console.log(maxStr(arr))
&lt;/code&gt;&lt;/pre&gt;
">58同城2021校招笔试部分题目及讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/XQaMLq3pa/"" data-c="
          &lt;h2 id=&#34;1掌握盒子水平垂直居中的五大方案&#34;&gt;1.掌握盒子水平垂直居中的五大方案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;定位：三种&lt;/li&gt;
&lt;li&gt;display:flex&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;li&gt;display:table-cell&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;p&gt;问：盒子水平和垂直居中怎么来实现？&lt;/p&gt;
&lt;p&gt;答：这个这种需求的话其实在我之前项目当中是非常常见的，刚开始我只用这种这种方法，后来随着Css3的一个兴起，然后这种flex方式其实特别方便，尤其在移动端开发的时候来实现，它的话特别强大对吧？然后那个有一段时间我自己去看掘金，看博客的时候发现，这种方案虽然不常用，但是也能实现，我感觉挺好玩的，所以我就记下来了。&lt;/p&gt;
&lt;h3 id=&#34;定位方式&#34;&gt;定位方式:&lt;/h3&gt;
&lt;p&gt;最开始实现的方案的话，其实我们都用这种方案叫定位的方式最开始实现的方案的话，其实我们都用这种方案叫定位的方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
		/* 让盒子相对父级定位 */
		position: relative;	
	}

.box {
			position: absolute;
			top: 50%;
			left: 50%;
			/* 盒子左上角在页面居中，通过盒子长宽调整到中间居中 */
			margin-top: -25px;
			margin-left: -50px;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;宽高自适应的定位方式&#34;&gt;宽高自适应的定位方式:&lt;/h3&gt;
&lt;p&gt;或者说我的宽和高，不知道具体宽高的情况下，前提是有宽高。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.box {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			margin: auto;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;利用css3控制形变位移实现&#34;&gt;利用CSS3控制形变位移实现：&lt;/h3&gt;
&lt;p&gt;不需要设置宽度和高度，能够随着内容变化自适应。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.box {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);	
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;不通过定位方式来实现&#34;&gt;不通过定位方式来实现：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
			display: flex;
			justify-content: center;
			align-items: center;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;jsts方法实现&#34;&gt;JS/TS方法实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsx&#34;&gt;let HTML = document.documentElement,
			winW = HTML.clientWidth,
			winH = HTML.clientHeight,
			boxW = box.offsetWidth,
			boxH = box.offsetHeight;
		box.style.position = &amp;quot;absolute&amp;quot;;
		box.style.left = (winW - boxW) / 2 + &#39;px&#39;;
		box.style.top = (winH - boxH) / 2 + &#39;px&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;table方法实现&#34;&gt;table方法实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;body {
			display: table-cell;
			vertical-align: middle;
			text-align: center;
			/* 固定宽高 */
			width: 500px;
			height: 500px;
		}

.box {
	display: inline-block;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-css3中盒模型&#34;&gt;2. CSS3中盒模型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c2570c44.jpg&#34; alt=&#34;标准盒模型&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c255eb4f.jpg&#34; alt=&#34;IE盒模型&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c249131f.jpg&#34; alt=&#34;Flex弹性伸缩盒模型&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;问：css3中有哪些盒模型？&lt;/p&gt;
&lt;p&gt;答：标准盒模型和 IE 盒模型也叫怪异盒模型，还有flex 弹性伸缩盒模型。&lt;/p&gt;
&lt;p&gt;问：盒子大小确定&lt;/p&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;p&gt;其实我们最常用的就是标准盒模型，也就是css 中的 contentbox 。它指的是谁呢？width和height 样式，指的是内容的宽度。对吧？并不是盒子最终的宽高。盒子宽高是由我们的内容宽高加上 padding 加上 border 。但这种东西的话在我们真实项目当中可能就会遇到一个问题，什么问题呢？假设然后我想指定一个，我想指我想构建一个 100 乘 100 的这样一个盒子。但是我之前我写的 width和height 是 100 乘100，后来我发现我要给它加个 border 我只要加 border 我不改 width和height 的话咋办？它一定会变大了，这样的话就会折下来了，是不是这样的话不好。那么我还要每改 border 每改 padding 我都要手动改下 width和height 值，还要重新计算，我认为这种方式比较谁麻烦。&lt;br&gt;
后来 CSS 3 里边给我们提供了一个方式，叫box-sizing=content-box 这也是我们所谓的IE盒模型，能够让我们来控制出使用IE盒模型了。&lt;br&gt;
这种怪异盒模型里边有个好处，什么好处呢？它里边我们在 width和height 指的是盒子大小，并不是内容的大小。比如说我写 100 乘 100 盒子最终就是谁 100 乘 100 不管我怎么调border的，不管我怎么调 padding，它会自己通过缩放内容来实现整个盒子还是100 乘 100。这样的话我写样的时候干什么比较方便，不用每一次来回算值了是不是？所以我现在在真实项目当中大部分都在应用谁应用我们的box-sizing= content-box这种IE盒模型，包括我看了 boost up 以及各大 UI 组件 element UI 这种组件它的源码里面的一些公共样式，里边大部分也是让盒子默认就采用box-sizing=content-box所以我认为这是我们开发中的一种规范和一种方式&lt;/p&gt;
&lt;h2 id=&#34;3-左右固定中间自适应方案布局&#34;&gt;3. 左右固定，中间自适应方案布局&lt;/h2&gt;
&lt;h3 id=&#34;最简单的flex布局&#34;&gt;最简单的flex布局&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;&amp;lt;style&amp;gt;
.container {
			display: flex;
			justify-content: space-between;
}

.left,
.right {
	flex:0 0 200px;
}

.center {
	flex:1;
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&amp;quot;container clearfix&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;定位方法&#34;&gt;定位方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;&amp;lt;style&amp;gt;
.container {
			position: relateive;
}

.left,
.right {
			position: absolute;
}
.left {
			left: 0;
}
.right {
			right: 0;
}
.center {
			margin: 0 200px;
}
&amp;lt;/style&amp;gt;

&amp;lt;div class=&amp;quot;container clearfix&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;圣杯布局浮动和负margin&#34;&gt;&lt;strong&gt;圣杯布局：浮动和负MARGIN&lt;/strong&gt;&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;&amp;lt;style&amp;gt;
    html,
    body {
        height: 100%;
        overflow: hidden;
    }

    .container {
        height: 100%;
        padding: 0 200px;
    }

    .left,
    .right {
        width: 200px;
        min-height: 200px;
        background: lightblue;
    }

    .center {
        width: 100%;
        min-height: 400px;
        background: lightsalmon;
    }

    .left,
    .center,
    .right {
        float: left;
    }

    .left {
        margin-left: -100%;
        position: relative;
        left: -200px;
    }

    .right {
        margin-right: -200px;
    }
&amp;lt;/style&amp;gt;

&amp;lt;div class=&amp;quot;container clearfix&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;双飞翼布局：浮动和负MARGIN&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;&amp;lt;style&amp;gt;
    html,
    body {
        height: 100%;
        overflow: hidden;
    }

    .container,
    .left,
    .right {
        float: left;
    }

    .container {
        width: 100%;
    }

    .container .center {
        margin: 0 200px;
        min-height: 400px;
        background: lightsalmon;
    }

    .left,
    .right {
        width: 200px;
        min-height: 200px;
        background: lightblue;
    }

    .left {
        margin-left: -100%;
    }

    .right {
        margin-left: -200px;
    }
&amp;lt;/style&amp;gt;

&amp;lt;body class=&amp;quot;clearfix&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;
        &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-让元素div消失在视野中&#34;&gt;4. 让元素div消失在视野中&lt;/h2&gt;
&lt;p&gt;1.position:absolute/relative/fixed  +  方位 top/bottom/left/right: -9999px&lt;br&gt;
2.display:none&lt;br&gt;
3.visibility:hidden&lt;br&gt;
4.width:0 + overflow:hidden&lt;br&gt;
height:0 +  overflow:hidden&lt;br&gt;
5.margin-top/bottom/left/right:-9999px;&lt;br&gt;
6.background-color:transparent&lt;br&gt;
7.opacity:0&lt;br&gt;
8.transform: translateX(-9999px)/translateY(-9999px)/translate(-9999px,-9999px)&lt;br&gt;
9.transform: scale(0)&lt;/p&gt;
&lt;h2 id=&#34;5-请说明z-index的工作原理适用范围&#34;&gt;5. 请说明z-index的工作原理,适用范围?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;z-index这个属性控制着元素在z轴上的表现形式。&lt;/li&gt;
&lt;li&gt;适用范围:仅适用于定位元素，即拥有relative,absolute,fixed属性的position元素。&lt;/li&gt;
&lt;li&gt;堆叠顺序是当前元素位于z轴上的值，数值越大说明元素的堆叠1顺序越高，越靠近屏幕。&lt;/li&gt;
&lt;li&gt;未定义时，后来居上，未定义z-index的属性，元素的堆叠顺序基于它所在的文档树。默认情况下，后来的元素的z-index的值越大。&lt;/li&gt;
&lt;li&gt;使用范围：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;网页两侧的浮动窗口（播放器，指定按钮，广告等）&lt;/li&gt;
&lt;li&gt;导航栏浮动值顶&lt;/li&gt;
&lt;li&gt;隐藏div实现弹窗功能（通过设置div定位和z-index控制div的位置和出现隐藏）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-谈谈你对html5的理解&#34;&gt;6. 谈谈你对html5的理解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;语义化标签类&lt;/li&gt;
&lt;li&gt;音视频处理&lt;/li&gt;
&lt;li&gt;canvas / webGL&lt;/li&gt;
&lt;li&gt;history API&lt;/li&gt;
&lt;li&gt;requestAnimationFrame&lt;/li&gt;
&lt;li&gt;地理位置&lt;/li&gt;
&lt;li&gt;web scoket&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;7-如何使一个div里面的文字垂直居中且该文字的大小根据屏幕大小自适应&#34;&gt;7. &lt;strong&gt;&lt;strong&gt;如何使一个div里面的文字垂直居中，且该文字的大小根据屏幕大小自适应？&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&#34;垂直居中&#34;&gt;垂直居中：&lt;/h3&gt;
&lt;p&gt;行高法：文字行高和容器相同&lt;/p&gt;
&lt;p&gt;内边距法: 利用padding将内容垂直居中&lt;/p&gt;
&lt;p&gt;模拟表格法：将容器设置为display:table，然后将子元素也就是要垂直居中显示的元素设置为display:table-cell，然后加上vertical-align:middle来实现。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div id=&amp;quot;wrapper&amp;quot;&amp;gt;
    &amp;lt;div id=&amp;quot;cell&amp;quot;&amp;gt;
        &amp;lt;p&amp;gt;测试垂直居中效果测试垂直居中效果&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;测试垂直居中效果测试垂直居中效果&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
#wrapper {display:table;}
#cell{display:table-cell; vertical-align:middle;}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS3 flex&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;flex&amp;quot;&amp;gt;
    &amp;lt;div&amp;gt;
       &amp;lt;p&amp;gt;我是多行文字我是多行文字我是多行文字我是多行文字&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;我是多行文字我是多行文字我是多行文字我是多行文字&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.flex{
    /*flex 布局*/
    display: flex;
    /*实现垂直居中*/
    align-items: center;
    /*实现水平居中*/
    justify-content: center;
    text-align: justify;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS3 transform&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.center-vertical{
  position: relative;
  top:50%;
  transform:translateY(-50%);
}.center-horizontal{
  position: relative;
  left:50%;
  transform:translateX(-50%); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSS3 box&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;text&amp;quot;&amp;gt;
    &amp;lt;p&amp;gt;我是多行文字&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;我是多行文字&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;我是多行文字&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.center {
  width: 300px;
  height: 200px;
  padding: 10px;
  border: 1px solid #ccc;
  background:#000;
  color:#fff;
  margin: 20px auto;
  display: -webkit-box;
  -webkit-box-orient: horizontal;
  -webkit-box-pack: center;
  -webkit-box-align: center;
  
  display: -moz-box;
  -moz-box-orient: horizontal;
  -moz-box-pack: center;
  -moz-box-align: center;
  
  display: -o-box;
  -o-box-orient: horizontal;
  -o-box-pack: center;
  -o-box-align: center;
  
  display: -ms-box;
  -ms-box-orient: horizontal;
  -ms-box-pack: center;
  -ms-box-align: center;
  
  display: box;
  box-orient: horizontal;
  box-pack: center;
  box-align: center;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;文字大小自适应&#34;&gt;文字大小自适应：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;p {
font-size: 36px;
}
@media (max-width: 1000px) {
  p {
    font-size: 30px;
  }
}

@media (max-width: 800px) {
  p {
    font-size: 24px;
  }
}

@media (max-width: 600px) {
  p {
    font-size: 18px;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8-不考虑其它因素下面哪种的渲染性能比较高&#34;&gt;8. 不考虑其它因素，下面哪种的渲染性能比较高？&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.box a{
    ...
}

a{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二个：CSS 的浏览器渲染机制是选择器从右向左查询，所以说遇到div的话就只找所有的 div 查找层级。浏览器渲染机制是先找所有 a 再找 box 下所有的 a，它进行了二次筛选，所以第一个的性能要比第二个慢。&lt;/p&gt;
">CSS常见面试</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/dVEj-wsQc/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c250b485.jpg&#34; alt=&#34;思维导图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;缺乏正向反馈&#34;&gt;缺乏「正向反馈」&lt;/h1&gt;
&lt;p&gt;在我们的大脑中，有一个叫做「奖励系统」的东西，其中包括了前额叶(主要掌管规划和决策)，还有一个叫伏隔核(主要是用来感知愉悦)，最后一个是中脑的一块区域，主要用来分泌多巴胺。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;重点说一下多巴胺，它是一种神经传导物质，当多巴胺分泌传导之后，我们的大脑就会产生愉悦的感受，而这一发现也获得了2000年的诺贝尔医学奖。&lt;br&gt;
而我们提到的抖音上瘾，其实就是因为我们在看一个个小视频的时候，会&lt;strong&gt;让大脑大量分泌多巴胺，让我们出现强烈的愉悦感&lt;/strong&gt;，这种愉悦感就会让我们完全停不不来。&lt;/p&gt;
&lt;h2 id=&#34;为什么向目标努力时无法上瘾&#34;&gt;为什么向目标努力时无法上瘾&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;朝着目标努力的过程中，正向反馈的频率太低了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;努力的过程中，负向反馈反而更多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;做一个行为设计专家让自律上瘾&#34;&gt;做一个行为设计专家，让自律上瘾&lt;/h1&gt;
&lt;p&gt;人的行为是可以设计的，当我们&lt;strong&gt;提前设计好激励和奖励措施&lt;/strong&gt;，人就会被这些措施所“摆弄。&lt;/p&gt;
&lt;p&gt;既然说，行为设计学可以主动地去制造正向反馈，让我们对APP的使用产生依赖，甚至上瘾，那么，同样的对于自律，对于我们去努力实现目标这件事，是不是也可以通过一些设计，设置各种正向反馈，从而实现自律上瘾，让我们更加坚持地去做一件更有意义的事呢?&lt;/p&gt;
&lt;h2 id=&#34;如何通过主动设计让我们更容易坚持自律&#34;&gt;如何通过主动设计，让我们更容易坚持自律?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;设置可量化的关键结果&lt;/p&gt;
&lt;p&gt;个人成就反馈体系要求，必须再次重新审视自己的关键结果，是否是可以进行清晰衡量的，而不是那种模棱两可的结果。&lt;br&gt;
比如，有些同学要复习考试，其中一个关键结果是:“复习完全部教材”。这个关键结果就属于不可量化的。要让这个KR达到一个效果，就是别人拿着你的KR，就可以对你是否完成这项结果，做出准确的判断。&lt;br&gt;
不然，你说我复习完这本书了，粗看一遍也算复习了，精读一遍也算复习了，这种不清晰的KR，需要再次优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置量化成就里程碑&lt;/p&gt;
&lt;p&gt;还是以复习一本书为例，如果有10个章节，那就按照章节划分为5个阶段。比如第1-3章是第一阶段，接着以此类推。&lt;br&gt;
还有，比如你要减肥20斤，那么每5斤，可以作为你的一个阶段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置奖励机制&lt;/p&gt;
&lt;p&gt;刚才我们已经设置了成就里程碑，你的每一个KR都进行了细分，接着就是在你的每个里程碑的点，设置一些奖品。&lt;/p&gt;
&lt;p&gt;第一，要根据自己的经济状况来设置。&lt;br&gt;
第二，最好设置的奖品能够比平时用的东西高档一点点。&lt;br&gt;
第三，奖品设置不要过于影响自己的状态。&lt;br&gt;
第四，奖品设置可以创新。注意，奖品不一定非要给自己买东西呀!你也可以做一些一直想做但没做的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;坚持追踪，持续复盘&lt;/p&gt;
&lt;p&gt;把奖品设置好之后，接着就需要坚持跟踪进度，持续进行复盘了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;社群的力量&#34;&gt;社群的力量&lt;/h2&gt;
&lt;p&gt;社群之所以为社群，是因为社群会形成一种社交磁力，这种磁力，会成为每一个人向前走的推动力。这些推动力的表现形式，通常都是一种正向反馈。&lt;br&gt;
一个人走，总会有疲惫的时候，不要过于封闭自己，而是和那些与你志同道合的小伙伴，一起互相给予正向反馈，更好地抱团成长。&lt;/p&gt;
">如何彻底摆脱三分钟热度?把自律变成一场好玩的游戏!</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/2g6RmtDe4/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c2566e89.jpg&#34; alt=&#34;思维导图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;设定晨间okr三只青蛙&#34;&gt;设定晨间OKR三只青蛙&lt;/h1&gt;
&lt;p&gt;装瓶理论，核心就是说，我们在做事的时候，要&lt;strong&gt;优先利用大块的时间，去处理那些重要的、复杂的事情，也就是那些大石块，然后利用一些间隙去完成那些小事情&lt;/strong&gt;，从而提升我们的整体行动效率。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;每天早上，到了办公室，先思考:今天对于你来说，最重要的三件事是什么，也就是那三只让人感觉很不爽的青蛙，而这些青蛙就相当于我们前面说的大石头。&lt;/p&gt;
&lt;h1 id=&#34;种植okr专注森林&#34;&gt;种植OKR专注森林&lt;/h1&gt;
&lt;p&gt;如何让自己保持专注的状态，找到所谓「心流」的感觉呢?&lt;br&gt;
这里给大家介绍一个方法，叫做种植专注森林。其实，跟我们比较熟悉的番茄钟的概念是相似的，但是从个人体验来看，使用种植森林的方式，会更容易让我进入到专注的状态。&lt;/p&gt;
&lt;p&gt;我来简单介绍一下专注森林或者说番茄钟的理论，一句话来说就是：&lt;strong&gt;一个25分钟的专注时间和5分钟的休息时间组成的工作循环。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;掌握吃拿卡要四字诀&#34;&gt;掌握“吃拿卡要”四字诀&lt;/h1&gt;
&lt;p&gt;接下来是我们的第三步，也是解决我们在吃青蛙过程中，最容易出现的问题:&lt;strong&gt;那就是被打扰。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;吃&#34;&gt;“吃”&lt;/h2&gt;
&lt;p&gt;当我们在吃青蛙的时候，遇到干扰了，这时候你首先要做一个判断，那就是&lt;strong&gt;这件事是否能够在2分钟之内完成&lt;/strong&gt;。比如，领导让你打电话定一个会议室;同事让你帮他收一个快递;老婆让你给家里买袋米.....诸如此类的事情，它们其实很小，也比较琐碎，算不上重要事务，那么就直接“吃”掉它。所以，“吃”字诀就是:干净利落脆，&lt;strong&gt;2分钟能搞定，赶紧吃掉&lt;/strong&gt;!&lt;/p&gt;
&lt;h2 id=&#34;拿&#34;&gt;“拿”&lt;/h2&gt;
&lt;p&gt;但是如果这件事没办法2分钟搞定，怎么办呢?先不着急，再做一次判断，那就是&lt;strong&gt;这件事能不能交给别人做&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;有一个时间管理领域的概念，叫做**「甩掉你身上的猴子」**，这里并不是鼓励大家在工作中甩锅，而是要做理性判断。你想，领导为什么把活儿交给你，其实就是把猴子扔在你肩上了，因为他已经做了一次判断，这并不代表，你一定要把这斯重。请们&lt;br&gt;
个猴子接住。我们要做的，是善于去进行资源优化配置，如果这件事不一定非要你来做，有更好的人选，为什么不把猴子交给别人呢?&lt;/p&gt;
&lt;h2 id=&#34;卡&#34;&gt;“卡”&lt;/h2&gt;
&lt;p&gt;不要总觉得，只要领导交给你的事，就要第一时间完成，你需要去根据自己的工作进度和状态来做出配置的。&lt;br&gt;
很多时候，&lt;strong&gt;延后并不是低效和拖延，而是更高效的优化配置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所谓的“卡”，就是让自己的工作安排，可以&lt;strong&gt;严格的卡在你的日程表上，在不影响自己核心事务的前提下，来去更好地安排工作&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;持续高频复盘追踪&#34;&gt;持续高频复盘追踪&lt;/h1&gt;
&lt;p&gt;上节课介绍0KR的时候，我们就提到了，对0KR的进度要进行持续追踪，包括&lt;strong&gt;每周一列0KR的计划，每周末对OKR进行总结分析&lt;/strong&gt;，这个复盘是以周为单位的。&lt;/p&gt;
&lt;h2 id=&#34;第一方面是okr在自己心中的不断强化&#34;&gt;第一方面，是OKR在自己心中的不断强化&lt;/h2&gt;
&lt;p&gt;就像我们每天设定晨间OKR三只青蛙的时候，不是瞎列的。而是要对照着你的OR，你的周计划，来安排你一天的青蛙的，这个过程，本身就需要你对自己的OKR重新回顾一遍。&lt;br&gt;
第二天写青蛙的时候，同样需要回顾0KR，第三天也一样....&lt;br&gt;
我们可以对比一下你以前设定目标的方法，通常是年初写好目标，热血两三天，基本就把目标束之高阁去吃灰了，很多时候，不是我们不想达成目标，是我们早就把目标给忘记了。&lt;/p&gt;
&lt;p&gt;但是当我们开始使用OKR之后，会强迫着你每天都要对自己的0KR目标回顾一遍，每一次回顾都是一次对目标的强化，这种强化，会很大程度上提升我们的目标感，不断提醒我们朝着正确的方向前进。&lt;/p&gt;
&lt;h2 id=&#34;第二方面就是每天吃青蛙的复盘&#34;&gt;第二方面，就是每天吃青蛙的复盘&lt;/h2&gt;
&lt;p&gt;如：每天早上会开一个5分钟的青蛙早会，内容很简单，就是每个人说一下昨天的青蛙吃的如何，今天的青蛙计划是什么。&lt;/p&gt;
&lt;p&gt;你也可以给自己&lt;strong&gt;每天设定一个复盘的固定化流程&lt;/strong&gt;，只需要几分钟的时间，来回顾自己吃青蛙的情况，这种复盘会让自己对0KR的进度保持足够的觉知，而不至于迷失在繁忙的工作中。&lt;/p&gt;
">4个核心步骤，构建你的专属「自律行动流」</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/Ajz-sKXZ4/"" data-c="
          &lt;p&gt;自律动机从哪里来?最重要、也是最强悍的自律动机，来源于我们的人生使命和目标。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://www.hualigs.cn/image/62cc1c2542a03.jpg&#34; alt=&#34;思维导图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;p&gt;如何最大限度地激发我们的自我驱动力，就是&lt;strong&gt;通过撰写自己的「人生基本法」&lt;/strong&gt;，找到我们的人生方向和目标，找到那个我们愿意为之奋斗一生的目标，支撑着我们向目标冲刺。&lt;br&gt;
「人生基本法」是由四个重要的支柱，或者说四个步骤组成的，包括:&lt;/p&gt;
&lt;h3 id=&#34;确定你的人生使命&#34;&gt;确定你的人生使命&lt;/h3&gt;
&lt;p&gt;所谓人生使命，就是你来到这个世界后，最终为之奋斗的东西，它是你和这个世界产生链接的方式，它能够让你在这个世界上产生的独特的意义与价值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;三星:为人类社会作贡献
苹果:让每人拥有一台计算机
迪斯尼公司:使人们过得快活
华为:丰富人们的沟通和生活
京东:让生活变得简单快乐
阿里巴巴:让天下没有难做的生意
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Ricky_Shao/upic_upload/raw/master/oss/2021%2010%2027%20image-20211027001723807%20.png&#34; alt=&#34;image-20211027001723807&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;**「3小时追梦计划」，帮助大家找到自己的人生使命: **&lt;/p&gt;
&lt;p&gt;具体的方法，就是给自己找出大约3个小时的时间，而且是不被打扰的状态，在白纸上逐条写下自己的渴望与梦想，不断不断地写，直到有一条能让你哭出来，此时你可能就找到了自己心灵深处的人生使命。&lt;/p&gt;
&lt;h3 id=&#34;确定你的人生目标&#34;&gt;确定你的人生目标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;身体：早睡早起、健康饮食、保持健身、精力满满，这些都可以作为身体维度上的目标。&lt;/li&gt;
&lt;li&gt;智力：目标也可以体现为比如“每日读书”，或者“给自己设定阶段性的学习任务”再或者“每年都有一个新的研究课题”等等。&lt;/li&gt;
&lt;li&gt;情感：这里可以包括亲情、爱情、友情以及各种人际关系，你希望可以达成什么样的目标状态。&lt;/li&gt;
&lt;li&gt;财富：不应该是标准答案，每个人的财富目标都是不同的，因为每个人的人生使命是有区别的。&lt;/li&gt;
&lt;li&gt;人生意义：这里给大家推荐一种最具有操作性的思考维度，就是根据你的人生角色，来找到你在不同角色下的人生意义，这个意义翻译过来，就是你想在这个维度下，变成一个什么样的人。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;确定你的价值观或原则&#34;&gt;确定你的价值观或原则&lt;/h3&gt;
&lt;p&gt;所谓价值观，就是你在做各种选择的时候，哪些是应该做的，哪些是不应该做的，哪些是重要的，哪些是不重要的。&lt;br&gt;
比如，极度开放、积极主动、实现双赢、真诚友善等等，这些都可以作为我们的价值观或者原则。&lt;/p&gt;
&lt;h3 id=&#34;确定你的人生策略&#34;&gt;确定你的人生策略&lt;/h3&gt;
&lt;p&gt;所谓人生策略，就是你想要达到以上提到的目标，需要做些什么。&lt;br&gt;
比如，你要实现财富自由，是不是应该学习相应的知识，开展相应的投资实践?比如你要获得家庭幸福，是不是应该学会沟通的艺术?这些都是我们的人生策略。&lt;/p&gt;
&lt;h2 id=&#34;关于人生基本法&#34;&gt;关于人生基本法&lt;/h2&gt;
&lt;p&gt;第一，「人生基本法」不是一天写成的，它需要你不断去思考、打磨和更新。这一周完成这项成果之后，并不代表这件事结来了，而是要不断地去思考、打磨和修正的。&lt;/p&gt;
&lt;p&gt;第二，「人生基本法」在不同的人生阶段，必然会出现变化。你想想看，你在小学时候的人生观和现在，是不是完全不同，再过十年，你的人生基本法一定又会出现巨大的变化。&lt;br&gt;
第三，「人生基本法」既包括使命、目标，也包括原则、策略。不要过于纠结于他的形式，他可能是你一生要追求的目标，比如实现财务自由;也可能是你在为人处世时必须要遵守的原则，比如为人诚信。最重要的是，你开始用“以终为始”的理念，来思考自己的人生意义，梳理自己的人生目标，完成这个思考过程，对于大多数人来说，都已经是一次认知上的巨大突破了。&lt;/p&gt;
&lt;h2 id=&#34;人生基本法模板&#34;&gt;《人生基本法》模板&lt;/h2&gt;
&lt;h3 id=&#34;一-人生使命&#34;&gt;一、人生使命&lt;/h3&gt;
&lt;p&gt;(你愿意为之奋斗一生的事情是什么?)&lt;/p&gt;
&lt;p&gt;[撰写指导]&lt;/p&gt;
&lt;p&gt;“每个人都有一个觉醒期,但觉醒的早晚决定个人的命运。”一一路遥&lt;br&gt;
思考人生使命，就是在唤醒沉睡的自己。&lt;br&gt;
寥寥几句话，却能让你热血沸腾。人人都有独特的人生使命，只是有的人已经找到，有的人还在追寻，但一定有那么一件事，是能够让你感受到浓厚的使命感的。&lt;/p&gt;
&lt;p&gt;撰写「人生使命」部分，不必过于纠结。可能在现阶段想破头都没有找到让自己百分百满意的使命，但没关系，把那个你认为已经是现阶段的最佳答案写下来，未来不断寻找，持续调整，总会找到满意的答案。&lt;/p&gt;
&lt;h3 id=&#34;二-人生目标&#34;&gt;二、人生目标&lt;/h3&gt;
&lt;p&gt;(你希望自己变成什么样的人，获得什么样的成就?)&lt;/p&gt;
&lt;p&gt;[撰写指导]&lt;br&gt;
建议从富足人生的5个维度，来撰写自己的人生目标。每个维度下，也可以做更细维度的划分，这个过程，将会更加全面深刻地剖析，“你想要的人生，到底是什么样子的”。&lt;br&gt;
相信我，绝大多数人，从来没有花时间认真思考过这个问题，因为它看起来太复杂，太庞大，太虚无缥缈了。但任何一个目标的实现，都不是碰巧出来的，而是经过持续深入的思考，持续不断的践行，才得以实现的。&lt;br&gt;
撰写「人生目标」部分，需要发挥你的想象力，从不同维度去描绘你的未来，这些目标或许一辈子都无法实现，但如果你连确定目标的勇气都没有，又怎么可能实现它呢?&lt;/p&gt;
&lt;p&gt;富足人生五要素:&lt;br&gt;
身体:&lt;br&gt;
智力:&lt;br&gt;
情感:&lt;br&gt;
财富:&lt;br&gt;
人生意义:&lt;/p&gt;
&lt;h3 id=&#34;三-人生原则价值观&#34;&gt;三、人生原则(价值观)&lt;/h3&gt;
&lt;p&gt;不同的人生原则，决定了不同人生命运。&lt;br&gt;
撰写「人生原则」时，不用顾虑太多的逻辑结构，只需要把你觉得自己最希望坚持的价值观写下来即可，同时这个人生原则，也需要不断去补充和更新。&lt;/p&gt;
&lt;h2 id=&#34;四-人生策略可选&#34;&gt;四、人生策略(可选)&lt;/h2&gt;
&lt;p&gt;(为了达成目标，你需要做哪些事情?)&lt;br&gt;
人生策略，是为了达成我们的人生使命和目标。&lt;br&gt;
撰写「人生策略」时，可以对照着你的人生目标，去思考想要完成这个目标，你需要做的事情。人生策略的撰写，一定是一个大工作，在「人生基本法J中可以省略，但我希望大家在未来的日子里，能够不断地去补充完善;&lt;br&gt;
只有人生目标是不够的，还需要你去绘制自己的人生地图，而人生策略就是你需要的那份地图。&lt;/p&gt;
">四个步骤找到人生使命和目标</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/-WxTzW7cO/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://gitee.com/Ricky_Shao/upic_upload/raw/master/oss/2021%2010%2023%20sPWZfO%20.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;&amp;quot;把自律当做一种目标，是对自律本身最大的误解。&amp;quot;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;为什么会间歇性自律&#34;&gt;为什么会间歇性自律&lt;/h2&gt;
&lt;p&gt;你在最开始阶段，对自律这件事本身的理解，就出现了严重的偏差。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;首先你的认知、你的立场、你的选择、你的前期准备是正确的，&lt;strong&gt;如果你在认知上就出现了偏差&lt;/strong&gt;，那就相当于走上了一条注定会失败的路，在错误的道路上前行，无论多么努力都是徒劳。&lt;br&gt;
其实，类似的问题还有很多。我们会发现:如果把自律看做我们的目标，会很容易陷入一种极端的**“只执行不思考”**的状态，只顾低头赶路，却忘记了思考和辨别自己的人生方向。&lt;br&gt;
&lt;strong&gt;总结起来就是:错误的目标+自律的行动=灾难。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了自律而自律，就像在填一个深不见底的大坑，遥遥无期，极其痛苦。&lt;/strong&gt;&lt;br&gt;
当你一直在做一件永远看不到头的事情的时候，你是很难坚持下来的。&lt;/p&gt;
&lt;h2 id=&#34;最底层的自律动机是人生使命和目标&#34;&gt;最底层的自律动机是人生使命和目标&lt;/h2&gt;
&lt;p&gt;自律，意味着你需要以&lt;strong&gt;极度开放的心态、积极主动的态度，去面对痛苦、承担责任、解决问题&lt;/strong&gt;。自律，是帮助我们实现人生目标的&lt;strong&gt;方法、路径和工具&lt;/strong&gt;。几乎所有的目标实现，都需要你付诸自律的行动，才能够达成。&lt;br&gt;
了解完自律的定义后，那么，能够让我们持续不断地保持自律，最底层的动机来源是什么呢?&lt;br&gt;
我们都知道，任何事情都离不开两个范畴。一个是“道”，一个是“术”，所谓**“道”，是最宏观的原则、方向，所谓“术”是我们微观的方法、策略。**&lt;br&gt;
而我们经常会花太多时间纠结和痛苦于自律的“术”，却从来没有认真思考过，自律的“道”。&lt;br&gt;
自律的道，就是我们的人生使命和目标。&lt;br&gt;
那么，问题又来了，&lt;strong&gt;人生使命和目标&lt;/strong&gt;又是什么呢?&lt;br&gt;
有的人渴望事业有成、实现财务自由，有的人希望家庭幸福，美满一生，有的人可能就想着每天开心就好。&lt;br&gt;
我试着对人生目标做了一个简单的提炼。我理解，无论何种目标，也无论有多少维度的目标，我们的人生目标都可以用一句话来解释，那就是:&lt;br&gt;
你这一辈子，&lt;strong&gt;想达到什么样的目标?想成为什么样的人?想获得什么样的成就?&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;思考一种人生状态富足人生&#34;&gt;思考一种人生状态:富足人生&lt;/h2&gt;
&lt;p&gt;仅仅是单一维度的人生目标，对于我们整个人生来说，是极不稳定的，甚至说是摇摇欲坠的。因为，我们的人生本身就是漫长的、复杂的、充满不确定性的。&lt;br&gt;
因此，我们在思考人生目标的时候，要有&lt;strong&gt;多维度的综合思维，从多个方面来组合我们的人生目标&lt;/strong&gt;，才能更加全面和稳定，我们的自律动机才足够坚定。&lt;br&gt;
富足人生，是指我们的人生无论在任何一个维度或者要素下，都能够获得一种丰富、充盈、满足的体验。&lt;br&gt;
富足的人生目标有五个纬度：&lt;strong&gt;第一:身体、第二:智力、第三:情感、第四:财富、第五:人生意义。&lt;/strong&gt;&lt;/p&gt;
">为什么真正自律的人，从来都不把自律当目标?</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/jiu-shou-ji-gai-zao-ji-hua-da-jian-aira2yi-ji-ji-qi-bian-jie-de-wang-ye-guan-li-wen-jian-fang-fa/"" data-c="
          &lt;h3 id=&#34;本文所需的工具ksweb可道云termux&#34;&gt;本文所需的工具：ksweb，可道云，termux&lt;/h3&gt;
&lt;h3 id=&#34;网站管理文件方法&#34;&gt;网站管理文件方法：&lt;/h3&gt;
&lt;p&gt;从&lt;a href=&#34;https://kodcloud.com/&#34;&gt;可道云官网&lt;/a&gt;下好源码解压到你用ksweb搭建的文件夹（参考我之前发的文章&lt;a href=&#34;http://ricky.shineteens.com/index.php/archives/13/&#34;&gt;旧手机搭建网站&lt;/a&gt;）然后建议文件夹改个好记的名字，然后进入&lt;a href=&#34;http://localhost/&#34;&gt;http://localhost&lt;/a&gt;:8080/你文件夹的名字。改个密码就完事了！以后你就可以随时访问这个目录访问你手机的文件夹了，只要你ksweb不被后台杀掉的话&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://img.imgdb.cn/item/606a0d218322e6675ce6b2c2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;aira2搭建&#34;&gt;aira2搭建&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;pkg install aira2
aria2c --enable-rpc --rpc-listen-all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想在浏览器上访问你的aira2的话，可以执行以下代码 先安装nodejs环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkg install nodejs
git clone https://github.com/ziahamza/webui-aria2.git
cd webui-aria2
node node-server.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;利用ftp访问文件&#34;&gt;&lt;img src=&#34;https://img.imgdb.cn/item/606a0cd28322e6675ce68832.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
利用ftp访问文件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ES浏览器——网络——从PC访问，然后在电脑上的资源管理器输入它给你的地址就好了，也可以在“增加一个网络位置”中输入那个地址&lt;br&gt;
优点：&lt;br&gt;
方便简单，对小白极其友好&lt;br&gt;
缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手机后台多跑一个应用，除非你打算下次临时访问时去打开&lt;/li&gt;
&lt;li&gt;如果映射到外网，没有用户名密码意味着别人输了地址就可以操作你手机文件了&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KSweb上的ftp创建一个用户，然后电脑访问你的手机地址，一般为192.168.0.x:2121(x为随机地址，可以到路由器后台看，也可以在termux输入ipconfig -a查看，端口不一定是2121，具体看ksweb的主页怎么显示的），输入用户名密码就可以看见你手机的文件夹了&lt;br&gt;
优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网站在ftp就在，只要ksweb不死你就可以随时访问&lt;/li&gt;
&lt;li&gt;有用户名密码，安全性很强&lt;br&gt;
缺点：&lt;br&gt;
除了有些小白可能操作半天外还真没什么缺点了，建议优先考虑&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://img.imgdb.cn/item/606a0cc28322e6675ce67ee3.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;另外我的图片是从电脑访问处截图的，所以请不要模仿上面的地址。&lt;/p&gt;
">旧手机改造计划——搭建aira2，以及极其便捷的网页管理文件方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;努力分享一些好玩实用的内容，虽然不算多！&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;立志实现财富自由的Coder～&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;p&gt;探索Github、学点有趣的东西、健身羽毛球那些……&lt;/p&gt;
&lt;h2 id=&#34;️技术栈&#34;&gt;🤹‍♂️技术栈&lt;/h2&gt;
&lt;p&gt;Vue 🌟🌟🌟🌟🌟&lt;br&gt;
Python 🌟🌟🌟🌟🌟&lt;br&gt;
MogoDB 🌟🌟🌟&lt;br&gt;
MySQL 🌟🌟🌟&lt;br&gt;
C++ 🌟🌟🌟&lt;br&gt;
Docker🌟🌟🌟&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;Email:veithly@163.com&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://ricky.shineteens.com/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;br&gt;
😨讲真，这又是一次博客搬迁，从群晖偶然挂了我就觉得还是要找个可靠的地方记录文字，别再瞎整一些乱七八糟的玩意来浪费时间了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;🤔再三思量后，我打算使用静态页面来配置搭建博客，之前php+mysql的cms像wordpress和typecho虽然简单无脑，但出事后重整太难受了。在做出静态页面的选择时我考虑过hexo,hugo，但还是偶然发现Gridea这个神奇的玩意，虽然说好像操作比较无脑，但考虑到我折腾hexo一直支棱不起来连发篇文章都费劲就觉得无脑的东西也挺好的。多花点时间看几篇paper，学学东西不香吗？&lt;br&gt;
😏github的page功能访问确实蛋疼，其他的仓库又不太支持，但还好我域名备案了，这就可以每月嫖腾讯的10GB CDN，访问速度还是挺ok的，至少比之前白嫖frp时不时宕机要舒服点。&lt;br&gt;
🤒用什么CSDN、知乎、简书记录东西也不是不行，但我还是不太喜欢自己的内容掌控在别的网站上，写个东西还要被放别人的广告白嫖挺不爽的。但毕竟人家流量是有的，等我有精力还是会考虑做个同步的玩意一键多平台分发。&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;h2 id=\&#34;框架集合\&#34;&gt;框架集合&lt;/h2&gt;\n&lt;p&gt;微服务是分布式架构的最佳实践方案，那这种方案它也需要具体的技术框架去落地。所以在全球有很多的互联网公司也都在去尝试开发自己的微服务落地技术。但是在这些技术里，真正广为人知的就是Spring Cloud。Spring Cloud 以微服务为核心的分布式系统构建标准，是一系列框架的有序集合，直至现在，由不同编程语言、不同技术框架所开发的微服务系统中，基于 Spring Cloud 的解决方案仍然是最为主流的选择。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://spring.io/projects/spring-cloud\&#34;&gt;Spring Cloud&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://spring.io/projects/spring-cloud-alibaba\&#34;&gt;Spring Cloud Alibaba&lt;/a&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fcb02ae2c64.jpg\&#34; alt=\&#34;62fcb02ae2c64\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;Spring Cloud Alibaba的微服务系统可以拆分成图中的架构：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fcb1f47f158.jpg\&#34; alt=\&#34;62fcb1f47f158\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;除了Spring Cloud，还有一些其他方案的框架可以选用，如:&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.cloudwego.io/zh/\&#34;&gt;CloudWeGo&lt;/a&gt;，是一套由字节跳动开源的、可快速构建企业级云原生微服务架构的中间件集合。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://tarscloud.org/\&#34;&gt;Tars&lt;/a&gt;，是一套高性能、多语言的微服务治理框架。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://dubbo.apache.org/\&#34;&gt;Dubbo&lt;/a&gt;，是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案，&lt;br&gt;\n涵盖 Java、Golang 等多种语言 SDK 实现。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/senecajs/seneca\&#34;&gt;Seneca&lt;/a&gt;，微服务架构的node.js的工具集。&lt;/p&gt;\n&lt;h2 id=\&#34;注册发现服务\&#34;&gt;注册发现服务&lt;/h2&gt;\n&lt;h3 id=\&#34;nacos\&#34;&gt;Nacos&lt;/h3&gt;\n&lt;p&gt;Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://nacos.io/zh-cn/index.html\&#34;&gt;Nacos&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;consul\&#34;&gt;Consul&lt;/h3&gt;\n&lt;p&gt;Consul是一个基于微服务的服务发现和管理工具，可以让我们轻松地管理和发现微服务，并且可以让我们轻松地管理微服务的负载均衡。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.consul.io/\&#34;&gt;Consul&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;eureka\&#34;&gt;Eureka&lt;/h3&gt;\n&lt;p&gt;Eureka是Netflix开发的服务发现框架，本身是一个基于REST的服务，主要用于定位运行在微服务的中间层服务，以达到负载均衡和中间层服务故障转移的目的。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/Netflix/eureka\&#34;&gt;Eureka&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;zookeeper\&#34;&gt;Zookeeper&lt;/h3&gt;\n&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://zookeeper.apache.org/\&#34;&gt;ZooKeeper&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;服务之间的通讯\&#34;&gt;服务之间的通讯&lt;/h2&gt;\n&lt;h3 id=\&#34;thift\&#34;&gt;thift&lt;/h3&gt;\n&lt;p&gt;Apache thift 软件框架，用于可扩展的跨语言服务开发，结合了软件栈和代码生成引擎，可以在 C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk、OCaml 和 Delphi 等语言之间高效、无缝地构建服务。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://thrift.apache.org/\&#34;&gt;thift&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;grpc\&#34;&gt;gRPC&lt;/h3&gt;\n&lt;p&gt;GRPC 是一个现代的开源高性能远程过程调用(Remote Process Call，RPC)框架，可以在任何环境中运行。它可以通过可插拔的负载平衡、跟踪、健康检查和身份验证支持，有效地连接数据中心内和数据中心之间的服务。它还适用于物联网设备、移动应用程序和浏览器到后端服务的最后一公里分布式计算。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://grpc.io/\&#34;&gt;gRPC&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;dubbo\&#34;&gt;Dubbo&lt;/h3&gt;\n&lt;p&gt;Dubbo 是一款微服务框架，为微服务提供高性能 RPC 通信，提供 Java、Golang 等语言 SDK 实现。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://dubbo.apache.org/zh/\&#34;&gt;Dubbo&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;tars\&#34;&gt;Tars&lt;/h3&gt;\n&lt;p&gt;Tars 是一个高性能、多语言的微服务治理框架。为微服务提供 RPC 通信，提供C++、Java、Go、JavaScript、php 等语言 SDK 实现，还可以部署在k8s集群上。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://tarscloud.org/\&#34;&gt;Tars&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;feign\&#34;&gt;feign&lt;/h3&gt;\n&lt;p&gt;feign是一个RESTful客户端框架，主要用于Java。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/OpenFeign/feign\&#34;&gt;feign&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;kitex\&#34;&gt;Kitex&lt;/h3&gt;\n&lt;p&gt;Kitex 是字节跳动内部的 Golang 微服务 RPC 框架，具有高性能、强可扩展的特点。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.cloudwego.io/zh/docs/kitex/overview/\&#34;&gt;Kitex&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;hertz\&#34;&gt;Hertz&lt;/h3&gt;\n&lt;p&gt;Hertz 是一个 Golang 微服务 HTTP 框架，在设计之初参考了其他开源框架 fasthttp、gin、echo 的优势， 并结合字节跳动内部的需求，使其具有高易用性、高性能、高扩展性等特点。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.cloudwego.io/zh/docs/hertz/overview/\&#34;&gt;Hertz&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;负载均衡\&#34;&gt;负载均衡&lt;/h2&gt;\n&lt;h3 id=\&#34;ribbon\&#34;&gt;Ribbon&lt;/h3&gt;\n&lt;p&gt;Ribbon 是一个内置了软件负载平衡器的进程间通信(远程过程调用)库。主要使用模型包括带有各种序列化方案支持的 REST 调用。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/Netflix/ribbon\&#34;&gt;Ribbon&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;网关\&#34;&gt;网关&lt;/h2&gt;\n&lt;h3 id=\&#34;spring-cloud-gateway\&#34;&gt;Spring Cloud Gateway&lt;/h3&gt;\n&lt;p&gt;Spring Cloud Gateway 是一个网关服务，用于将多个服务集成到一个网关服务中，并且提供统一的访问接口。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://spring.io/projects/spring-cloud-gateway\&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;zuul\&#34;&gt;Zuul&lt;/h3&gt;\n&lt;p&gt;Zuul 是一个提供动态路由、监视、弹性、安全等功能的网关服务。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/Netflix/zuul\&#34;&gt;Zuul&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;容错保护\&#34;&gt;容错保护&lt;/h2&gt;\n&lt;h3 id=\&#34;sentinel\&#34;&gt;Sentinel&lt;/h3&gt;\n&lt;p&gt;Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://sentinelguard.io/zh-cn/\&#34;&gt;Sentinel&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;hystrix\&#34;&gt;Hystrix&lt;/h3&gt;\n&lt;p&gt;Hystrix是由Netflflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/Netflix/Hystrix\&#34;&gt;Hystrix&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;resilience4j\&#34;&gt;Resilience4j&lt;/h3&gt;\n&lt;p&gt;Resilicence4J一款非常轻量、简单，并且文档非常清晰、丰富的熔断工具，这也是Hystrix官方推荐的替代产品。不仅如此，Resilicence4j还原生支持Spring Boot 1.x/2.x，而且监控也支持和prometheus等多款主流产品进行整合。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/resilience4j/resilience4j\&#34;&gt;Resilience4j&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;链路追踪\&#34;&gt;链路追踪&lt;/h2&gt;\n&lt;h3 id=\&#34;zipkin\&#34;&gt;Zipkin&lt;/h3&gt;\n&lt;p&gt;Zipkin分布式跟踪系统；它可以帮助收集时间数据，解决在微服务架构下的延迟问题；它管理这些数据的收集和查找。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://zipkin.io/\&#34;&gt;Zipkin&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;skywalking\&#34;&gt;Skywalking&lt;/h3&gt;\n&lt;p&gt;Skywalking 是用于分布式系统的应用程序性能监视工具，特别是为微服务、云本地和基于容器(Kubernetes)架构设计的。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://skywalking.apache.org/\&#34;&gt;Skywalking&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;jaeger\&#34;&gt;Jaeger&lt;/h3&gt;\n&lt;p&gt;Jaeger 是一个开源端到端分布式跟踪，监视和排除复杂分布式系统中的事务。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.jaegertracing.io/\&#34;&gt;Jaeger&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;分布式事务\&#34;&gt;分布式事务&lt;/h2&gt;\n&lt;h3 id=\&#34;seata\&#34;&gt;Seata&lt;/h3&gt;\n&lt;p&gt;Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://seata.io/zh-cn/index.html\&#34;&gt;Seata&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;数据存储\&#34;&gt;数据存储&lt;/h2&gt;\n&lt;h3 id=\&#34;minio\&#34;&gt;Minio&lt;/h3&gt;\n&lt;p&gt;MinIO 提供高性能、 S3兼容的对象存储。原产于 Kubernetes 的 minIO 是唯一可用于所有公共云、Kubernetes 发行版、私有云和边缘储存的对象存储套件。MinIO 在 GNU AGPL v3下是100% 开源的。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://min.io/\&#34;&gt;Minio&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;服务部署\&#34;&gt;服务部署&lt;/h2&gt;\n&lt;h3 id=\&#34;kubernetes\&#34;&gt;Kubernetes&lt;/h3&gt;\n&lt;p&gt;Kubernetes是Google开源的一个容器编排引擎，它支持自动化部署、大规模可伸缩、应用容器化管理。在生产环境中部署一个应用程序时，通常要部署该应用的多个实例以便对应用请求进行负载均衡。&lt;/p&gt;\n&lt;p&gt;在Kubernetes中，我们可以创建多个容器，每个容器里面运行一个应用实例，然后通过内置的负载均衡策略，实现对这一组应用实例的管理、发现、访问，而这些细节都不需要运维人员去进行复杂的手工配置和处理。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://kubernetes.io/\&#34;&gt;Kubernetes&lt;/a&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;docker\&#34;&gt;Docker&lt;/h3&gt;\n&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.docker.com/\&#34;&gt;Docker&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;2Xxn7pCb3&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;框架集合\&#34;&gt;框架集合&lt;/h2&gt;\n&lt;p&gt;微服务是分布式架构的最佳实践方案，那这种方案它也需要具体的技术框架去落地。所以在全球有很多的互联网公司也都在去尝试开发自己的微服务落地技术。但是在这些技术里，真正广为人知的就是Spring Cloud。Spring Cloud 以微服务为核心的分布式系统构建标准，是一系列框架的有序集合，直至现在，由不同编程语言、不同技术框架所开发的微服务系统中，基于 Spring Cloud 的解决方案仍然是最为主流的选择。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://spring.io/projects/spring-cloud\&#34;&gt;Spring Cloud&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://spring.io/projects/spring-cloud-alibaba\&#34;&gt;Spring Cloud Alibaba&lt;/a&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fcb02ae2c64.jpg\&#34; alt=\&#34;62fcb02ae2c64\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;title&#34;:&#34;微服务｜现有技术框架选型与资料整理&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;微服务&#34;,&#34;slug&#34;:&#34;tzlLItuaD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/tzlLItuaD/&#34;}],&#34;date&#34;:&#34;2022-08-25 11:01:16&#34;,&#34;dateFormat&#34;:&#34;2022-08-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/2Xxn7pCb3/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:390000,&#34;words&#34;:1799,&#34;minutes&#34;:7},&#34;description&#34;:&#34;框架集合\n微服务是分布式架构的最佳实践方案，那这种方案它也需要具体的技术框架去落地。所以在全球有很多的互联网公司也都在去尝试开发自己的微服务落地技术。但是在这些技术里，真正广为人知的就是Spring Cloud。Spring Cloud 以...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A1%86%E6%9E%B6%E9%9B%86%E5%90%88\&#34;&gt;框架集合&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B3%A8%E5%86%8C%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1\&#34;&gt;注册发现服务&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#nacos\&#34;&gt;Nacos&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#consul\&#34;&gt;Consul&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#eureka\&#34;&gt;Eureka&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#zookeeper\&#34;&gt;Zookeeper&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E8%AE%AF\&#34;&gt;服务之间的通讯&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#thift\&#34;&gt;thift&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#grpc\&#34;&gt;gRPC&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dubbo\&#34;&gt;Dubbo&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tars\&#34;&gt;Tars&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#feign\&#34;&gt;feign&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#kitex\&#34;&gt;Kitex&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#hertz\&#34;&gt;Hertz&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\&#34;&gt;负载均衡&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ribbon\&#34;&gt;Ribbon&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BD%91%E5%85%B3\&#34;&gt;网关&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#spring-cloud-gateway\&#34;&gt;Spring Cloud Gateway&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#zuul\&#34;&gt;Zuul&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%B9%E9%94%99%E4%BF%9D%E6%8A%A4\&#34;&gt;容错保护&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#sentinel\&#34;&gt;Sentinel&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#hystrix\&#34;&gt;Hystrix&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#resilience4j\&#34;&gt;Resilience4j&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA\&#34;&gt;链路追踪&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#zipkin\&#34;&gt;Zipkin&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#skywalking\&#34;&gt;Skywalking&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jaeger\&#34;&gt;Jaeger&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1\&#34;&gt;分布式事务&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#seata\&#34;&gt;Seata&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\&#34;&gt;数据存储&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#minio\&#34;&gt;Minio&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2\&#34;&gt;服务部署&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#kubernetes\&#34;&gt;Kubernetes&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#docker\&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;之前的文章里讲了Promise的好处以及具体应用，不了解Promise用法的读者可以移步到这里：&lt;a href=\&#34;https://ricky.shineteens.com/post/lgixxdcqc/\&#34;&gt;JavaScript｜Promise使用详解&lt;/a&gt;。这里我们主要来看看Promise是怎么实现的。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;promise结构设计\&#34;&gt;Promise结构设计&lt;/h2&gt;\n&lt;p&gt;如果要实现一个Promise，应该按照Promise A+规范来设计：&lt;a href=\&#34;https://promisesaplus.com/\&#34;&gt;Promise A+&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;\nconst PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;\nconst PROMISE_STATUS_REJECTED = &#39;rejected&#39;\n\nclass myPromise{\n    constructor(executor) {\n        this.status = PROMISE_STATUS_PENDING\n        this.value = undefined\n        this.reason = undefined\n\n        const resolve = (value) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行\n                this.status = PROMISE_STATUS_FULFILLED\n                console.log(&#39;resolve called&#39;);\n                this.value = value\n            }\n        }\n        const reject = (reason) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) {\n                this.status = PROMISE_STATUS_REJECTED\n                console.log(&#39;reject called&#39;);\n                this.reason = reason\n            }\n        }\n        executor(resolve, reject) // 调用resolve/reject方法\n    }\n}\n\nconst promise = new myPromise((resolve, reject) =&amp;gt; {\n    console.log(&#39;执行了&#39;); // 执行了\n    resolve() // resolve called\n    reject() // 要注意，这里不会调用reject方法\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promisethen方法设计\&#34;&gt;Promise.then方法设计&lt;/h2&gt;\n&lt;p&gt;Promise.then方法是Promise的核心方法，它的作用是：当Promise的状态变为fulfilled或rejected时，执行then方法的回调函数，但是调用这个方法有需要考虑很多问题，如多次调用，链式调用，以及调用时Promise的状态等等。&lt;/p&gt;\n&lt;h3 id=\&#34;then方法基本结构\&#34;&gt;then方法基本结构&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;\nconst PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;\nconst PROMISE_STATUS_REJECTED = &#39;rejected&#39;\n\nclass myPromise{\n    constructor(executor) {\n        this.status = PROMISE_STATUS_PENDING\n        this.value = undefined\n        this.reason = undefined\n\n        const resolve = (value) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行\n                this.status = PROMISE_STATUS_FULFILLED\n                queueMicrotask(() =&amp;gt; { // 异步执行，先执行then方法，将onFulfilled方法放入队列中\n                    this.value = value\n                    this.onfulfilled&amp;amp;&amp;amp;this.onfulfilled(value)\n                })\n            }\n        }\n        const reject = (reason) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) {\n                this.status = PROMISE_STATUS_REJECTED\n                queueMicrotask(() =&amp;gt; {\n                    this.reason = reason\n                    this.onrejected&amp;amp;&amp;amp;this.onrejected(reason)\n                })\n            }\n        }\n        executor(resolve, reject) // 调用resolve/reject方法\n    }\n\n    then(onfulfilled, onrejected) {\n        this.onfulfilled = onfulfilled\n        this.onrejected = onrejected\n    }\n}\n\nconst promise = new myPromise((resolve, reject) =&amp;gt; {\n    console.log(&#39;执行了&#39;); // 执行了\n    resolve(&#39;res&#39;)\n}).then(res =&amp;gt; {\n    console.log(res) // res\n}, err =&amp;gt; {\n    console.log(err)\n})\n\nconst promise1 = new myPromise((resolve, reject) =&amp;gt; {\n    console.log(&#39;执行了&#39;); // 执行了\n    reject(&#39;err&#39;)\n}).then(res =&amp;gt; {\n    console.log(res)\n}, err =&amp;gt; {\n    console.log(err) // err\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;then方法多次调用\&#34;&gt;then方法多次调用&lt;/h3&gt;\n&lt;p&gt;上述实现的then虽然能够实现，但如果再次添加then方法的时候会覆盖掉onfulfilled和onrejected，所以需要添加一个多次调用的方法。这里我们将方法加入到数组中，然后遍历数组，执行每一个方法。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;\nconst PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;\nconst PROMISE_STATUS_REJECTED = &#39;rejected&#39;\n\nclass myPromise{\n    constructor(executor) {\n        this.status = PROMISE_STATUS_PENDING\n        this.value = undefined\n        this.reason = undefined\n        this.onfulfilledFns = []\n        this.onrejectedFns = []\n\n        const resolve = (value) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行\n                queueMicrotask(() =&amp;gt; { // 异步执行，先执行then方法，将onFulfilled方法放入队列中\n                    if (this.status !== PROMISE_STATUS_PENDING) return // 如果状态已经变化，则不执行\n                    this.status = PROMISE_STATUS_FULFILLED // 设置状态，放在微任务队列可以保证状态变化的时候，不会执行then方法\n                    this.value = value\n                    this.onfulfilledFns.forEach(fn =&amp;gt; {\n                        fn(this.value)\n                    })\n                })\n            }\n        }\n        const reject = (reason) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) {\n                queueMicrotask(() =&amp;gt; {\n                    if (this.status !== PROMISE_STATUS_PENDING) return\n                    this.status = PROMISE_STATUS_REJECTED\n                    this.reason = reason\n                    this.onfulfilledFns.forEach(fn =&amp;gt; {\n                        fn(this.reason)\n                    })\n                })\n            }\n        }\n        executor(resolve, reject) // 调用resolve/reject方法\n    }\n\n    then(onfulfilled, onrejected) {\n        // 调用then时，状态确，例如setTimeout(() =&amp;gt; {}, 0)，那么就会立即执行onfulfilled方法，而不是将方法放入队列中\n        if (this.status === PROMISE_STATUS_FULFILLED) {\n            onfulfilled(this.value)\n        } else if (this.status === PROMISE_STATUS_REJECTED) {\n            onrejected(this.reason)\n        } \n        // 将成功回调和失败回调放入数组中\n        if (this.status === PROMISE_STATUS_PENDING) {\n            this.onfulfilledFns.push(onfulfilled)\n            this.onrejectedFns.push(onrejected)\n        }\n    }\n}\n\nconst promise = new myPromise((resolve, reject) =&amp;gt; {\n    console.log(&#39;执行了&#39;); // 执行了\n    resolve(&#39;res&#39;)\n    reject(&#39;err&#39;)\n})\n\n// 调用then方法多次调用\npromise.then(res =&amp;gt; {\n  console.log(&amp;quot;res1:&amp;quot;, res)\n}, err =&amp;gt; {\n  console.log(&amp;quot;err:&amp;quot;, err)\n})\n\npromise.then(res =&amp;gt; {\n  console.log(&amp;quot;res2:&amp;quot;, res)\n}, err =&amp;gt; {\n  console.log(&amp;quot;err2:&amp;quot;, err)\n})\n\n// 在确定Promise状态之后, 再次调用then\nsetTimeout(() =&amp;gt; {\n  promise.then(res =&amp;gt; {\n    console.log(&amp;quot;res3:&amp;quot;, res)\n  }, err =&amp;gt; {\n    console.log(&amp;quot;err3:&amp;quot;, err)\n  })\n}, 1000)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;then方法的链式调用\&#34;&gt;then方法的链式调用&lt;/h3&gt;\n&lt;p&gt;上述实现的then方法多次调用，但如果在一个then后面再次调用then方法，则会报错，原因是then没有返回，我们需要在then函数中添加一个返回值，返回一个新的myPromise对象。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;\nconst PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;\nconst PROMISE_STATUS_REJECTED = &#39;rejected&#39;\n\n// 抽离try catch函数储存返回值\nfunction execFunctionWithCatchError(execFn, value, resolve, reject) {\n    try {\n        const reason = execFn(value)\n        resolve(reason)   \n    } catch (error) {\n        reject(error)\n    }\n}\n\nclass myPromise{\n    constructor(executor) {\n        this.status = PROMISE_STATUS_PENDING\n        this.value = undefined\n        this.reason = undefined\n        this.onfulfilledFns = []\n        this.onrejectedFns = []\n\n        const resolve = (value) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行\n                queueMicrotask(() =&amp;gt; { // 异步执行，先执行then方法，将onFulfilled方法放入队列中\n                    if (this.status !== PROMISE_STATUS_PENDING) return // 如果状态已经变化，则不执行\n                    this.status = PROMISE_STATUS_FULFILLED // 设置状态，放在微任务队列可以保证状态变化的时候，不会执行then方法\n                    this.value = value\n                    this.onfulfilledFns.forEach(fn =&amp;gt; {\n                        fn(this.value)\n                    })\n                })\n            }\n        }\n        const reject = (reason) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) {\n                queueMicrotask(() =&amp;gt; {\n                    if (this.status !== PROMISE_STATUS_PENDING) return\n                    this.status = PROMISE_STATUS_REJECTED\n                    this.reason = reason\n                    this.onrejectedFns.forEach(fn =&amp;gt; {\n                        fn(this.reason)\n                    })\n                })\n            }\n        }\n        try { // 第一个promise可能报错，报错信息需要通过REJECT方法传递给第二个promise\n            executor(resolve, reject) // 调用resolve/reject方法\n        } catch (err) {\n            reject(err)\n        }\n    }\n\n    then(onfulfilled, onrejected) {\n        return new myPromise((resolve, reject) =&amp;gt; { // 直接返回这个promise，如果没有then会直接执行\n            // 调用then时，状态确，例如setTimeout(() =&amp;gt; {}, 0)，那么就会立即执行onfulfilled方法，而不是将方法放入队列中\n            if (this.status === PROMISE_STATUS_FULFILLED &amp;amp;&amp;amp; resolve) {\n                // try { //回调函数需要获取结果或者报错，所以需要try catch\n                //     const value = onfulfilled(this.value)\n                //     resolve(value)\n                // } catch (error) {\n                //     reject(error)\n                // }\n                execFunctionWithCatchError(onfulfilled, this.value, resolve, reject)\n            } else if (this.status === PROMISE_STATUS_REJECTED &amp;amp;&amp;amp; onrejected) {\n                execFunctionWithCatchError(onrejected, this.reason, resolve, reject)\n            } \n            // 将成功回调和失败回调放入数组中\n            if (this.status === PROMISE_STATUS_PENDING) {\n                this.onfulfilledFns.push(() =&amp;gt; {\n                    execFunctionWithCatchError(onfulfilled, this.value, resolve, reject)\n                })\n                this.onrejectedFns.push(() =&amp;gt; {\n                    execFunctionWithCatchError(onrejected, this.reason, resolve, reject)\n                })\n            }\n        })\n    }\n}\n\nconst promise = new myPromise((resolve, reject) =&amp;gt; {\n    console.log(&#39;执行了&#39;); // 执行了\n    resolve(&#39;res&#39;)\n    reject(&#39;err&#39;)\n})\n\n// 调用then方法多次调用\npromise.then(res =&amp;gt; {\n  console.log(&amp;quot;res1:&amp;quot;, res)\n  return &amp;quot;aaaa&amp;quot;\n  // throw new Error(&amp;quot;err message&amp;quot;)\n}, err =&amp;gt; {\n  console.log(&amp;quot;err1:&amp;quot;, err)\n  return &amp;quot;bbbbb&amp;quot;\n  // throw new Error(&amp;quot;err message&amp;quot;)\n}).then(res =&amp;gt; {\n  console.log(&amp;quot;res2:&amp;quot;, res)\n}, err =&amp;gt; {\n  console.log(&amp;quot;err2:&amp;quot;, err)\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promisecatch方法设计\&#34;&gt;Promise.catch方法设计&lt;/h2&gt;\n&lt;p&gt;Promise.catch方法是Promise.prototype.then方法的简化版本，当Promise的状态变为rejected时，会调用参数函数，并将Promise的reason作为参数传入函数。在这里可以直接调用then方法来实现吗，除了调用then，还需要设置相关的边界条件处理undefined，并且要确保resolve和reject方法的返回值能够被下一个方法捕获到。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;const PROMISE_STATUS_PENDING = &#39;pending&#39;\nconst PROMISE_STATUS_FULFILLED = &#39;fulfilled&#39;\nconst PROMISE_STATUS_REJECTED = &#39;rejected&#39;\n\n// 抽离try catch函数储存返回值\nfunction execFunctionWithCatchError(execFn, value, resolve, reject) {\n    try {\n        const reason = execFn(value)\n        resolve(reason)   \n    } catch (error) {\n        reject(error)\n    }\n}\n\nclass myPromise{\n    constructor(executor) {\n        this.status = PROMISE_STATUS_PENDING\n        this.value = undefined\n        this.reason = undefined\n        this.onfulfilledFns = []\n        this.onrejectedFns = []\n\n        const resolve = (value) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) { // 设置状态使得其他状态的代码不会执行\n                queueMicrotask(() =&amp;gt; { // 异步执行，先执行then方法，将onFulfilled方法放入队列中\n                    if (this.status !== PROMISE_STATUS_PENDING) return // 如果状态已经变化，则不执行\n                    this.status = PROMISE_STATUS_FULFILLED // 设置状态，放在微任务队列可以保证状态变化的时候，不会执行then方法\n                    this.value = value\n                    this.onfulfilledFns.forEach(fn =&amp;gt; {\n                        fn(this.value)\n                    })\n                })\n            }\n        }\n        const reject = (reason) =&amp;gt; {\n            if (this.status === PROMISE_STATUS_PENDING) {\n                queueMicrotask(() =&amp;gt; {\n                    if (this.status !== PROMISE_STATUS_PENDING) return\n                    this.status = PROMISE_STATUS_REJECTED\n                    this.reason = reason\n                    this.onrejectedFns.forEach(fn =&amp;gt; {\n                        fn(this.reason)\n                    })\n                })\n            }\n        }\n        try { // 第一个promise可能报错，报错信息需要通过REJECT方法传递给第二个promise\n            executor(resolve, reject) // 调用resolve/reject方法\n        } catch (err) {\n            reject(err)\n        }\n    }\n\n    then(onfulfilled, onrejected) {\n        // catch 传入 undefined 会抛出异常，让 promise 去调用下一个 reject\n        const defaultOnRejected = err =&amp;gt; {throw err}\n        onrejected = onrejected || defaultOnRejected\n        // resolve 也需要返回\n        const defaultOnFulfilled = value =&amp;gt; { value }\n        onfulfilled = onfulfilled || defaultOnFulfilled\n\n        return new myPromise((resolve, reject) =&amp;gt; { // 直接返回这个promise，如果没有then会直接执行\n            // 调用then时，状态确，例如setTimeout(() =&amp;gt; {}, 0)，那么就会立即执行onfulfilled方法，而不是将方法放入队列中\n            if (this.status === PROMISE_STATUS_FULFILLED &amp;amp;&amp;amp; onfulfilled) {\n                //回调函数需要获取结果或者报错，所以需要try catch\n                execFunctionWithCatchError(onfulfilled, this.value, resolve, reject)\n            } \n            if (this.status === PROMISE_STATUS_REJECTED &amp;amp;&amp;amp; onrejected) {\n                execFunctionWithCatchError(onrejected, this.reason, resolve, reject)\n            } \n            // 将成功回调和失败回调放入数组中\n            if (this.status === PROMISE_STATUS_PENDING) {\n                // catch 会传入 undefined\n                if (onfulfilled) this.onfulfilledFns.push(() =&amp;gt; {\n                    execFunctionWithCatchError(onfulfilled, this.value, resolve, reject)\n                })\n                if (onrejected) this.onrejectedFns.push(() =&amp;gt; {\n                    execFunctionWithCatchError(onrejected, this.reason, resolve, reject)\n                })\n            }\n        })\n    }\n\n    catch(onrejected) {\n        return this.then(undefined, onrejected) // 将实例返回出来，以便下一个方法调用\n    }\n}\n\nconst promise = new myPromise((resolve, reject) =&amp;gt; {\n    console.log(&#39;执行了&#39;); // 执行了\n    // resolve(&#39;res&#39;)\n    reject(&#39;err&#39;)\n})\n\n// 调用catch方法\npromise.then(res =&amp;gt; {\n  console.log(&amp;quot;res:&amp;quot;, res)\n}).catch(err =&amp;gt; {\n  console.log(&amp;quot;err:&amp;quot;, err) // err: err\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promisefinally方法设计\&#34;&gt;Promise.finally方法设计&lt;/h2&gt;\n&lt;p&gt;Promise.finally的实现可以直接在将then方法下的两个参数传入finally的方法实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;class myPromise{\n    //...其余方法同上，注意catch方法\n    finally(onFinally) {\n        this.then(() =&amp;gt; onFinally(), () =&amp;gt; onFinally())\n    }\n}\n\nconst promise = new myPromise((resolve, reject) =&amp;gt; {\n    console.log(&#39;执行了&#39;); // 执行了\n    resolve(&#39;res&#39;)\n}).then((res) =&amp;gt; {\n    console.log(&amp;quot;res:&amp;quot;, res) // res: res\n}).catch((err) =&amp;gt; {\n    console.log(&amp;quot;err:&amp;quot;, err)\n}).finally(() =&amp;gt; {\n    console.log(&amp;quot;finally&amp;quot;) // finally\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promiseresolve-promisereject方法直接实现\&#34;&gt;Promise.resolve &amp;amp;&amp;amp; Promise.reject方法直接实现&lt;/h2&gt;\n&lt;p&gt;通过设置静态函数来 new 一个新的 promise 就可以了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;class myPromise{\n    //...其余方法同上\n    static resolve(value) {\n        return new myPromise((resolve, reject) =&amp;gt; {\n            resolve(value)\n        })\n    }\n    static reject(reason) {\n        return new myPromise((resolve, reject) =&amp;gt; {\n            reject(reason)\n        })\n    }\n}\n\nmyPromise.resolve(&#39;Hello World&#39;).then(res =&amp;gt; {\n    console.log(&amp;quot;res:&amp;quot;, res) // res: Hello World\n})\n\nmyPromise.reject(&#39;err&#39;).catch(err =&amp;gt; {\n    console.log(&amp;quot;err:&amp;quot;, err) // err: err\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promiseall-promiseallsettled方法实现\&#34;&gt;Promise.all &amp;amp;&amp;amp; Promise.allSettled方法实现&lt;/h2&gt;\n&lt;p&gt;两个方法都是通过对数组进行遍历，分别执行Promise，但不同的是：Promise.allSettled返回的是一个数组，数组中的每一项是一个Promise的状态，而Promise.all返回的是一个Promise，Promise.all返回的Promise的状态是数组中所有Promise的状态的并集。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;class myPromise {\n    // ...其余方法同上\n    static all(promises) {\n        return new myPromise((resolve, reject) =&amp;gt; {\n            let result = []\n            promises.forEach(promise =&amp;gt; {\n                promise.then(\n                res =&amp;gt; {\n                    result.push(res)\n                    // 如果数组中的所有Promise都执行完毕，则执行resolve\n                    if (result.length === promises.length) {\n                        resolve(result)\n                    }\n                }),\n                // 如果数组中的某一个Promise执行失败，则执行reject\n                err =&amp;gt; {\n                    reject(err)\n                })\n            })\n        })\n    }\n\n    static allSettled(promises) {\n        return new myPromise((resolve, reject) =&amp;gt; {\n            let result = []\n            promises.forEach(promise =&amp;gt; {\n                // 对每个结果进行分类，分为fulfilled和rejected，加入到数组中\n                promise.then(\n                res =&amp;gt; {\n                    result.push({status: &#39;fulfilled&#39;, value: res})\n                    if (result.length === promises.length) {\n                        resolve(result)\n                    }\n                }),\n                err =&amp;gt; {\n                    result.push({status: &#39;rejected&#39;, reason: err})\n                    if (result.length === promises.length) {\n                        resolve(result)\n                    }\n                })\n            })\n        })\n    }\n}\n\nconst p1 = new myPromise((resolve) =&amp;gt; {\n  setTimeout(() =&amp;gt; { resolve(1111) }, 1000)\n})\nconst p2 = new myPromise((resolve, reject) =&amp;gt; {\n  setTimeout(() =&amp;gt; { reject(2222) }, 2000)\n})\nconst p3 = new myPromise((resolve) =&amp;gt; {\n  setTimeout(() =&amp;gt; { resolve(3333) }, 3000)\n})\n\nmyPromise.all([p1, p2, p3]).then(res =&amp;gt; {\n  console.log(&amp;quot;res:&amp;quot;, res) // res: [ 1111, 2222, 3333 ]\n})\n\nmyPromise.allSettled([p1, p2, p3]).then(res =&amp;gt; {\n  console.log(&amp;quot;res:&amp;quot;, res) // res: [ { status: &#39;fulfilled&#39;, value: 1111 }, { status: &#39;rejected&#39;, reason: 2222 }, { status: &#39;fulfilled&#39;, value: 3333 } ]\n})\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promiserace-promiseany-方法设计\&#34;&gt;Promise.race &amp;amp;&amp;amp; Promise.any 方法设计&lt;/h2&gt;\n&lt;p&gt;两个方法都是直接执行第一个可以执行Promise，区别在于：race执行到第一个就可以返回，any则需要等待一个resolve才可以返回，否则返回reject:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;class myPromise {\n    // ...同上\n    static race(promises) {\n        return new myPromise((resolve, reject) =&amp;gt; {\n            promises.forEach(promise =&amp;gt; {\n                // promise.then(res =&amp;gt; {\n                //   resolve(res)\n                // }, err =&amp;gt; {\n                //   reject(err)\n                // })\n                promise.then(resolve, reject)\n            })\n        })\n    }\n\n    static any(promises) {\n        // resolve必须等到有一个成功的结果\n        // reject所有的都失败才执行reject\n        const reasons = []\n        return new myPromise((resolve, reject) =&amp;gt; {\n            promises.forEach(promise =&amp;gt; {\n                promise.then(resolve, err =&amp;gt; {\n                    // 如果有一个Promise执行成功，则执行resolve\n                    reasons.push(err)\n                    if (reasons.length === promises.length) {\n                        reject(new AggregateError(reasons))\n                    }\n                })\n            })\n        })\n    }\n}\n\nconst p1 = new myPromise((resolve) =&amp;gt; {\n  setTimeout(() =&amp;gt; { resolve(1111) }, 1000)\n})\n\nconst p2 = new myPromise((resolve, reject) =&amp;gt; {\n  setTimeout(() =&amp;gt; { reject(2222) }, 2000)\n})\n\nconst p3 = new myPromise((resolve) =&amp;gt; {\n  setTimeout(() =&amp;gt; { resolve(3333) }, 3000)\n}).\n\nmyPromise.race([p1, p2, p3]).then(res =&amp;gt; {\n    console.log(res); // 111\n})\n\nmyPromise.any([p1, p2, p3]).then(res =&amp;gt; {\n    console.log(res); // 111\n})\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;IZaI2U_Lq&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;之前的文章里讲了Promise的好处以及具体应用，不了解Promise用法的读者可以移步到这里：&lt;a href=\&#34;https://ricky.shineteens.com/post/lgixxdcqc/\&#34;&gt;JavaScript｜Promise使用详解&lt;/a&gt;。这里我们主要来看看Promise是怎么实现的。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript｜手写Promise&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Promise&#34;,&#34;slug&#34;:&#34;NWGKu8Hd_&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/NWGKu8Hd_/&#34;},{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;2BbnUmwOd&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/2BbnUmwOd/&#34;},{&#34;name&#34;:&#34;手撕算法&#34;,&#34;slug&#34;:&#34;mXSK6D8su7&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/mXSK6D8su7/&#34;}],&#34;date&#34;:&#34;2022-08-23 09:43:30&#34;,&#34;dateFormat&#34;:&#34;2022-08-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/IZaI2U_Lq/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;14 min read&#34;,&#34;time&#34;:794000,&#34;words&#34;:2746,&#34;minutes&#34;:14},&#34;description&#34;:&#34;之前的文章里讲了Promise的好处以及具体应用，不了解Promise用法的读者可以移步到这里：JavaScript｜Promise使用详解。这里我们主要来看看Promise是怎么实现的。\n\nPromise结构设计\n如果要实现一个Promi...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#promise%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\&#34;&gt;Promise结构设计&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promisethen%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1\&#34;&gt;Promise.then方法设计&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#then%E6%96%B9%E6%B3%95%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\&#34;&gt;then方法基本结构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#then%E6%96%B9%E6%B3%95%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8\&#34;&gt;then方法多次调用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#then%E6%96%B9%E6%B3%95%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8\&#34;&gt;then方法的链式调用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promisecatch%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1\&#34;&gt;Promise.catch方法设计&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promisefinally%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1\&#34;&gt;Promise.finally方法设计&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promiseresolve-promisereject%E6%96%B9%E6%B3%95%E7%9B%B4%E6%8E%A5%E5%AE%9E%E7%8E%B0\&#34;&gt;Promise.resolve &amp;amp;&amp;amp; Promise.reject方法直接实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promiseall-promiseallsettled%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0\&#34;&gt;Promise.all &amp;amp;&amp;amp; Promise.allSettled方法实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promiserace-promiseany-%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1\&#34;&gt;Promise.race &amp;amp;&amp;amp; Promise.any 方法设计&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;promise-之前实现异步的弊端\&#34;&gt;Promise 之前实现异步的弊端&lt;/h2&gt;\n&lt;p&gt;首先看一个例子，再没有Promise之前，实现一个网络异步请求：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;function requestData(url, successCallback, failtureCallback) {\n    // 模拟网络请求\n    setTimeout(() =&amp;gt; {\n        // 获取请求结果\n        // url 传入的是 ricky 则请求成功，否则请求失败\n        if (url === &#39;ricky&#39;) {\n            let res = {\n                name: &#39;ricky&#39;,\n                age: 18\n            };\n            successCallback(res);\n        } else {\n            let error = &#39;请求失败&#39;;\n            failtureCallback(error);\n        }\n    }, 3000);\n}\n\nrequestData(&#39;ricky&#39;, (res) =&amp;gt; {\n    console.log(res);\n} , (error) =&amp;gt; {\n    console.log(error);\n} );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种实现方法有很多弊端：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;如果是我们自己封装的requestData,那么我们在封装的时候必须要自己设计好callback名称, 并且使用好&lt;/li&gt;\n&lt;li&gt;如果我们使用的是别人封装的requestData或者一些第三方库, 那么我们必须去看别人的源码或者文档, 才知道它这个函数需要怎么去获取到结果&lt;/li&gt;\n&lt;/ol&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;什么是-promise\&#34;&gt;什么是 Promise&lt;/h2&gt;\n&lt;p&gt;当我们需要给予调用者一个承诺：待会儿我会给你回调数据时，就可以创建一个Promise的对象；&lt;/p&gt;\n&lt;p&gt;在通过new创建Promise对象时，我们需要传入一个回调函数，我们称之为executor&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;这个回调函数会被立即执行，并且给传入另外两个回调函数resolve、reject；&lt;/li&gt;\n&lt;li&gt;当我们调用resolve回调函数时，会执行Promise对象的then方法传入的回调函数；&lt;/li&gt;\n&lt;li&gt;当我们调用reject回调函数时，会执行Promise对象的catch方法传入的回调函数；&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;通过Promise改进的异步请求方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;function requestData(url) {\n    // 模拟网络请求\n    return new Promise((resolve, reject) =&amp;gt; {\n        setTimeout(() =&amp;gt; {\n            // 获取请求结果\n            // url 传入的是 ricky 则请求成功，否则请求失败\n            if (url === &#39;ricky&#39;) {\n                let res = {\n                    name: &#39;ricky&#39;,\n                    age: 18\n                };\n                resolve(res);\n            } else {\n                let error = &#39;请求失败&#39;;\n                reject(error);\n            }\n        }, 3000);\n    });\n}\n\nrequestData(&#39;ricky&#39;).then((res) =&amp;gt; \n    console.log(res), (err) =&amp;gt; \n    console.log(err)\n);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promise-三种状态\&#34;&gt;Promise 三种状态&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;pending: 初始状态，表示Promise对象正在处理状态，还未完成&lt;/li&gt;\n&lt;li&gt;fulfilled: 表示Promise对象已经成功处理，当执行resolve方法时，Promise对象的状态就会变为fulfilled&lt;/li&gt;\n&lt;li&gt;rejected: 表示Promise对象已经处理失败，当执行reject方法时，Promise对象的状态就会变为rejected&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;const promise = new Promise((resolve, reject) =&amp;gt; {\n    // 调用resolve方法, then 传入回调执行\n    resolve(&#39;successCallback&#39;)\n    // 调用reject方法, catch 传入回调执行\n    reject(&#39;errorCallback&#39;)\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;resolve-传参区别\&#34;&gt;resolve 传参区别&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;如果resolve传入一个普通的值或者对象，那么这个值会作为then回调的参数；&lt;/li&gt;\n&lt;li&gt;如果resolve传入一个Promise对象，那么这个Promise对象的状态就会被设置为当前Promise对象的状态；&lt;/li&gt;\n&lt;li&gt;如果resolve传入一个有then方法的对象，那么这个对象的then方法就会被调用，并且传入的参数就是当前Promise对象的状态；&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;// 传入Promise对象\nconst newPromise = new Promise((resolve, reject) =&amp;gt; {\n  reject(&amp;quot;err message&amp;quot;)\n})\n\nnew Promise((resolve, reject) =&amp;gt; {\n  // pending -&amp;gt; fulfilled\n  resolve(newPromise)\n}).then(res =&amp;gt; {\n  console.log(&amp;quot;res:&amp;quot;, res)\n}, err =&amp;gt; {\n  console.log(&amp;quot;err:&amp;quot;, err) // err: err message\n})\n\n// 传入有then方法的对象\nnew Promise((resolve, reject) =&amp;gt; {\n  // pending -&amp;gt; fulfilled\n  const obj = {\n    then: function(resolve, reject) {\n      // resolve(&amp;quot;resolve message&amp;quot;)\n      reject(&amp;quot;reject message&amp;quot;)\n    }\n  }\n  resolve(obj)\n}).then(res =&amp;gt; {\n  console.log(&amp;quot;res:&amp;quot;, res)\n}, err =&amp;gt; {\n  console.log(&amp;quot;err:&amp;quot;, err) // err: reject message\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;then-方法\&#34;&gt;then 方法&lt;/h2&gt;\n&lt;p&gt;then是Promise对象上的方法，在Promise原型上的Promise.prototype.then&lt;/p&gt;\n&lt;h3 id=\&#34;两个参数\&#34;&gt;两个参数&lt;/h3&gt;\n&lt;p&gt;then方法接受两个参数，分别是resolve和reject，当Promise对象的状态变为fulfilled时，会执行resolve，当Promise对象的状态变为rejected时，会执行reject&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;promise.then(res =&amp;gt; {\n    console.log(res);\n}, err =&amp;gt; {\n    console.log(err);\n})\n\n// 等价于\npromise.then(res =&amp;gt; {\n    console.log(res);\n}).catch(err =&amp;gt; {\n    console.log(err);\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;多次调用\&#34;&gt;多次调用&lt;/h3&gt;\n&lt;p&gt;Promise对象的then方法可以被多次调用，每次调用我们都可以传入对应的fulfilled回调；当Promise的状态变成fulfilled的时候，这些回调函数都会被执行；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;const promise = new Promise((resolve, reject) =&amp;gt; {\n    setTimeout(() =&amp;gt; {\n        resolve(&#39;success&#39;)\n    }, 1000);\n})\n\npromise.then(res1 =&amp;gt; {\n    console.log(&#39;res1:&#39;, res1);\n})\n\npromise.then(res2 =&amp;gt; {\n    console.log(&#39;res2:&#39;, res2);\n})\n\npromise.then(res3 =&amp;gt; {\n    console.log(&#39;res3:&#39;, res3);\n})\n// 上述三个结果都在同一时间打印\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;then方法的返回值\&#34;&gt;then方法的返回值&lt;/h3&gt;\n&lt;p&gt;then方法的返回值是一个新的Promise对象，这个新的Promise对象的状态和原来的Promise对象保持一致。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;// resolve情况\npromise.then(res =&amp;gt; {\n    console.log(&#39;res:&#39;, res); // res: success\n    return &#39;res success&#39;\n}).then(res =&amp;gt; console.log(res), err =&amp;gt; console.log(err)) // res success\n// reject情况\npromise.then(res =&amp;gt; {\n    console.log(&#39;res:&#39;, res); // res: success\n    throw &#39;res err&#39;\n}).then(res =&amp;gt; console.log(res), err =&amp;gt; console.log(err)) // res err\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;catch-方法\&#34;&gt;catch 方法&lt;/h2&gt;\n&lt;p&gt;catch方法是then方法的另一个版本，用于指定rejected的回调函数，当Promise对象的状态变为rejected时，会执行rejected&lt;/p&gt;\n&lt;h3 id=\&#34;多次调用-2\&#34;&gt;多次调用&lt;/h3&gt;\n&lt;p&gt;Promise对象的catch也可以进行多次调用，每次调用都会执行对应的回调函数；当Promise的状态变成rejected的时候，这些回调函数都会被执行；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;// 同样会在promise对象的状态变为rejected的时候同时执行\npromise.catch(err =&amp;gt; console.log(&amp;quot;err1:&amp;quot; err))\npromise.catch(err =&amp;gt; console.log(&amp;quot;err2:&amp;quot; err))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;catch返回值\&#34;&gt;catch返回值&lt;/h3&gt;\n&lt;p&gt;catch方法的返回值也是一个新的Promise对象，这个新的Promise对象的状态和原来的Promise对象保持一致。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;promise.catch(err =&amp;gt; {\n    console.log(&#39;err:&#39;, err); // err: err message\n    return err\n}).then(res =&amp;gt; {\n    console.log(&#39;res:&#39;, res); // 执行此处\n}).catch(err =&amp;gt; {\n    console.log(err);\n})\n\npromise.catch(err =&amp;gt; {\n    console.log(&#39;err:&#39;, err); // err: err message\n    throw err\n}).then(res =&amp;gt; {\n    console.log(&#39;res:&#39;, res);\n}).catch(err =&amp;gt; {\n    console.log(err); // 执行此处\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;finally-方法\&#34;&gt;finally 方法&lt;/h2&gt;\n&lt;p&gt;finally方法是then方法的另一个版本，用于指定无论Promise对象最后状态如何，都会执行的回调函数。finally方法是不接收参数的，因为无论前面是fulfilled状态，还是reject状态，它都会执行。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;promise.then(res =&amp;gt; {\n    console.log(&#39;res:&#39;, res); // res: success\n}).catch(err =&amp;gt; {\n    console.log(&#39;err:&#39;, err);\n}).finally(() =&amp;gt; {\n    console.log(&#39;finally&#39;); // finally\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;resolve-reject-方法\&#34;&gt;resolve &amp;amp; reject 方法&lt;/h2&gt;\n&lt;p&gt;有时候我们已经有一个现成的内容了，希望将其转成Promise来使用，这个时候我们可以使用 Promise.resolve/Promise.reject 方法来完成。&lt;/p&gt;\n&lt;p&gt;Promise.resolve的用法相当于new Promise，并且执行resolve操作，可以传递除了普通值或对象、Promise和thenable对象作为参数。&lt;/p&gt;\n&lt;p&gt;Promise.reject的用法也相当于new Promise，并且执行reject操作，可以传递任何形态的参数，这些参数都会直接作为reject状态的参数传递到catch。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;Promise.resolve(&#39;success&#39;) \n\n// 相当于\n\nnew Promise((resolve, reject) =&amp;gt; {\n    resolve(&#39;success&#39;)\n})\n\nPromise.reject(&#39;err&#39;)\n\n// 相当于\n\nnew Promise((resolve, reject) =&amp;gt; {\n    reject(&#39;err&#39;)\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promiseall方法\&#34;&gt;Promise.all方法&lt;/h2&gt;\n&lt;p&gt;Promise.all方法用于将多个Promise对象，包装成一个新的Promise对象。&lt;/p&gt;\n&lt;p&gt;新的Promise状态由包裹的所有Promise共同决定：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;当所有的Promise状态变成fulfilled状态时，新的Promise状态为fulfilled，并且会将所有Promise的返回值组成一个数组；&lt;/li&gt;\n&lt;li&gt;当有一个Promise状态为reject时，新的Promise状态为reject，并且会将第一个reject的返回值作为参数；&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;const r1 = new Promise((resolve, reject) =&amp;gt; {\n    setTimeout(() =&amp;gt; {\n        resolve(&#39;r1 success&#39;)\n    }, 1000);\n})\n\nconst r2 = new Promise((resolve, reject) =&amp;gt; {\n    setTimeout(() =&amp;gt; {\n        resolve(&#39;r2 success&#39;)\n    }, 1500);\n})\n\nconst r3 = new Promise((resolve, reject) =&amp;gt; {\n    setTimeout(() =&amp;gt; {\n        resolve(&#39;r3 success&#39;)\n    }, 2000);\n})\n\nconst e1 = new Promise((resolve, reject) =&amp;gt; {\n    setTimeout(() =&amp;gt; {\n        reject(&#39;e1 error&#39;)\n    }, 1000);\n})\n\nconst e2 = new Promise((resolve, reject) =&amp;gt; {\n    setTimeout(() =&amp;gt; {\n        reject(&#39;e2 error&#39;)\n    }, 2000);\n})\n\nPromise.all([r1, r2, r3]).then(res =&amp;gt; {\n    console.log(res); // [ &#39;r1 success&#39;, &#39;r2 success&#39;, &#39;r3 success&#39; ]\n})\n\nPromise.all([r1, r2, r3, e1, e2]).then(res =&amp;gt; {\n    console.log(res);\n}).catch(err =&amp;gt; {\n    console.log(err); // e1 error\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promiseallsettled-方法\&#34;&gt;Promise.allSettled 方法&lt;/h2&gt;\n&lt;p&gt;all方法有一个缺点：如果一个Promise变成reject状态，那么其他的Promise也会变成reject状态，并且不会再执行then方法。无法获取已经resolved状态的Promise。ES11中新增了allSettled方法，用于解决这个问题。该方法会在所有的Promise都有结果（settled），无论是fulfilled，还是reject时，都有最终的状态，并且这个Promise的结果一定是fulfilled的。&lt;/p&gt;\n&lt;p&gt;返回的Promise的结果是一个数组，数组中的每一项都是一个Promise的结果，包含status状态以及对应的value值，数组的顺序与传入的Promise数组的顺序一致。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;Promise.allSettled([r1, r2, r3, e1, e2]).then(res =&amp;gt; {\n    console.log(res); // [ { status: &#39;fulfilled&#39;, value: &#39;r1 success&#39; }, { status: &#39;fulfilled&#39;, value: &#39;r2 success&#39; }, { status: &#39;fulfilled&#39;, value: &#39;r3 success&#39; }, { status: &#39;rejected&#39;, reason: &#39;e1 error&#39; }, { status: &#39;rejected&#39;, reason: &#39;e2 error&#39; } ]\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promiserace方法\&#34;&gt;Promise.race方法&lt;/h2&gt;\n&lt;p&gt;如果有一个Promise有了结果，我们就希望决定最终新Promise的状态，那么可以使用race方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;Promise.race([r1, r2, r3]).then(res =&amp;gt; {\n    console.log(res); // r1 success\n}) \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promiseany方法\&#34;&gt;Promise.any方法&lt;/h2&gt;\n&lt;p&gt;any方法是ES12中新增的方法，和race方法是类似的：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;any方法会等到一个fulfilled状态，才会决定新Promise的状态&lt;/li&gt;\n&lt;li&gt;如果所有的Promise都是reject的，那么也会等到所有的Promise都变成rejected状态&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;Promise.any([r1, r2, r3, e1, e2]).then(res =&amp;gt; {\n    console.log(res); // &#39;r1 success&#39;\n})\n\nPromise.any([e1, e2]).then(res =&amp;gt; {\n    console.log(res);\n}) \n// 报错：Error: All promises were rejected\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;LGIXxDcQC&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;promise-之前实现异步的弊端\&#34;&gt;Promise 之前实现异步的弊端&lt;/h2&gt;\n&lt;p&gt;首先看一个例子，再没有Promise之前，实现一个网络异步请求：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-JavaScript\&#34;&gt;function requestData(url, successCallback, failtureCallback) {\n    // 模拟网络请求\n    setTimeout(() =&amp;gt; {\n        // 获取请求结果\n        // url 传入的是 ricky 则请求成功，否则请求失败\n        if (url === &#39;ricky&#39;) {\n            let res = {\n                name: &#39;ricky&#39;,\n                age: 18\n            };\n            successCallback(res);\n        } else {\n            let error = &#39;请求失败&#39;;\n            failtureCallback(error);\n        }\n    }, 3000);\n}\n\nrequestData(&#39;ricky&#39;, (res) =&amp;gt; {\n    console.log(res);\n} , (error) =&amp;gt; {\n    console.log(error);\n} );\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这种实现方法有很多弊端：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;如果是我们自己封装的requestData,那么我们在封装的时候必须要自己设计好callback名称, 并且使用好&lt;/li&gt;\n&lt;li&gt;如果我们使用的是别人封装的requestData或者一些第三方库, 那么我们必须去看别人的源码或者文档, 才知道它这个函数需要怎么去获取到结果&lt;/li&gt;\n&lt;/ol&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript｜Promise使用详解&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Promise&#34;,&#34;slug&#34;:&#34;NWGKu8Hd_&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/NWGKu8Hd_/&#34;},{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;2BbnUmwOd&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/2BbnUmwOd/&#34;}],&#34;date&#34;:&#34;2022-08-22 09:51:38&#34;,&#34;dateFormat&#34;:&#34;2022-08-22&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/LGIXxDcQC/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:549000,&#34;words&#34;:2109,&#34;minutes&#34;:10},&#34;description&#34;:&#34;Promise 之前实现异步的弊端\n首先看一个例子，再没有Promise之前，实现一个网络异步请求：\nfunction requestData(url, successCallback, failtureCallback) {\n    //...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#promise-%E4%B9%8B%E5%89%8D%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%9A%84%E5%BC%8A%E7%AB%AF\&#34;&gt;Promise 之前实现异步的弊端&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%80%E4%B9%88%E6%98%AF-promise\&#34;&gt;什么是 Promise&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promise-%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81\&#34;&gt;Promise 三种状态&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#resolve-%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB\&#34;&gt;resolve 传参区别&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#then-%E6%96%B9%E6%B3%95\&#34;&gt;then 方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0\&#34;&gt;两个参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8\&#34;&gt;多次调用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#then%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC\&#34;&gt;then方法的返回值&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#catch-%E6%96%B9%E6%B3%95\&#34;&gt;catch 方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E6%AC%A1%E8%B0%83%E7%94%A8-2\&#34;&gt;多次调用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#catch%E8%BF%94%E5%9B%9E%E5%80%BC\&#34;&gt;catch返回值&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#finally-%E6%96%B9%E6%B3%95\&#34;&gt;finally 方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#resolve-reject-%E6%96%B9%E6%B3%95\&#34;&gt;resolve &amp;amp; reject 方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promiseall%E6%96%B9%E6%B3%95\&#34;&gt;Promise.all方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promiseallsettled-%E6%96%B9%E6%B3%95\&#34;&gt;Promise.allSettled 方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promiserace%E6%96%B9%E6%B3%95\&#34;&gt;Promise.race方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promiseany%E6%96%B9%E6%B3%95\&#34;&gt;Promise.any方法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;认识微服务\&#34;&gt;认识微服务&lt;/h2&gt;\n&lt;p&gt;微服务其实是一种架构风格，我们在开发一个应用的时候这个应用应该是由一组小型服务组成，每个小型服务都运行在自己的进程内；小服务之间通过 HTTP 的方式进行互联互通。&lt;/p&gt;\n&lt;h3 id=\&#34;扩展性\&#34;&gt;扩展性&lt;/h3&gt;\n&lt;p&gt;在单体应用中，如果要对模块进行扩展，那么需要对所有模块进行扩展。比如一个电商系统，我可能只需要扩展秒杀服务，但是在单体应用下进行扩展时其他功能也会扩展，会造成大量的资源浪费。而利用微服务可以只扩展响应服务即可。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;每一个服务都是一个 web 应用，我们可以对它进行独立的部署。就比如说这个服务它的访问压力比较大，我们就可以对他进行水平的扩展。就比如说关于他这一组的服务都访问压力比较大，我们可以给他们放在一组，把他归类在一组进行水平的扩展。这样带来的一个性能的优化是最佳的。并且他们的容错率是要比我们之前的单体应用的容错率是要更高的。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9adb47302d.jpg\&#34; alt=\&#34;62f9adb47302d\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;隔离性强\&#34;&gt;隔离性强&lt;/h3&gt;\n&lt;p&gt;在我们单体应用当中，比如说我一个不相关的一个功能，它出现了 OOM 内存溢出，那么会导致我整个应用都不可用了。&lt;/p&gt;\n&lt;p&gt;那么在我们的微服务架构当中，由于我们所有的这个服务都是单独的一个 web 应用都是单独一个进程。那么假如说我是一个这个电商系统，比方说是一个电商系统，比如说积分服务它挂掉了，那么它是不影响我继续去进行购买的，不影响我商品浏览，然后下单支付等等这些主要的流程操作的。我的整个应用依然能够正常的使用。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9ace963dd4.jpg\&#34; alt=\&#34;62f9ace963dd4\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;微服务带来的问题\&#34;&gt;微服务带来的问题&lt;/h2&gt;\n&lt;p&gt;那么我们一个微服务架构，我们可以看到经过拆分，经过更细粒度更彻底的一个拆分之后，我们的这个服务会变得非常非常的多，每一个节点都是一个服务，并且经过水平的扩展、负载均衡之后，它们之间的一个调用链路会变得更加的错综的复杂。&lt;/p&gt;\n&lt;p&gt;一个业务功能之中，一般都会涉及到好几个功能模块。那么经过我们的微服务一拆分之后，有可能就会变到变成几个微服务，甚至十几个微服务。那么一一负载均衡。那甚至涉及到几十个微服务之间的相互交友。那么这么多微服务之间的调用肯定会出现一系列的问题。那么我们怎么去解决这些问题呢？&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9b3253c072.jpg\&#34; alt=\&#34;62f9b3253c072\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;服务治理\&#34;&gt;服务治理&lt;/h3&gt;\n&lt;p&gt;首先是这么多服务，如何进行管理？比如说我的订单服务，要去调用我的库存服务，有可能还要调用商品服务，然后有可能还要去调用积分服务等等。&lt;/p&gt;\n&lt;p&gt;那么这个时候我要去调用这些服务，我是不是得知道他们的一个远程服务的地址，因为不同的服务都是部署在不同的服务器，他们可能都有不同的一个 IP。那么我要调用他们是不是得知道他们的一个 IP 然后进行远程的调用？他们这些 IP 是不是会频繁的变化。就比如说库存，那么今天他的这个访问压力比较大，那么我给他换一台这个性能不是这么好的服务器，我给他换一台 IP 就变了。然后我商品可能我今天压力比较大，我给他换一台性能比较好的服务器。或者说我今天我商品压力比较大，我给他水平扩展几个，那么 IP 又多了几个。那么这些远程服务地址的 IP 我都维护在订单这里的话是不是相当麻烦，因为他们会频繁地变化。所以说在我们的微服务架构当中，就引入了一个微服务治理组件，叫做注册中心。那么这个注册中心它就可以去管理我们所有的服务，我们会将这些服务都注册到这个注册中心当中。&lt;/p&gt;\n&lt;p&gt;去注册的时候，我们提供一个名字，比如说订单是 order ，比如说商品是 product ，那么订单我去调用商品的时候，我只要知道这个商品服务的名字（product），就可以直接去调用这个服务。这样就有效的去管理了我们这些服务。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9b54b3cf0c.jpg\&#34; alt=\&#34;62f9b54b3cf0c\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;通讯\&#34;&gt;通讯&lt;/h3&gt;\n&lt;p&gt;服务拆分后，服务之间的通信就不能像单体应用那样能够通过函数调用的方法进行调用了，因为函数调用是基于进程的，所以我们的服务之间是不能直接通信的。所以我们需要一个通信的框架，来实现我们的服务之间的通信。RPC和Rest是微服务最常见的两种协议，微服务内部通信一般采用RPC或者Rest进行通信，对于客户端来说主要采取Rest来进行交互。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;Rest&lt;/strong&gt;：严格的说接口很规范，操作对象即为资源，对资源的四种操作(post、get、put、delete)，并且参数都放在 URL 上。不严格的说 Http+json、Http+xml，常见的 http api 都可以称为 Rest 接口。在微服务中，可以选用 springBoot&lt;br&gt;\nrestTemplate 或者 feign 进行 Rest 接口的开发。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;RPC&lt;/strong&gt;：常说的远程方法调用，就是像调用本地方法一样调用远程方法，通信协议大多采用二进制方式。RPC通常基于TCP实现，常用框架例如dubbo，netty、mina、thrift。&lt;/p&gt;\n&lt;p&gt;两者之间的差异如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/15/62f9b9e00b4f2.jpg\&#34; alt=\&#34;62f9b9e00b4f2\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;微服务网关\&#34;&gt;微服务网关&lt;/h3&gt;\n&lt;p&gt;不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，如果让客户端直接与各个微服务通信，会有以下的问题：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;客户端会多次请求不同的微服务，增加了客户端的复杂性&lt;/li&gt;\n&lt;li&gt;存在跨域请求，在一定场景下处理相对复杂&lt;/li&gt;\n&lt;li&gt;认证复杂，每个服务都需要独立认证&lt;/li&gt;\n&lt;li&gt;难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施&lt;/li&gt;\n&lt;li&gt;某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;所以，我们需要通过配置微服务网关来实现客户端的访问。微服务网关是一个网关，它可以将一个或多个微服务集成到一个应用中，并且可以将这些微服务之间的调用进行转发，从而实现微服务之间的调用。&lt;/p&gt;\n&lt;p&gt;也就是在我们调用微服务的时候，它会为我们路由到不同的一个组件到路由到不同的一个服务当中去，从而为我们去把守我们整个微服务的一个大门。微服务也是中心化的，但是它不是强行的要求你去使用。&lt;/p&gt;\n&lt;p&gt;就比如说你也可以点对点的直接去访问我某一个服务，这是没有问题的。并且假如说我网关突然挂掉了，我也可以采用降级的方式降级去访问我这个服务，也就是说我不去访问网关了，我去访问我具体的那个服务。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fc91c397a33.jpg\&#34; alt=\&#34;62fc91c397a33\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;容错策略\&#34;&gt;容错策略&lt;/h3&gt;\n&lt;p&gt;在微服务中，每一个服务或者部署微服务的集群并非完全可靠的，如果一个服务挂掉了，那么可能会影响整个调用链路的正常运行，这时候我们需要实现容错策略，来解决这个问题：&lt;/p&gt;\n&lt;p&gt;容错的设计是为了解决这些问题：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;一个依赖服务出现故障不会严重破坏用户体验&lt;/li&gt;\n&lt;li&gt;一个依赖服务出现故障不会影响到其他服务&lt;/li&gt;\n&lt;li&gt;一个依赖服务出现故障不会影响到系统的可用性&lt;/li&gt;\n&lt;li&gt;系统能过具备自动处理故障的能力&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;常用的微服务容错策略包括如下：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;隔离：线程池隔离和信号隔离&lt;/li&gt;\n&lt;li&gt;超时：超过最大响应时间则释放进程&lt;/li&gt;\n&lt;li&gt;限流：限制服务的调用频率&lt;/li&gt;\n&lt;li&gt;熔断：熔断服务，当服务出现故障时，将服务降级到熔断状态，熔断状态下不再调用服务，直到服务恢复正常为止&lt;/li&gt;\n&lt;li&gt;降级：当服务出现故障时，提供其他服务的替代服务&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fc97d1927be.jpg\&#34; alt=\&#34;62fc97d1927be\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;链路追踪\&#34;&gt;链路追踪&lt;/h3&gt;\n&lt;p&gt;在微服务中，一个外部请求往往涉及到多个服务之间的调用，这些调用可能会出现跨越多个模块、多个中间件、多个服务器……如果一个调用出现问题，我们需要对各个服务进行排查，这需要花费大量的时间精力去排查，所以我们需要一个方法来追踪调用的链路来方便我们对请求调用进行追溯。&lt;/p&gt;\n&lt;p&gt;衡量一个接口，我们一般会看三个指标：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;接口的 RT（Route-Target）是什么？&lt;/li&gt;\n&lt;li&gt;接口是否有异常响应?&lt;/li&gt;\n&lt;li&gt;接口请求慢在哪里?&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;一般在系统发生问题时，比如系统异常或者系统性能出现问题时，通常都是从系统记录的日志文件中找出蛛丝马脚，而对于微服务架构下的分布式部署，日志文件的分散，想从日志中查找问题工作量很大。对于用户某一次请求调用后端哪些服务，每个服务执行情况，想从日志中获得更是不可能的事。&lt;/p&gt;\n&lt;p&gt;对于传统的监控告警平台也紧针对平台资源的监控包括cpu、内存、网络带宽情况等，对业务微服务应用的指标（平均响应时间、慢端点情况等）的监控显得无从下手。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fc9f650411b.jpg\&#34; alt=\&#34;62fc9f650411b\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/17/62fc9f264e765.jpg\&#34; alt=\&#34;62fc9f264e765\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;相关资料推荐\&#34;&gt;相关资料推荐&lt;/h2&gt;\n&lt;p&gt;这个文档对理解微服务和分布式架构有很大的帮助：&lt;br&gt;\n&lt;a href=\&#34;http://icyfenix.cn/\&#34;&gt;凤凰架构&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;阿里云提供了脚手架和实验室还有教程，可以边动手边学习：&lt;br&gt;\n&lt;a href=\&#34;https://start.aliyun.com/\&#34;&gt;知行动手实验室&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;369HPigUO&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;认识微服务\&#34;&gt;认识微服务&lt;/h2&gt;\n&lt;p&gt;微服务其实是一种架构风格，我们在开发一个应用的时候这个应用应该是由一组小型服务组成，每个小型服务都运行在自己的进程内；小服务之间通过 HTTP 的方式进行互联互通。&lt;/p&gt;\n&lt;h3 id=\&#34;扩展性\&#34;&gt;扩展性&lt;/h3&gt;\n&lt;p&gt;在单体应用中，如果要对模块进行扩展，那么需要对所有模块进行扩展。比如一个电商系统，我可能只需要扩展秒杀服务，但是在单体应用下进行扩展时其他功能也会扩展，会造成大量的资源浪费。而利用微服务可以只扩展响应服务即可。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;微服务｜概念认识与相关问题&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;微服务&#34;,&#34;slug&#34;:&#34;tzlLItuaD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/tzlLItuaD/&#34;}],&#34;date&#34;:&#34;2022-08-17 16:25:19&#34;,&#34;dateFormat&#34;:&#34;2022-08-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/369HPigUO/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:569000,&#34;words&#34;:2808,&#34;minutes&#34;:10},&#34;description&#34;:&#34;认识微服务\n微服务其实是一种架构风格，我们在开发一个应用的时候这个应用应该是由一组小型服务组成，每个小型服务都运行在自己的进程内；小服务之间通过 HTTP 的方式进行互联互通。\n扩展性\n在单体应用中，如果要对模块进行扩展，那么需要对所有模块...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1\&#34;&gt;认识微服务&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%A9%E5%B1%95%E6%80%A7\&#34;&gt;扩展性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9A%94%E7%A6%BB%E6%80%A7%E5%BC%BA\&#34;&gt;隔离性强&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;微服务带来的问题&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86\&#34;&gt;服务治理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E8%AE%AF\&#34;&gt;通讯&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3\&#34;&gt;微服务网关&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%B9%E9%94%99%E7%AD%96%E7%95%A5\&#34;&gt;容错策略&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA\&#34;&gt;链路追踪&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99%E6%8E%A8%E8%8D%90\&#34;&gt;相关资料推荐&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;很多前端 JavaScript 框架，包含但不限于（Angular，React，Vue）都拥有自己的响应式方法，而这些方法其实都是基于监听对象来实现的，这里我们来看看监听对象实现响应式的原理。&lt;/p&gt;\n&lt;h2 id=\&#34;objectdefineproperty-监听对象\&#34;&gt;Object.defineProperty 监听对象&lt;/h2&gt;\n&lt;p&gt;如果需要监听对象的属性变化，可以使用&lt;strong&gt;Object.defineProperty&lt;/strong&gt;的存储属性描述符的方法来监听。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const obj = {\n  a: 1,\n  b: 2,\n  c: 3\n}\n\n// 监听一个属性的变化\nObject.defineProperty(obj, &#39;a&#39;, {\n  set(val) {\n    console.log(&#39;a set&#39;, val)\n  },\n  get() {\n    console.log(&#39;a get&#39;)\n    return this.a\n  }\n})\n&amp;lt;!-- more --&amp;gt;\n// 监听所有属性的变化\nObject.keys(obj).forEach(key =&amp;gt; {\n    let val = obj[key]\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(key, &#39;get&#39;)\n            return val\n        },\n        set(newVal) {\n            console.log(key, &#39;set&#39;, newVal)\n            val = newVal\n        },\n    })\n});\n\nconsole.log(obj.a) // a get 1\nobj.a = 2 // a set 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但通过Object.defineProperty会带来很多问题：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;如果需要监听对象的增删操作，这个方法就会失效&lt;/li&gt;\n&lt;li&gt;定义属性时，所有的普通属性都会强行变成属性描述符&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;存储数据描述符设计的初衷并不是为了去监听一个完整的对象。&lt;/p&gt;\n&lt;h2 id=\&#34;proxy的基本使用\&#34;&gt;Proxy的基本使用&lt;/h2&gt;\n&lt;p&gt;在ES6中，新增了&lt;strong&gt;Proxy类&lt;/strong&gt;，用于为对象创建一个代理：&lt;br&gt;\n如果我们希望监听一个对象的相关操作，可以先创建一个代理对象(Proxy)，然后将相关操作都在代理对象上完成。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const obj = {\n  a: 1,\n  b: 2,\n  c: 3\n}\n\nconst proxy = new Proxy(obj, {\n    get(target, key) {\n        console.log(&#39;get&#39;, key)\n        return target[key]\n    },\n    set(target, key, val) {\n    console.log(&#39;set&#39;, key, val)\n    target[key] = val\n    },\n    has(target, key) {\n        console.log(&#39;has&#39;, key)\n        return key in target\n    },\n    deleteProperty(target, key) {\n        console.log(&#39;delete&#39;, key)\n        delete target[key]\n    }\n})\n\nconsole.log(proxy.a); // get a 1\nproxy.a = 2; // set a 2\nconsole.log(&#39;b&#39; in proxy); // has b true\ndelete proxy.c // delete c\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Proxy除了可以代理对象外，还能代理函数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;function foo() {\n  \n}\n\nconst proxy = new Proxy(foo, {\n    apply(target, thisArg, argArray) {\n        console.log(&#39;apply&#39;)\n        return target.apply(thisArg, argArray)\n    },\n    construct(target, argArray) {\n        console.log(&#39;construct&#39;)\n        return new target(...argArray)\n    },\n})\n\nproxy.apply({}, [1, 2]) // apply\nnew proxy(&#39;1&#39;,&#39;2&#39;) // construct\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Proxy有很多捕获器方法，具体可以查阅MDN文档&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy\&#34;&gt;proxy&lt;/a&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;reflect基本使用\&#34;&gt;Reflect基本使用&lt;/h2&gt;\n&lt;p&gt;Reflect也是ES6新增的一个API，它是一个对象，它主要提供了很多操作JavaScript对象的方法，有点像Object中操作对象的方法：比如Reflect.getPrototypeOf(target)类似于 Object.getPrototypeOf()； Reflect.defineProperty(target, propertyKey, attributes)类似于Object.defineProperty()……&lt;/p&gt;\n&lt;p&gt;为什么要有Reflect呢？早期ECMA规范中没有考虑到这种对&lt;strong&gt;对象本身&lt;/strong&gt;的操作如何设计会更加规范，所以将这些API放到了Object上面。但是&lt;strong&gt;Object作为一个构造函数，这些操作实际上放到它身上并不合适&lt;/strong&gt;。另外还包含一些类似于 in、delete操作符，让JS看起来是会有一些奇怪的。所以在ES6中新增了Reflect，让我们这些操作都集中到了Reflect对象上。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/Comparing_Reflect_and_Object_methods\&#34;&gt;比较Reflect和Object&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect\&#34;&gt;Reflect API&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 将之前代理转换成Reflect使用\nconst obj = {\n  a: 1,\n  b: 2,\n  c: 3\n}\n\nconst proxy = new Proxy(obj, {\n    get(target, key, receiver) {\n        console.log(&#39;get&#39;, key)\n        return Reflect.get(target, key, receiver)\n    },\n    set(target, key, val, receiver) {\n        console.log(&#39;set&#39;, key, val)\n        return Reflect.set(target, key, val, receiver)\n    },\n    has(target, key) {\n        console.log(&#39;has&#39;, key)\n        return Reflect.has(target, key)\n    },\n    deleteProperty(target, key) {\n        console.log(&#39;delete&#39;, key)\n        return Reflect.deleteProperty(target, key)\n    }\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;receiver的作用\&#34;&gt;Receiver的作用&lt;/h3&gt;\n&lt;p&gt;receiver的参数，它的作用是什么呢？如果我们的源对象（obj）有setter、getter的访问器属性，那么可以通过receiver来改变里面的this。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;function Student(name, age) {\n    this.name = name\n    this.age = age\n}\n\nfunction Teacher() {}\n\nconst teacher = Reflect.construct(Student, [&#39;Tom&#39;, 18], Teacher)\nconsole.log(teacher); // Teacher { name: &#39;Tom&#39;, age: 18 }\nconsole.log(teacher instanceof Teacher) // true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;响应式原理\&#34;&gt;响应式原理&lt;/h2&gt;\n&lt;h3 id=\&#34;响应式的定义\&#34;&gt;响应式的定义&lt;/h3&gt;\n&lt;p&gt;响应式是指，当一个对象的属性发生变化时，会自动触发对应的方法。&lt;/p&gt;\n&lt;p&gt;变量响应式&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;let a = 10\n// 需要执行的代码\nconsole.log(a)\nconsole.log(a * 2)\n// 当a发生变化时上面代码需要再次执行\na = 20\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;对象响应式&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;let obj = {\n    a: 1,\n    b: 2,\n    c: 3\n}\n\nconsole.log(obj.a); // obj.a 改变时需要再次执行\nconsole.log(obj.b); // obj.b 改变时需要再次执行\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;响应式函数的封装\&#34;&gt;响应式函数的封装&lt;/h3&gt;\n&lt;p&gt;通过创建一个数组收集变量触发需要执行的方法，然后在每次变量发生变化时，遍历数组，调用所有变量的响应式方法。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;let fns = []\nfunction watchFn(fn) {\n    fns.push(fn)\n}\n\nconst obj = {\n    a: 1,\n    b: 2,\n    c: 3\n}\n\nwatchFn(function() {\n    console.log(obj.a)\n})\n\nwatchFn(function() {\n    console.log(obj.b)\n}\n// 变量改变时触发该函数\nfns.forEach(fn =&amp;gt; fn())\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;依赖收集封装\&#34;&gt;依赖收集封装&lt;/h3&gt;\n&lt;p&gt;上述的方法在对多个对象做监听的时候，每创建一个对象都需要创建一个数组和方法，这样会比较麻烦。可以通过将该方法封装成一个类去实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;class Dep {\n    constructor() {\n        this.subs = []\n    }\n    addSub(sub) {\n        this.subs.push(sub)\n    }\n    notify() {\n        this.subs.forEach(sub =&amp;gt; sub.update())\n    }\n}\n\nconst obj = {\n    a: 1,\n    b: 2,\n    c: 3\n}\n\nconst dep = new Dep()\n\ndep.addSub(function() {\n    console.log(obj.a)\n})\n\ndep.addSub(function() {\n    console.log(obj.b)\n})\n\n// 变量改变时触发该函数\ndep.notify()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;自动监听对象的变化\&#34;&gt;自动监听对象的变化&lt;/h3&gt;\n&lt;p&gt;收集好依赖函数后，对象变化时如何触发相关依赖？我们可以通过proxy来实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 沿用上个例子的代码\nconst proxy = new Proxy(obj, {\n    get(target, key, receiver) {\n        return Reflect.get(target, key, receiver)\n    },\n    set(target, key, val, receiver) {\n        Reflect.set(target, key, val, receiver)\n        dep.notify()\n    }\n})\n\nproxy.a = 10 // 触发dep.notify() -&amp;gt; 10 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;依赖的管理\&#34;&gt;依赖的管理&lt;/h3&gt;\n&lt;p&gt;我们目前是创建了一个Depend对象，用来管理对于obj变化需要监听的响应函数：但是实际开发中我们会有不同的对象，另外会有不同的属性需要管理；我们如何可以使用一种数据结构来管理不同对象的不同依赖关系呢？&lt;/p&gt;\n&lt;p&gt;在前面关于ES6的文章中我提到过WeakMap，并且在学习WeakMap的时候我讲到了后面通过WeakMap如何管理这种响应式的数据依赖：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 依赖封装\nclass Depend {\n  constructor() {\n      this.reactiveFns = []\n  }\n  addDepend(reactiveFn) {\n      this.reactiveFns.push(reactiveFn)\n  }\n  notify() {\n      this.reactiveFns.forEach(reactiveFn =&amp;gt; reactiveFn())\n  }\n}\n\n// 响应式函数封装\nlet activeReactFn = null\nfunction watchFn(reactiveFn) {\n  activeReactFn = reactiveFn\n  reactiveFn()\n  activeReactFn = null\n}\n\n// 封装一个获取depend函数\nconst targetMap = new WeakMap()\nfunction getDepend(target, key) {\n  // 根据target获取map\n  let map = targetMap.get(target)\n  if (!map) {\n    map = new Map()\n    targetMap.set(target, map)\n  }\n  // 根据target获取map中的depend对象\n  let depend = map.get(key) \n  if (!depend) {\n      depend = new Depend()\n      map.set(key, depend)\n  }\n  return depend\n}\n\n// 对象案例\nconst obj = {\n  name: &#39;张三&#39;,\n  age: 18\n}\n\n// 监听代理\nconst objProxy = new Proxy(obj, {\n  get: function (target, key, receiver) {\n      // 获取depend对象\n      const depend = getDepend(target, key)\n      // 添加响应函数\n      depend.addDepend(activeReactFn)\n      // 返回值\n      return Reflect.get(target, key, receiver)\n  },\n  set: function (target, key, val, receiver) {\n      Reflect.set(target, key, val, receiver)\n      // 获取depend对象\n      const depend = getDepend(target, key)\n      // 响应函数\n      depend.notify()\n  }\n})\n\nwatchFn(function() {\n  console.log(&#39;React Name&#39;)\n  console.log(objProxy.name)\n})\n\nwatchFn(function() {\n  console.log(&#39;React Age&#39;)\n  console.log(objProxy.age)\n})\n\nobjProxy.name = &#39;李四&#39; // 只会触发 React Name 李四，不会触发 React Age 18\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;依赖管理重构\&#34;&gt;依赖管理重构&lt;/h3&gt;\n&lt;p&gt;上述的方法可以针对对象的某个变量完成响应式，但是如果响应式函数中变量被调用两次，那么这个函数会被收集两次，可以通过Set来解决这个问题，还可以将get的收集依赖方法放在Dep内部，避免混淆：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// 对上述两个方法进行改进\n// 依赖封装\nclass Depend {\n  constructor() {\n        this.reactiveFns = new Set()\n  }\n  addDepend() {\n        if (activeReactiveFn)\n        this.reactiveFns.add(activeReactiveFn)\n  }\n  notify() {\n        this.reactiveFns.forEach(reactiveFn =&amp;gt; reactiveFn())\n  }\n}\n\n// 监听代理\nconst objProxy = new Proxy(obj, {\n  get: function (target, key, receiver) {\n      // 获取depend对象\n      const depend = getDepend(target, key)\n      // 添加响应函数\n      depend.addDepend()\n      // 返回值\n      return Reflect.get(target, key, receiver)\n  },\n  set: function (target, key, val, receiver) {\n      Reflect.set(target, key, val, receiver)\n      // 获取depend对象\n      const depend = getDepend(target, key)\n      // 响应函数\n      depend.notify()\n  }\n})\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;实现vue3vue2响应式\&#34;&gt;实现Vue3/Vue2响应式&lt;/h3&gt;\n&lt;p&gt;通过上面的原理，再利用闭包的特性，可以实现Vue的响应式方法：&lt;/p&gt;\n&lt;p&gt;Vue3是通过Proxy实现响应式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// vue3 reactive\nfunction reactive(obj) {\n    return new Proxy(obj, {\n        get: function (target, key, receiver) {\n            // 获取depend对象\n            const depend = getDepend(target, key)\n            // 添加响应函数\n            depend.addDepend()\n            // 返回值\n            return Reflect.get(target, key, receiver)\n        },\n        set: function (target, key, val, receiver) {\n            Reflect.set(target, key, val, receiver)\n            // 获取depend对象\n            const depend = getDepend(target, key)\n            // 响应函数\n            depend.notify()\n        }\n    })\n}\n\nconst info = reactive({\n    name: &#39;张三&#39;,\n    age: 18\n})\n\nwatchFn(function() {\n    console.log(&#39;React Name&#39;)\n    console.log(info.name)\n})\n\ninfo.name = &#39;李四&#39; // React Name 李四\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Vue2是通过Object.defineProperty实现响应式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;// vue2 reactive\nfunction reactive(obj) {\n    Object.keys(obj).forEach(key =&amp;gt; {\n        let value = obj[key]\n        Object.defineProperty(obj, key, {\n        get: function (target, key, receiver) {\n            // 获取depend对象\n            const depend = getDepend(target, key)\n            // 添加响应函数\n            depend.addDepend()\n            // 返回值\n            return Reflect.get(target, key, receiver)\n            },\n        set: function (target, key, val, receiver) {\n            Reflect.set(target, key, val, receiver)\n            // 获取depend对象\n            const depend = getDepend(target, key)\n            // 响应函数\n            depend.notify()\n            }\n        })\n    })\n    return obj\n}\n\nconst info = reactive({\n    name: &#39;张三&#39;,\n    age: 18\n})\n\nwatchFn(function() {\n    console.log(&#39;React Name&#39;)\n    console.log(info.name)\n})\n\ninfo.name = &#39;李四&#39; // React Name 李四\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;ylCQIx8xP&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;很多前端 JavaScript 框架，包含但不限于（Angular，React，Vue）都拥有自己的响应式方法，而这些方法其实都是基于监听对象来实现的，这里我们来看看监听对象实现响应式的原理。&lt;/p&gt;\n&lt;h2 id=\&#34;objectdefineproperty-监听对象\&#34;&gt;Object.defineProperty 监听对象&lt;/h2&gt;\n&lt;p&gt;如果需要监听对象的属性变化，可以使用&lt;strong&gt;Object.defineProperty&lt;/strong&gt;的存储属性描述符的方法来监听。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const obj = {\n  a: 1,\n  b: 2,\n  c: 3\n}\n\n// 监听一个属性的变化\nObject.defineProperty(obj, &#39;a&#39;, {\n  set(val) {\n    console.log(&#39;a set&#39;, val)\n  },\n  get() {\n    console.log(&#39;a get&#39;)\n    return this.a\n  }\n})&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript｜监听对象与响应式原理&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;响应式&#34;,&#34;slug&#34;:&#34;LJ6JSMcdz&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/LJ6JSMcdz/&#34;},{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;2BbnUmwOd&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/2BbnUmwOd/&#34;}],&#34;date&#34;:&#34;2022-08-17 10:27:49&#34;,&#34;dateFormat&#34;:&#34;2022-08-17&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/ylCQIx8xP/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:true,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:572000,&#34;words&#34;:2103,&#34;minutes&#34;:10},&#34;description&#34;:&#34;很多前端 JavaScript 框架，包含但不限于（Angular，React，Vue）都拥有自己的响应式方法，而这些方法其实都是基于监听对象来实现的，这里我们来看看监听对象实现响应式的原理。\nObject.defineProperty 监...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#objectdefineproperty-%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1\&#34;&gt;Object.defineProperty 监听对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#proxy%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\&#34;&gt;Proxy的基本使用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#reflect%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\&#34;&gt;Reflect基本使用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#receiver%E7%9A%84%E4%BD%9C%E7%94%A8\&#34;&gt;Receiver的作用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86\&#34;&gt;响应式原理&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89\&#34;&gt;响应式的定义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85\&#34;&gt;响应式函数的封装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E5%B0%81%E8%A3%85\&#34;&gt;依赖收集封装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%87%AA%E5%8A%A8%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96\&#34;&gt;自动监听对象的变化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BE%9D%E8%B5%96%E7%9A%84%E7%AE%A1%E7%90%86\&#34;&gt;依赖的管理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E9%87%8D%E6%9E%84\&#34;&gt;依赖管理重构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0vue3vue2%E5%93%8D%E5%BA%94%E5%BC%8F\&#34;&gt;实现Vue3/Vue2响应式&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;题目介绍\&#34;&gt;题目介绍&lt;/h2&gt;\n&lt;p&gt;给你一个字符串 s，找到 s 中最长的回文子串。&lt;/p&gt;\n&lt;p&gt;示例 1：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;babad&amp;quot;\n输出：&amp;quot;bab&amp;quot;\n解释：&amp;quot;aba&amp;quot; 同样是符合题意的答案。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;示例 2：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;cbbd&amp;quot;\n输出：&amp;quot;bb&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;提示：&lt;/p&gt;\n&lt;p&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;br&gt;\ns 仅由数字和英文字母组成&lt;/p&gt;\n&lt;h3 id=\&#34;tags\&#34;&gt;Tags&lt;/h3&gt;\n&lt;p&gt;string | dynamic-programming&lt;/p&gt;\n&lt;h3 id=\&#34;companies\&#34;&gt;Companies&lt;/h3&gt;\n&lt;p&gt;amazon | bloomberg | microsoft&lt;/p&gt;\n&lt;h2 id=\&#34;题解\&#34;&gt;题解&lt;/h2&gt;\n&lt;p&gt;这道题是一道经典的动态规划题，需要用到动态规划的思想。&lt;/p&gt;\n&lt;p&gt;首先是判断回文串，通过比较中心的两个字符是否相等来判断。可以在利用双指针来实现，先从两端开始遍历，如果两个字符相等，则继续向中心移动，不相等则返回false，遍历结束返回true。因为第二个指针相对于第一个指针是镜像的，所以第二个指针可以可以直接用&lt;code&gt;字符串长度 - 第一个指针位置 - 1&lt;/code&gt;实现。&lt;/p&gt;\n&lt;p&gt;其次是对整体的字符串进行遍历，找出最长的字符串。从第二个开始遍历，当然要进行一个边界条件判断，只有一个字符的时候，直接返回即可。这里也是利用双指针进行遍历，第一个指针位置从头遍历到尾，下一个指针从头遍历到第一个指针的位置之前的一位，获取一个临时字符串进行判断，如果临时字符串是回文串，则更新最长回文串。这里可以这样优化，将第二个指针放在最大最大回文串长度之前，这样可以减少遍历的次数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;/*\n * @lc app=leetcode.cn id=5 lang=javascript\n *\n * [5] 最长回文子串\n */\n\n// @lc code=start\n/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function(s) {\n    // 回文串判断\n    function judge(tmp) {\n        const len = tmp.length;\n        const mid = Math.floor(len / 2);\n        // 奇偶字符串都遍历一半就好了，中间的字符可以无视\n        for (let i = 0; i &amp;lt; mid; i++) {\n            if (tmp[i] != tmp[len - 1 - i]) return false;\n        }\n        return true;\n    }\n\n    let len = s.length;\n    // 边界条件，只有一个字符的时候，直接返回即可\n    if (len &amp;lt;= 1) return s;\n    // 存储最长回文串，第一项为长度第二项为字符串\n    let maxRes = [1, s[0]];\n    // 从第二个开始遍历\n    for (let i = 1; i &amp;lt; len;i++) {\n        for (let j = 0; j &amp;lt; i; j++) {\n            let dif = i - j + 1;\n            // 如果截取的字符串长度小于最大长度，则跳过\n            if (dif &amp;lt;= maxRes[0]) break;\n            let tmpArray = s.slice(j, i + 1);\n            // 判断回文串，如果是回文串，则更新最长回文串\n            if(judge(tmpArray) &amp;amp;&amp;amp; dif &amp;gt; maxRes[0]) {\n                maxRes[0] = dif;\n                maxRes[1] = tmpArray;\n            }\n        }\n    }\n    return maxRes[1];\n};\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;vvOUWDU7T&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;题目介绍\&#34;&gt;题目介绍&lt;/h2&gt;\n&lt;p&gt;给你一个字符串 s，找到 s 中最长的回文子串。&lt;/p&gt;\n&lt;p&gt;示例 1：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;babad&amp;quot;\n输出：&amp;quot;bab&amp;quot;\n解释：&amp;quot;aba&amp;quot; 同样是符合题意的答案。\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;示例 2：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;输入：s = &amp;quot;cbbd&amp;quot;\n输出：&amp;quot;bb&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;LeetCode 05.最长回文子串 动态规划&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;算法&#34;,&#34;slug&#34;:&#34;PiU9ZQ2k4&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/PiU9ZQ2k4/&#34;}],&#34;date&#34;:&#34;2022-08-16 17:15:38&#34;,&#34;dateFormat&#34;:&#34;2022-08-16&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/vvOUWDU7T/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:159000,&#34;words&#34;:659,&#34;minutes&#34;:3},&#34;description&#34;:&#34;题目介绍\n给你一个字符串 s，找到 s 中最长的回文子串。\n示例 1：\n输入：s = &amp;quot;babad&amp;quot;\n输出：&amp;quot;bab&amp;quot;\n解释：&amp;quot;aba&amp;quot; 同样是符合题意的答案。\n\n示例 2：\n输入...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E7%9B%AE%E4%BB%8B%E7%BB%8D\&#34;&gt;题目介绍&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#tags\&#34;&gt;Tags&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#companies\&#34;&gt;Companies&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%98%E8%A7%A3\&#34;&gt;题解&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;ES7~ES12是 ES6 的补充，里面有很多比较灵活的用法可以在日常中使用，如果对 ES6 不太熟悉的可以看看这里：&lt;a href=\&#34;https://ricky.shineteens.com/post/j9qm98nhv/\&#34;&gt;JavaScript｜ES6日常用法详解&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;es7-array-includes\&#34;&gt;ES7 - Array Includes&lt;/h2&gt;\n&lt;p&gt;在ES7之前，如果我们想判断一个数组中是否包含某个元素，需要通过 indexOf 获取结果，并且判断是否为 -1。 在ES7中，我们可以通过includes来判断一个数组中是否包含一个指定的元素，根据情况，如果包含则返回 true， 否则返回false。&lt;br&gt;\n&lt;code&gt;arr.includes(valueToFind[, fromIndex])&lt;/code&gt;&lt;br&gt;\nfromIndex(可选): 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const arr = [1, 2, 3, 4, 5];\nconsole.log(arr.includes(3)); // true\nconsole.log(arr.includes(6)); // false\nconsole.log(arr.includes(3, 3)); // false\nconsole.log(arr.includes(3, -1)); // true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;es7-指数乘方-exponentiation运算符\&#34;&gt;ES7 –指数(乘方) exponentiation运算符&lt;/h2&gt;\n&lt;p&gt;在ES7之前，计算数字的乘方需要通过 Math.pow 方法来完成。 在ES7中，增加了 ** 运算符，可以对数字来计算乘方。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;console.log(2 ** 3); // 8\nconsole.log(2 ** -3); // 0.125\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es8-object-values\&#34;&gt;ES8 Object values&lt;/h2&gt;\n&lt;p&gt;之前我们可以通过 Object.keys 获取一个对象所有的key，在ES8中提供了 Object.values 来获取所有的value值：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const obj = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\nconsole.log(Object.values(obj)); // [1, 2, 3]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es8-object-entries\&#34;&gt;ES8 Object Entries&lt;/h2&gt;\n&lt;p&gt;通过Object.entries可以获取到一个数组，数组中会存放可枚举属性的键值对数组。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const obj = {\n  a: 1,\n  b: 2,\n  c: 3\n};\n\nconsole.log(Object.entries(obj)); // [[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es8-string-padstart和padend\&#34;&gt;ES8 String PadStart和PadEnd&lt;/h2&gt;\n&lt;p&gt;某些字符串我们需要对其进行前后的填充，来实现某种格式化效果，ES8中增加了 padStart 和 padEnd 方法，分别是对字符串的首尾进行填充的。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const str = &#39;hello&#39;;\nconsole.log(str.padStart(10, &#39;hi&#39;)); // &#39;hihello&#39;\nconsole.log(str.padEnd(10, &#39;hi&#39;)); // &#39;hellohi&#39;\n\n// 小场景：对银行卡实现位数隐藏\nconst card = &#39;1234 1234 1234 1234&#39;;\nconst lastFour = card.slice(-4);\nconst masked = lastFour.padStart(card.length, &#39;*&#39;);\n\nconsole.log(masked); // &#39;************1234&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es8-trailing-commas\&#34;&gt;ES8 - Trailing Commas&lt;/h2&gt;\n&lt;p&gt;在 ES8 中，我们可以通过在函数参数的最后一个元素后面添加逗号来让 JavaScript 忽略最后一个参数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;function log(a, b, c,) {\n  console.log(a, b, c);\n}\n\nlog(1, 2, 3); // 1 2 3\nlog(1, 2, 3, 4); // 1 2 3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es10-flat-flatmap\&#34;&gt;ES10 - flat flatMap&lt;/h2&gt;\n&lt;p&gt;flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。&lt;/p&gt;\n&lt;p&gt;flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。&lt;/p&gt;\n&lt;p&gt;注意一：flatMap是先进行map操作，再做flat的操作；&lt;br&gt;\n注意二：flatMap中的flat相当于深度为1；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const arr = [1, 2, 3, [4, 5], 6, [7, [8, 9]]];\n\nconsole.log(arr.flat()); // [1, 2, 3, 4, 5, 6, 7, [8, 9]]\nconsole.log(arr.flat(2)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nconst arr2 = [&#39;a b c&#39;, &#39;d e f&#39;, &#39;g h i&#39;];\nconsole.log(arr2.flatMap(x =&amp;gt; x.split(&#39; &#39;))); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es10-object-fromentries\&#34;&gt;ES10 - Object fromEntries&lt;/h2&gt;\n&lt;p&gt;ES8提供了对象转换方法Object.fromEntries，可以将一个键值对数组转换为对象，如果有entries怎么转换成对象呢？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const entries = [[&#39;name&#39;, &#39;张三&#39;], [&#39;age&#39;, 18]];\nconst obj = Object.fromEntries(entries);\nconsole.log(obj); // {name: &#39;张三&#39;, age: 18}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es10-trimstart-trimend\&#34;&gt;ES10 - trimStart trimEnd&lt;/h2&gt;\n&lt;p&gt;去除一个字符串首尾的空格，我们可以通过trim方法，如果单独去除前面或者后面呢？&lt;br&gt;\nES10中给我们提供了trimStart和trimEnd；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const str = &#39;  hello  &#39;;\nconsole.log(str.trimStart()); // &#39;hello  &#39;\nconsole.log(str.trimEnd()); // &#39;  hello&#39;\nconsole.log(str.trim()); // &#39;hello&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es11-bigint\&#34;&gt;ES11 - BigInt&lt;/h2&gt;\n&lt;p&gt;BigInt是一个新的数据类型，它可以表示一个大的整数，比如 JavaScript 中的整数只能表示到 2^53 之间，BigInt 可以表示到 2^1024 之间。BitInt的表示方法是在数值的后面加上n。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const int = 2 ** 53;\nconsole.log(int) // 9007199254740992\nconsole.log(int + 1); // 9007199254740992 无法直接加1，因为这个数超过了2的53次方\n\nconst bigInt = BigInt(9007199254740993);\nconsole.log(bigInt); // 9007199254740993n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es11-nullish-coalescing-operator\&#34;&gt;ES11 - Nullish Coalescing Operator&lt;/h2&gt;\n&lt;p&gt;ES11，Nullish Coalescing Operator增加了空值合并操作符：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const a = undefined;\n\nconst r1 = a ?? &#39;default&#39;;\nconsole.log(r1); // &#39;default&#39;\n\nconst r2 = a || &#39;default&#39;;\nconsole.log(r2); // &#39;default&#39;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es11-optional-chaining\&#34;&gt;ES11 - Optional Chaining&lt;/h2&gt;\n&lt;p&gt;ES11，Optional Chaining增加了对象属性的可选调用：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const obj = {\n  a: {\n    b: {\n      c: &#39;hello&#39;\n    }\n  }\n};\n\nif (obj.a &amp;amp;&amp;amp; obj.a.b &amp;amp;&amp;amp; obj.a.b.c) {\n  console.log(obj.a.b.c); // &#39;hello&#39;\n}\n\nconsole.log(obj?.a?.b?.c); // &#39;hello&#39;\nconsole.log(obj?.a?.b?.d); // undefined\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es11-global-this\&#34;&gt;ES11 - Global This&lt;/h2&gt;\n&lt;p&gt;在之前我们希望获取JavaScript环境的全局对象，不同的环境获取的方式是不一样的：比如在浏览器中可以通过this、window来获取，在Node中我们需要通过global来获取……那么在ES11中对获取全局对象进行了统一的规范：globalThis：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;console.log(global); // &amp;lt;ref *1&amp;gt; Object [global]  {...}\nconsole.log(this); // Window {...}\nconsole.log(globalThis); // Window {...}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es12-finalizationregistry\&#34;&gt;ES12 - FinalizationRegistry&lt;/h2&gt;\n&lt;p&gt;FinalizationRegistry是一个新的对象，用于管理对象的清理工作，它可以在可以让你在对象被垃圾回收时请求一个回调。&lt;br&gt;\nFinalizationRegistry 提供了这样的一种方法：当一个在注册表中注册的对象被回收时，请求在某个时间点上调用一个清理回调。（清理回调有时被称为 finalizer ）; 你可以通过调用register方法，注册任何你想要清理回调的对象，传入该对象和所含的值;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const registry = new FinalizationRegistry(\n  (target) =&amp;gt; {\n    console.log(&#39;对象被销毁&#39;, target); // &amp;lt;ref *2&amp;gt; Object {...}\n  }\n);\n\nconst obj = {name: &#39;张三&#39;};\nregistry.register(obj, &#39;hello&#39;);\n\nobj = null;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es12-weakrefs\&#34;&gt;ES12 - WeakRefs&lt;/h2&gt;\n&lt;p&gt;WeakRefs是一个新的对象，用于管理对象的弱引用，如果我们默认将一个对象赋值给另外一个引用，那么这个引用是一个强引用：如果我们希望是一个弱引用的话，可以使用WeakRef；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javaScript\&#34;&gt;const obj = {name: &#39;张三&#39;};\n\nconst weakRef = new WeakRef(obj);\n\nweakRef.name = &#39;李四&#39;;\n\nconsole.log(obj.name); // 张三\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;es12-logical-assignment-operators\&#34;&gt;ES12 - logical assignment operators&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;||= 逻辑或赋值运算&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;let message = &amp;quot;hello world&amp;quot;\nmessage = message || &amp;quot;default value&amp;quot; // &amp;quot;hello world&amp;quot;\nmessage ||= &amp;quot;default value&amp;quot; // &amp;quot;hello world&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;&amp;amp;&amp;amp;= 逻辑与赋值运算&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;let message = &amp;quot;hello world&amp;quot;\nmessage = message &amp;amp;&amp;amp; &amp;quot;default value&amp;quot; // &amp;quot;default value&amp;quot;\nmessage &amp;amp;&amp;amp;= &amp;quot;default value&amp;quot; // &amp;quot;default value&amp;quot;\n\nlet info = { name: &#39;张三&#39; };\ninfo &amp;amp;&amp;amp;= info.name; // &amp;quot;张三&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;??= 逻辑或赋值运算&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;let message = &amp;quot;hello world&amp;quot;\nmessage ??= &amp;quot;default value&amp;quot; // &amp;quot;hello world&amp;quot;\nlet blank = &#39;&#39;\nblank ??= &amp;quot;default value&amp;quot; // &amp;quot;default value&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;tbAaAqNsf&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;ES7~ES12是 ES6 的补充，里面有很多比较灵活的用法可以在日常中使用，如果对 ES6 不太熟悉的可以看看这里：&lt;a href=\&#34;https://ricky.shineteens.com/post/j9qm98nhv/\&#34;&gt;JavaScript｜ES6日常用法详解&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;es7-array-includes\&#34;&gt;ES7 - Array Includes&lt;/h2&gt;\n&lt;p&gt;在ES7之前，如果我们想判断一个数组中是否包含某个元素，需要通过 indexOf 获取结果，并且判断是否为 -1。 在ES7中，我们可以通过includes来判断一个数组中是否包含一个指定的元素，根据情况，如果包含则返回 true， 否则返回false。&lt;br&gt;\n&lt;code&gt;arr.includes(valueToFind[, fromIndex])&lt;/code&gt;&lt;br&gt;\nfromIndex(可选): 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-js\&#34;&gt;const arr = [1, 2, 3, 4, 5];\nconsole.log(arr.includes(3)); // true\nconsole.log(arr.includes(6)); // false\nconsole.log(arr.includes(3, 3)); // false\nconsole.log(arr.includes(3, -1)); // true\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript｜ES7~ES12常见基础用法&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ES6&#34;,&#34;slug&#34;:&#34;fB0pVEAG4&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/fB0pVEAG4/&#34;},{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;2BbnUmwOd&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/2BbnUmwOd/&#34;}],&#34;date&#34;:&#34;2022-08-15 18:51:55&#34;,&#34;dateFormat&#34;:&#34;2022-08-15&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/tbAaAqNsf/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:415000,&#34;words&#34;:1554,&#34;minutes&#34;:7},&#34;description&#34;:&#34;ES7~ES12是 ES6 的补充，里面有很多比较灵活的用法可以在日常中使用，如果对 ES6 不太熟悉的可以看看这里：JavaScript｜ES6日常用法详解\nES7 - Array Includes\n在ES7之前，如果我们想判断一个数组中...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#es7-array-includes\&#34;&gt;ES7 - Array Includes&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es7-%E6%8C%87%E6%95%B0%E4%B9%98%E6%96%B9-exponentiation%E8%BF%90%E7%AE%97%E7%AC%A6\&#34;&gt;ES7 –指数(乘方) exponentiation运算符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es8-object-values\&#34;&gt;ES8 Object values&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es8-object-entries\&#34;&gt;ES8 Object Entries&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es8-string-padstart%E5%92%8Cpadend\&#34;&gt;ES8 String PadStart和PadEnd&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es8-trailing-commas\&#34;&gt;ES8 - Trailing Commas&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es10-flat-flatmap\&#34;&gt;ES10 - flat flatMap&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es10-object-fromentries\&#34;&gt;ES10 - Object fromEntries&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es10-trimstart-trimend\&#34;&gt;ES10 - trimStart trimEnd&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es11-bigint\&#34;&gt;ES11 - BigInt&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es11-nullish-coalescing-operator\&#34;&gt;ES11 - Nullish Coalescing Operator&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es11-optional-chaining\&#34;&gt;ES11 - Optional Chaining&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es11-global-this\&#34;&gt;ES11 - Global This&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es12-finalizationregistry\&#34;&gt;ES12 - FinalizationRegistry&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es12-weakrefs\&#34;&gt;ES12 - WeakRefs&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#es12-logical-assignment-operators\&#34;&gt;ES12 - logical assignment operators&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;单体架构\&#34;&gt;单体架构&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f5fddcc6f67.png\&#34; alt=\&#34;1660288475283.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;单体架构即将所有的业务放在一个项目中开发，作为一个应用部署，这样的架构比较简单，但是不能满足复杂的业务需求。早期互联网产品因为流量小所以靠单体应用也能维持业务，但现在随着业务更加复杂单体应用已经满足不了。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;比如说一个电商系统，里面会包含很多用户管理，商品管理，订单管理，物流管理等等很多模块，我们会把它们做成一个web项目，然后部署到一台tomcat服务器上。&lt;/p&gt;\n&lt;p&gt;单体架构优点：单体架构比较简单，部署和维护成本低。&lt;/p&gt;\n&lt;p&gt;单体架构缺点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;单体架构不能满足复杂的业务需求，需要更多的资源和时间来开发复杂的应用。&lt;/li&gt;\n&lt;li&gt;模块之间紧密耦合，单点容错率低&lt;/li&gt;\n&lt;li&gt;无法很好地针对不同模块进行性能优化和扩展&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f605e44f950.png\&#34; alt=\&#34;1660290532080.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;垂直应用架构\&#34;&gt;垂直应用架构&lt;/h2&gt;\n&lt;p&gt;随着访问量的逐渐增大，单一应用只能依靠增加节点来应对，但是这时候会发现并不是所有的模块都会有比较大的访问量。还是以上面的电商为例子，用户访问量的增加可能影响的只是用户和订单模块，但是对消息模块的影响就比较小. 那么此时我们希望只多增加几个订单模块，而不增加消息模块. 此时单体应用就做不到了，垂直应用就应运而生了。&lt;/p&gt;\n&lt;p&gt;垂直应用架构是一种更加灵活的架构，它将业务模块划分成多个独立的项目，每个项目都是一个独立的应用，这样的架构比较灵活。&lt;/p&gt;\n&lt;p&gt;例如一个单体应用的电商系统可以拆分成：电商系统(用户管理 商品管理 订单管理)、后台系统(用户管理 订单管理 客户管理)、CMS系统(广告管理 营销管理)&lt;/p&gt;\n&lt;p&gt;这样拆分完毕之后，一旦用户访问量变大，只需要增加电商系统的节点就可以了，而无需增加后台和CMS的节点。&lt;/p&gt;\n&lt;p&gt;优点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;系统拆分实现了流量分担，解决了并发问题，而且可以针对不同模块进行优化和水扩展&lt;/li&gt;\n&lt;li&gt;一个系统的问题不会影响到其他系统，提高容错率&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;缺点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;系统之间相互独立，无法进行相互调用&lt;/li&gt;\n&lt;li&gt;系统之间相互独立，会有重复的开发任务&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f606dde9df5.png\&#34; alt=\&#34;1660290781607.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;分布式架构\&#34;&gt;分布式架构&lt;/h2&gt;\n&lt;p&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f5fe172fffc.png\&#34; alt=\&#34;1660288534744.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n当垂直应用越来越多，重复的业务代码就会越来越多。这时候，我们就思考可不可以将重复的代码抽取出来，做成统一的业务层作为独立的服务，然后由前端控制层调用不同的业务层服务呢？&lt;/p&gt;\n&lt;p&gt;这就产生了新的分布式系统架构。它将把工程拆分成表现层和服务层两个部分：&lt;/p&gt;\n&lt;p&gt;服务层中包含业务逻辑，例如数据库操作，网络请求，文件读写等等。&lt;/p&gt;\n&lt;p&gt;表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。&lt;/p&gt;\n&lt;p&gt;优点：分布式架构可以满足复杂的业务需求，并且抽取公共功能为服务层，提高代码复用性&lt;/p&gt;\n&lt;p&gt;缺点：系统间耦合度变高，调用关系复杂，难以维护&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f60adf9df52.png\&#34; alt=\&#34;1660291807335.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;soa架构\&#34;&gt;SOA架构&lt;/h2&gt;\n&lt;p&gt;在分布式架构下，当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加&lt;br&gt;\n一个调度中心对集群进行实时管理。&lt;/p&gt;\n&lt;p&gt;此时，用于资源调度和治理中心(SOA Service Oriented Architecture，面向服务的架构)是关键。&lt;/p&gt;\n&lt;p&gt;优点: 使用注册中心解决了服务间调用关系的自动调节&lt;/p&gt;\n&lt;p&gt;缺点:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;服务间会有依赖关系，一旦某个环节出错会影响较大( 服务雪崩 )&lt;/li&gt;\n&lt;li&gt;服务关系复杂，运维、测试部署困难&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f60f2ccf2c7.jpg\&#34; alt=\&#34;62f60f2ccf2c7\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;微服务架构\&#34;&gt;微服务架构&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f610e8e18a5.png\&#34; alt=\&#34;1660293352644.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;微服务架构在某种程度上是面向服务的架构SOA继续发展的下一步，它更加强调服务的&amp;quot;彻底拆分&amp;quot;。&lt;/p&gt;\n&lt;p&gt;微服务架构特征：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发&lt;/li&gt;\n&lt;li&gt;面向服务：微服务对外暴露业务接口&lt;/li&gt;\n&lt;li&gt;自治：团队独立、技术独立、数据独立、部署独立&lt;/li&gt;\n&lt;li&gt;隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;优点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;服务原子化拆分，独立打包、部署和升级，保证每个微服务清晰的任务划分，利于扩展&lt;/li&gt;\n&lt;li&gt;微服务之间采用tcp协议相互调用&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;缺点：架构非常复杂，运维、监控、部署难度提高&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f61115cfe14.png\&#34; alt=\&#34;1660293397706.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;7cQbwosME&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;单体架构\&#34;&gt;单体架构&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/12/62f5fddcc6f67.png\&#34; alt=\&#34;1660288475283.png\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;单体架构即将所有的业务放在一个项目中开发，作为一个应用部署，这样的架构比较简单，但是不能满足复杂的业务需求。早期互联网产品因为流量小所以靠单体应用也能维持业务，但现在随着业务更加复杂单体应用已经满足不了。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;微服务｜系统应用架构演变&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;微服务&#34;,&#34;slug&#34;:&#34;tzlLItuaD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/tzlLItuaD/&#34;},{&#34;name&#34;:&#34;分布式系统&#34;,&#34;slug&#34;:&#34;VfSpNRpldr&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/VfSpNRpldr/&#34;},{&#34;name&#34;:&#34;系统架构&#34;,&#34;slug&#34;:&#34;qhk6X1vFr6&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/qhk6X1vFr6/&#34;}],&#34;date&#34;:&#34;2022-08-12 10:19:12&#34;,&#34;dateFormat&#34;:&#34;2022-08-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/7cQbwosME/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:255000,&#34;words&#34;:1264,&#34;minutes&#34;:5},&#34;description&#34;:&#34;单体架构\n\n单体架构即将所有的业务放在一个项目中开发，作为一个应用部署，这样的架构比较简单，但是不能满足复杂的业务需求。早期互联网产品因为流量小所以靠单体应用也能维持业务，但现在随着业务更加复杂单体应用已经满足不了。\n\n比如说一个电商系统，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84\&#34;&gt;单体架构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9E%82%E7%9B%B4%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84\&#34;&gt;垂直应用架构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84\&#34;&gt;分布式架构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#soa%E6%9E%B6%E6%9E%84\&#34;&gt;SOA架构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84\&#34;&gt;微服务架构&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;ES6全称ECMAScript 6.0 ，是JavaScript 的下一个版本标准。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。&lt;/p&gt;\n&lt;p&gt;在前文中提到了ES6的新特性——class语法糖的使用。本文来讲讲除了class外ES6～ES12其他的新的特性，如果没有读的可以去看看：&lt;a href=\&#34;https://ricky.shineteens.com/post/u7zwdeg-m/\&#34;&gt;JavaScript｜Class定义类&lt;/a&gt;。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;字面量的增强\&#34;&gt;字面量的增强&lt;/h2&gt;\n&lt;p&gt;ES6中对&lt;strong&gt;对象字面量&lt;/strong&gt;进行了增强，主要包括三个部分：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;属性的简写&lt;/li&gt;\n&lt;li&gt;方法的简写&lt;/li&gt;\n&lt;li&gt;计算属性名&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javaScript\&#34;&gt;var name = &#39;ricky&#39;\nvar age = 18\n\nvar obj = {\n    // 属性的简写\n    name,\n    age,\n    // 方法的简写\n    foo: function() { // 一般写法\n        console.log(this);\n    },\n    bar() { // 简写\n        console.log(this);\n    },\n    bar2: ()=&amp;gt; { // 箭头函数\n        console.log(this);\n    }\n    // 计算属性名\n    [name+233]: &#39;Hello, world!&#39;,\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;解构\&#34;&gt;解构&lt;/h2&gt;\n&lt;h3 id=\&#34;数组解构\&#34;&gt;数组解构&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var names = [&amp;quot;abc&amp;quot;, &amp;quot;cba&amp;quot;, &amp;quot;nba&amp;quot;]\n\n// 对数组的解构: []\nvar [item1, item2, item3] = names\nconsole.log(item1, item2, item3) // abc cba nba\n\n// 解构后面的元素\nvar [, , itemz] = names\nconsole.log(itemz) // nba\n\n// 解构出一个元素,后面的元素放到一个新数组中\nvar [itemx, ...newNames] = names\nconsole.log(itemx, newNames) // abc [&#39;cba&#39;, &#39;nba&#39;]\n\n// 解构的默认值\nvar [itema, itemb, itemc, itemd = &amp;quot;aaa&amp;quot;] = names\nconsole.log(itemd) // aaa\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;对象解构\&#34;&gt;对象解构&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var obj = {\n  name: &amp;quot;Ricky&amp;quot;,\n  age: 18,\n  height: 1.88\n}\n\n// 对象的解构: {}\nvar { name, age, height } = obj\nconsole.log(name, age, height) // Ricky 18 1.88\n\n// 解构后赋予其他变量名\nvar { name: newName } = obj\nconsole.log(newName) // Ricky\n\n// 设置默认值\nvar { address: newAddress = &amp;quot;广州市&amp;quot; } = obj\nconsole.log(newAddress) // 广州市\n\n\nfunction foo(info) {\n  console.log(info.name, info.age)\n}\n\nfoo(obj) // Ricky 18\n\nfunction bar({name, age}) {\n  console.log(name, age)\n}\n\nbar(obj) // Ricky 18\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;letconst的使用\&#34;&gt;let/const的使用&lt;/h2&gt;\n&lt;p&gt;在ES5中，我们使用var来声明变量，从ES6开始我们可以通过let/const来声明。&lt;/p&gt;\n&lt;p&gt;let关键字：从直观的角度来说，let和var是没有太大的区别的，都是用于声明一个变量。&lt;/p&gt;\n&lt;p&gt;const关键字： 它表示保存的数据一旦被赋值，就不能被修改； 但是如果赋值的是引用类型，那么可以通过引用找到对应的对象，修改对象的内容。&lt;/p&gt;\n&lt;h3 id=\&#34;作用域提升\&#34;&gt;作用域提升&lt;/h3&gt;\n&lt;p&gt;let、const和var的另一个重要区别是作用域提升：我们知道var声明的变量是会进行作用域提升的；但是如果我们使用let声明的变量，在声明之前访问会报错。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;console.log(a); // undifined\n\nvar a = &#39;Hello, world!&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;console.log(a); // ReferenceError: Cannot access &#39;a&#39; before initialization\n\nlet a = &#39;Hello, world!&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这些变量会被创建在包含他们的词法环境被实例化时，但是是不可以访问它们的，直到词法绑定被求值。从这里可以看出let、const没有进行作用域提升，但是会在解析阶段被创建出来。&lt;/p&gt;\n&lt;h3 id=\&#34;变量保存\&#34;&gt;变量保存&lt;/h3&gt;\n&lt;p&gt;我们知道通过var声明的变量会被保存在window中，但let/const是不会给window添加属性的。在ECMA标准有这样一个描述：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;每一个执行上下文会被关联到一个变量环境 (variable object, VO)，在源代码中的变量和函数声明会被作为属性添加到VO中。对于函数来说，参数也会被添加到VO中。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;blockquote&gt;\n&lt;p&gt;每一个执行上下文会关联到一个变量环境 (VariableEnvironment) 中，在执行代码中变量和函数的声明会作为环境记录 (Environment Record) 添加到变量环境中。对于函数来说，参数也会被作为环境记录添加到变量环境中。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;所以通过let/const声明的变量会被添加到变量环境中，但不是window对象上。在v8中通过VariableMap的hashmap来实现变量存储。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://nas.shineteens.com:9999/i/2022/08/10/62f3758c370c7.png\&#34; alt=\&#34;62f3758c370c7\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;块级作用域\&#34;&gt;块级作用域&lt;/h2&gt;\n&lt;p&gt;在ES5中只有两个东西会形成作用域：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;全局作用域&lt;/li&gt;\n&lt;li&gt;函数作用域&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;在ES6中新增了块级作用域，并且通过let、const、function、class声明的标识符是具备块级作用域的限制的，但块级作用域内不函数可以被外部访问，因为引擎会对函数进行特殊处理：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javaScript\&#34;&gt;{\n  let foo = &amp;quot;why&amp;quot;\n  function demo() {\n    console.log(&amp;quot;demo function&amp;quot;)\n  }\n  class Person {}\n}\n\nconsole.log(foo) // foo is not defined\n// 不同的浏览器有不同实现的(大部分浏览器为了兼容以前的代码, 让function是没有块级作用域)\ndemo() // demo function\nvar p = new Person() // Person is not defined\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;块级作用域案例——多个按钮监听点击：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-html\&#34;&gt;&amp;lt;button&amp;gt;button1&amp;lt;/button&amp;gt;\n&amp;lt;button&amp;gt;button2&amp;lt;/button&amp;gt;\n&amp;lt;button&amp;gt;button3&amp;lt;/button&amp;gt;\n&amp;lt;button&amp;gt;button4&amp;lt;/button&amp;gt;\n&amp;lt;script&amp;gt;\nconst btns = document.getElementsByTagName(&#39;button&#39;)\nfor (let i = 0; i &amp;lt; btns.length; i++) {\n  btns[i].onclick = function() {\n    console.log(&amp;quot;第&amp;quot; + i + &amp;quot;个按钮被点击&amp;quot;)\n  }\n}\n&amp;lt;/script&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;暂时性死区\&#34;&gt;暂时性死区&lt;/h3&gt;\n&lt;p&gt;是在一个代码中，使用let、const声明的变量，在声明之前，变量都是不可以访问的：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var foo = &#39;foo&#39;;\n\nif (1) {\n    console.log(foo); // ReferenceError: Cannot access &#39;foo&#39; before initialization\n    let foo = &#39;bar&#39;;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;模版字符串\&#34;&gt;模版字符串&lt;/h2&gt;\n&lt;p&gt;通过&lt;code&gt;${...}&lt;/code&gt;可以实现模版字符串&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javaScript\&#34;&gt;// ES6之前拼接字符串和其他标识符\nconst name = &amp;quot;Ricky&amp;quot;\nconst age = 18\nconst height = 1.88\n// ES6提供模板字符串 ``\nconst message = `my name is ${name}, age is ${age}, height is ${height}`\nconsole.log(message) // my name is Ricky, age is 18, height is 1.88\n\n// 能够实现运算\nconst info = `age double is ${age * 2}`\nconsole.log(info) // 36\n\n// 能够实现函数\nfunction doubleAge() {\n  return age * 2\n}\n\nconst info2 = `double age is ${doubleAge()}`\nconsole.log(info2) // 36\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;一个不怎么常用的方法：标签模块字符串&lt;/p&gt;\n&lt;p&gt;第一个参数依然是模块字符串中整个字符串, 只是被切成多块,放到了一个数组中&lt;br&gt;\n第二个参数是模块字符串中, 第一个 ${}&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javaScript\&#34;&gt;function foo(m, n, x) {\n  console.log(m, n, x)\n}\n\nfoo`Hello World` // [ &#39;Hello World&#39; ] undefined undefined\n\nconst name = &amp;quot;Ricky&amp;quot;\nconst age = 18\n// [&#39;Hello&#39;, &#39;Wo&#39;, &#39;rld&#39;]\nfoo`Hello${name}Wo${age}rld` // [ &#39;Hello&#39;, &#39;Wo&#39;, &#39;rld&#39; ] Ricky 18\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;函数默认值\&#34;&gt;函数默认值&lt;/h2&gt;\n&lt;p&gt;可以在创建函数的时候很方便地为参数设置默认值，但最好有默认值的参数放在最后;&lt;br&gt;\n另外默认值会改变函数的length的个数，默认值以及后面的参数都不计算在length之内了.&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javaScript\&#34;&gt;// 1.ES6可以给函数参数提供默认值\nfunction foo(m = &amp;quot;aaa&amp;quot;, n = &amp;quot;bbb&amp;quot;) {\n  console.log(m, n)\n}\n\nfoo() // aaa bbb \nfoo(0, &amp;quot;&amp;quot;) // 0 \n\n// 2.对象参数和默认值以及解构\nfunction printInfo({name, age} = {name: &amp;quot;Ricky&amp;quot;, age: 18}) {\n  console.log(name, age)\n}\n\nprintInfo({name: &amp;quot;kobe&amp;quot;, age: 40}) // kobe 40\n\n// 另外一种写法\nfunction printInfo1({name = &amp;quot;Ricky&amp;quot;, age = 18} = {}) {\n  console.log(name, age)\n}\n\nprintInfo1() // Ricky 18\n\n// 3.有默认值的形参最好放到最后\nfunction bar(x, y, z = 30) {\n  console.log(x, y, z)\n}\n\nbar(10, 20) // 10 20 30\nbar(undefined, 10, 20) // undefined 10 20\n\n// 4.有默认值的函数的length属性\nfunction baz(x, y, z, m, n = 30) {\n  console.log(x, y, z, m, n)\n}\n\nfunction baz1(x, y, z, m, n) {\n  console.log(x, y, z, m, n)\n}\n\nconsole.log(baz.length) // 4\nconsole.log(baz1.length) // 5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;函数剩余参数\&#34;&gt;函数剩余参数&lt;/h2&gt;\n&lt;p&gt;ES6中引用了rest parameter，可以将不定数量的参数放入到一个数组中：如果最后一个参数是 ... 为前缀的，那么它会将剩余的参数放到该参数中，并且作为一个数组。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javaScript\&#34;&gt;function fun(m, n, ...args) {\n    console.log(m, n);\n    console.log(args);\n}\n\nfun(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;);  //a b [ &#39;c&#39;, &#39;d&#39; ]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;与arguments区别：剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参；arguments对象不是一个真正的数组，而rest参数是一个真正的数组，可以进行数组的所有操作；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javaScript\&#34;&gt;function fun1(m, n) {\n  console.log(m, n);\n  console.log(arguments);\n}\n\nfun1(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;); // a b [Arguments] { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, &#39;3&#39;: &#39;d&#39; }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;箭头函数\&#34;&gt;箭头函数&lt;/h2&gt;\n&lt;p&gt;箭头函数没有显示原型，不能作为构造函数，即不能new:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;const foo = () =&amp;gt; {\n    console.log(&#39;foo&#39;);\n}\n\nconsole.log(foo.prototype); // undefined\nvar f = new foo(); // TypeError: foo is not a constructor\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;展开语法\&#34;&gt;展开语法&lt;/h2&gt;\n&lt;p&gt;可以在函数调用/数组构造时，将数组表达式或者string在语法层面展开，还可以在构造字面量对象时, 将对象表达式按key-value的方式展开：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;const str = &#39;Hello&#39;;\nconsole.log(...str); // H e l l o\n\nconst arr = [1, 2, 3];\nconst arr1 = [...arr, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]\n\nconst obj = {a: 1, b: 2};\nconst obj1 = {...obj, c: 3, d: 4}; // {a: 1, b: 2, c: 3, d: 4}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;数值表示\&#34;&gt;数值表示&lt;/h2&gt;\n&lt;p&gt;在ES6中规范了二进制和八进制的写法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;const binary = 0b11111111; // 二进制 -&amp;gt; 十进制: 255\nconst octal = 0o377; // 八进制 -&amp;gt; 十进制: 255\nconst hex = 0xFF; // 十六进制 -&amp;gt; 十进制: 255\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在ES2021新增特性：数字过长时，可以使用_作为连接符：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;const bigNum = 123_456_789_123; // 123456789123\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;symbol作为属性名\&#34;&gt;Symbol作为属性名&lt;/h2&gt;\n&lt;p&gt;Symbol是一种新的基本数据类型，可以用来描述对象的属性名，在ES6之前，对象的属性名都是字符串形式，那么很容易造成属性名的冲突。比如原来有一个对象，我们希望在其中添加一个新的属性和值，但是我们在不确定它原来内部有什么内容的情况下，很容易造成冲突，从而覆盖掉它内部的某个属性。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;const key1 = Symbol(&#39;key&#39;);\nconst key2 = Symbol(&#39;key&#39;);\n\nconsole.log(key1 === key2); // false\n\nconst obj = {\n    [key1]: &#39;value1&#39;,\n    [key2]: &#39;value2&#39;\n}\n\n// Symbol只能通过[key]访问\nconsole.log(obj[key1], obj[key2]); // value1 value2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;setmap\&#34;&gt;Set&amp;amp;Map&lt;/h2&gt;\n&lt;p&gt;在ES6之前，我们存储数据的结构主要有两种：数组、对象。 在ES6中新增了另外两种数据结构：Set、Map，以及它们的另外形式WeakSet、WeakMap。&lt;/p&gt;\n&lt;h3 id=\&#34;set\&#34;&gt;Set&lt;/h3&gt;\n&lt;p&gt;Set是一个新增的数据结构，可以用来保存数据，类似于数组，但是和数组的区别是元素不能重复。创建Set我们需要通过Set构造函数（暂时没有字面量创建的方式）：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;const set = new Set();\n\n// 添加元素\nset.add(1);\nset.add(2);\nset.add(3);\nset.add(1);\n\nconsole.log(set); // Set(3) { 1, 2, 3 }\n\n// 删除元素\nset.delete(1);\n\nconsole.log(set); // Set(2) { 2, 3 }\n\n// 判断是否存在元素\nconsole.log(set.has(1)); // false\nconsole.log(set.has(2)); // true\n\n// 清空Set\nset.clear();\n\nconsole.log(set); // Set(0) {}\n\n// 遍历Set: 可以forEach和for of\nconst set1 = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])\n\nset1.forEach(item =&amp;gt; {\n    console.log(item); // a b c d\n}\n\nfor (let value of set1) {\n    console.log(value); // a b c d\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;常见用法——数组去重：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5];\n\nconst set = new Set(arr);\n\nconst newArr = Array.from(set);\n\nconsole.log(newArr); // 1 2 3 4 5 6 7 8 9 10\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;weakset\&#34;&gt;WeakSet&lt;/h3&gt;\n&lt;p&gt;WeakSet是新增和Set类似的数据结构，可以用来保存对象，但是和Set不同的是：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;WeakSet中只能存放对象类型，不能存放基本数据类型&lt;/li&gt;\n&lt;li&gt;WeakSet的每个元素都是弱引用，即垃圾回收机制不考虑WeakSet对该元素的引用，因此，如果元素所在的内存被回收，该元素也会被回收。&lt;/li&gt;\n&lt;li&gt;WeakSet不能遍历：因为WeakSet只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁。所以存储到WeakSet中的对象是没办法获取的&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;一个作用——防止通过非构造方法创建出来的对象调用：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javaScript\&#34;&gt;const set = new WeakSet();\n\nclass Person {\n  constructor(name) {\n      this.name = name;\n      set.add(this)\n  }\n  sayHi() {\n      if (!set.has(this)) throw new Error(&#39;不能调用非构造方法创建出来的对象&#39;)；\n      console.log(`Hi, I am ${this.name}`);\n  }\n}；\n\nconst person1 = new Person(&#39;张三&#39;);\nperson1.sayHi(); // Hi, I am 张三\n\nperson1.sayHi.call({name: &#39;李四&#39;}); // Error: 不能调用非构造方法创建出来的对象\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;map\&#34;&gt;Map&lt;/h3&gt;\n&lt;p&gt;Map是一个新增的数据结构，可以用来保存键值对，类似于对象，但是和对象的区别是键不能重复，而且可以用其他类型作为键。创建Map我们需要通过Map构造函数（暂时没有字面量创建的方式）：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;const map = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]]);\n\n// 添加元素\nmap.set(&#39;d&#39;, 4);\n\nconsole.log(map); // Map(4) { &#39;a&#39; =&amp;gt; 1, &#39;b&#39; =&amp;gt; 2, &#39;c&#39; =&amp;gt; 3, &#39;d&#39; =&amp;gt; 4 }\n\n// 可以设置其他类型的键\nmap.set({ name: &#39;a&#39; }, 5); // Map(5) { &#39;a&#39; =&amp;gt; 1, &#39;b&#39; =&amp;gt; 2, &#39;c&#39; =&amp;gt; 3, &#39;d&#39; =&amp;gt; 4, { name: &#39;a&#39; } =&amp;gt; 5 }\n\n// 查找元素\nconsole.log(map.get(&#39;a&#39;)); // 1\n\n// 删除元素\nmap.delete(&#39;a&#39;);\n\nconsole.log(map); // Map(4) { &#39;b&#39; =&amp;gt; 2, &#39;c&#39; =&amp;gt; 3, &#39;d&#39; =&amp;gt; 4 , { name: &#39;a&#39; } =&amp;gt; 5 }\n\n// 判断是否存在元素\nconsole.log(map.has(&#39;a&#39;)); // false\nconsole.log(map.has(&#39;b&#39;)); // true\n\n// 清空Map\nmap.clear();\n\nconsole.log(map); // Map(0) {}\n\n// 遍历Map: 可以forEach和for of\nconst map1 = new Map([[&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]])\n\nmap1.forEach((value, key) =&amp;gt; {\n    console.log(key, value); // a 1 b 2 c 3\n}\n\nfor (let [key, value] of map1) {\n    console.log(key, value); // a 1 b 2 c 3\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;weakmap\&#34;&gt;WeakMap&lt;/h3&gt;\n&lt;p&gt;WeakMap是新增的数据结构，可以用来保存对象，但是和Map不同的是：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;WeakMap中只能存放对象类型，不能存放基本数据类型&lt;/li&gt;\n&lt;li&gt;WeakMap的每个元素都是弱引用，即垃圾回收机制不考虑WeakMap对该元素的引用，因此，如果元素所在的内存被回收，该元素也会被回收。&lt;/li&gt;\n&lt;li&gt;WeakMap不能遍历：因为WeakMap只是对对象的弱引用，如果我们遍历获取到其中的元素，那么有可能造成对象不能正常的销毁。所以存储到WeakMap中的对象是没办法获取的&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;可以通过WeakMap来实现响应式原理，将对象和方法存储在一起，当对象的属性发生变化时，可以自动触发对应的方法，而对象销毁的时候WeakMap也会销毁：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// 应用场景(vue3响应式原理)\nconst obj1 = {\n  name: &amp;quot;Ricky&amp;quot;,\n  age: 18\n}\n\nfunction obj1NameFn1() {\n  console.log(&amp;quot;obj1NameFn1被执行&amp;quot;)\n}\n\nfunction obj1NameFn2() {\n  console.log(&amp;quot;obj1NameFn2被执行&amp;quot;)\n}\n\nfunction obj1AgeFn1() {\n  console.log(&amp;quot;obj1AgeFn1&amp;quot;)\n}\n\nfunction obj1AgeFn2() {\n  console.log(&amp;quot;obj1AgeFn2&amp;quot;)\n}\n\nconst obj2 = {\n  name: &amp;quot;kobe&amp;quot;,\n  height: 1.88,\n  address: &amp;quot;广州市&amp;quot;\n}\n\nfunction obj2NameFn1() {\n  console.log(&amp;quot;obj1NameFn1被执行&amp;quot;)\n}\n\nfunction obj2NameFn2() {\n  console.log(&amp;quot;obj1NameFn2被执行&amp;quot;)\n}\n\n// 1.创建WeakMap\nconst weakMap = new WeakMap()\n\n// 2.收集依赖结构\n// 2.1.对obj1收集的数据结构\nconst obj1Map = new Map()\nobj1Map.set(&amp;quot;name&amp;quot;, [obj1NameFn1, obj1NameFn2])\nobj1Map.set(&amp;quot;age&amp;quot;, [obj1AgeFn1, obj1AgeFn2])\nweakMap.set(obj1, obj1Map)\n\n// 2.2.对obj2收集的数据结构\nconst obj2Map = new Map()\nobj2Map.set(&amp;quot;name&amp;quot;, [obj2NameFn1, obj2NameFn2])\nweakMap.set(obj2, obj2Map)\n\n// 3.如果obj1.name发生了改变\n// Proxy/Object.defineProperty\nobj1.name = &amp;quot;james&amp;quot;\nconst targetMap = weakMap.get(obj1)\nconst fns = targetMap.get(&amp;quot;name&amp;quot;)\nfns.forEach(item =&amp;gt; item()) // obj1NameFn1被执行 obj1NameFn2被执行\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;J9qM98Nhv&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;ES6全称ECMAScript 6.0 ，是JavaScript 的下一个版本标准。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。&lt;/p&gt;\n&lt;p&gt;在前文中提到了ES6的新特性——class语法糖的使用。本文来讲讲除了class外ES6～ES12其他的新的特性，如果没有读的可以去看看：&lt;a href=\&#34;https://ricky.shineteens.com/post/u7zwdeg-m/\&#34;&gt;JavaScript｜Class定义类&lt;/a&gt;。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript｜ES6日常用法详解&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;ES6&#34;,&#34;slug&#34;:&#34;fB0pVEAG4&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/fB0pVEAG4/&#34;},{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;2BbnUmwOd&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/2BbnUmwOd/&#34;}],&#34;date&#34;:&#34;2022-08-09 11:16:22&#34;,&#34;dateFormat&#34;:&#34;2022-08-09&#34;,&#34;feature&#34;:&#34;https://nas.shineteens.com:9999/i/2022/08/11/62f4f8200745f.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/J9qM98Nhv/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;16 min read&#34;,&#34;time&#34;:915000,&#34;words&#34;:3488,&#34;minutes&#34;:16},&#34;description&#34;:&#34;ES6全称ECMAScript 6.0 ，是JavaScript 的下一个版本标准。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n在前文中提到了ES6的新特性——class语法糖的使用。本文来...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%97%E9%9D%A2%E9%87%8F%E7%9A%84%E5%A2%9E%E5%BC%BA\&#34;&gt;字面量的增强&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E6%9E%84\&#34;&gt;解构&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84\&#34;&gt;数组解构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84\&#34;&gt;对象解构&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#letconst%E7%9A%84%E4%BD%BF%E7%94%A8\&#34;&gt;let/const的使用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%90%E5%8D%87\&#34;&gt;作用域提升&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%98%E9%87%8F%E4%BF%9D%E5%AD%98\&#34;&gt;变量保存&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F\&#34;&gt;块级作用域&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA\&#34;&gt;暂时性死区&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A8%A1%E7%89%88%E5%AD%97%E7%AC%A6%E4%B8%B2\&#34;&gt;模版字符串&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC\&#34;&gt;函数默认值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0\&#34;&gt;函数剩余参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0\&#34;&gt;箭头函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95\&#34;&gt;展开语法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA\&#34;&gt;数值表示&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#symbol%E4%BD%9C%E4%B8%BA%E5%B1%9E%E6%80%A7%E5%90%8D\&#34;&gt;Symbol作为属性名&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#setmap\&#34;&gt;Set&amp;amp;Map&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#set\&#34;&gt;Set&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#weakset\&#34;&gt;WeakSet&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#map\&#34;&gt;Map&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#weakmap\&#34;&gt;WeakMap&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;认识class和class的构造函数\&#34;&gt;认识class和class的构造函数&lt;/h2&gt;\n&lt;p&gt;在之前我讲原型的文章中，按构造函数创建的类不仅和普通的函数相似，还不容易理解。在ES6中，我们可以使用class来定义类，class的本质其实是构造函数的语法糖而已。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  say() {\n    console.log(`${this.name} is ${this.age} years old.`);\n  }\n}\n\nvar person = new Person(&#39;Tom&#39;, 18);\n\nperson.say(); // Tom is 18 years old.\n\nconsole.log(person); // Person { name: &#39;Tom&#39;, age: 18 }\nconsole.log(person.__proto__); // {}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;在Babel中会被转换成构造函数的代码，如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var Person = /*#__PURE__*/function () {\n  function Person(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  var _proto = Person.prototype;\n\n  _proto.say = function say() {\n    console.log(this.name + &amp;quot; is &amp;quot; + this.age + &amp;quot; years old.&amp;quot;);\n  };\n\n  return Person;\n}();\n\nvar person = new Person(&#39;Tom&#39;, 18);\nperson.say(); // Tom is 18 years old.\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;class方法和方法拦截\&#34;&gt;class方法和方法拦截&lt;/h2&gt;\n&lt;p&gt;class中的方法可以通过静态方法来实现，也可以通过实例方法来实现。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var names = [&amp;quot;abc&amp;quot;, &amp;quot;cba&amp;quot;, &amp;quot;nba&amp;quot;]\n\nclass Person {\n  constructor(name, age) {\n    this.name = name\n    this.age = age\n    this._address = &amp;quot;广州市&amp;quot;\n  }\n\n  // 普通的实例方法\n  // 创建出来的对象进行访问\n  // var p = new Person()\n  // p.eating()\n  eating() {\n    console.log(this.name + &amp;quot; eating~&amp;quot;)\n  }\n\n  running() {\n    console.log(this.name + &amp;quot; running~&amp;quot;)\n  }\n\n  // 类的访问器方法\n  get address() {\n    console.log(&amp;quot;拦截访问操作&amp;quot;)\n    return this._address\n  }\n\n  set address(newAddress) {\n    console.log(&amp;quot;拦截设置操作&amp;quot;)\n    this._address = newAddress\n  }\n\n  // 类的静态方法(类方法)\n  // Person.createPerson()\n  static randomPerson() {\n    var nameIndex = Math.floor(Math.random() * names.length)\n    var name = names[nameIndex]\n    var age = Math.floor(Math.random() * 100)\n    return new Person(name, age)\n  }\n}\n\nvar p = new Person(&amp;quot;Ricky&amp;quot;, 18)\np.eating() // Ricky eating~\np.running() // Ricky running~\n\nconsole.log(p.address) // 拦截访问操作 // 广州市\np.address = &amp;quot;北京市&amp;quot; // 拦截设置操作\nconsole.log(p.address) // 拦截访问操作 // 北京市\n\n// console.log(Object.getOwnPropertyDescriptors(Person.prototype))\n\nfor (var i = 0; i &amp;lt; 50; i++) {\n  console.log(Person.randomPerson()) // Person { name: &#39;cba&#39;, age: 52, _address: &#39;广州市&#39; } ... x100\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;class中的继承\&#34;&gt;class中的继承&lt;/h2&gt;\n&lt;p&gt;在ES6中新增extends关键字，可以方便的帮助我们实现继承。&lt;/p&gt;\n&lt;p&gt;还有super关键字，这个super关键字有不同的使用方式：注意：在子（派生）类的构造函数中使用this或者返回默认对象之前，必须先通过super调用父类的构造函数！super的使用位置有三个：子类的构造函数、实例方法、静态方法。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;class Person {\n  constructor(name, age) {\n    this.name = name\n    this.age = age\n  }\n\n  say() {\n    console.log(this.name + &amp;quot; is &amp;quot; + this.age + &amp;quot; years old.&amp;quot;)\n  }\n}\n\nclass Student extends Person {\n  constructor(name, age, grade) {\n    super(name, age)\n    this.grade = grade\n  }\n  say() {\n    super.say()\n    console.log(&amp;quot;I am a student. My grade is &amp;quot; + this.grade)\n  }\n}\n\nvar s = new Student(&amp;quot;Ricky&amp;quot;, 18, &amp;quot;一年级&amp;quot;)\n\ns.say() // Ricky is 18 years old. I am a student. My grade is 一年级\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;继承内置类型\&#34;&gt;继承内置类型&lt;/h3&gt;\n&lt;p&gt;可以通过继承内置类型来实现继承，如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;\nclass superArray extends Array {\n    lastItem() {\n        return this[this.length - 1]\n    }\n}\n\nvar arr = new superArray(1, 2, 3)\nconsole.log(arr.lastItem()) // 3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;类的混入\&#34;&gt;类的混入&lt;/h3&gt;\n&lt;p&gt;混入是一种特殊的继承，它可以将多个类的特性混入到目标类中。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;class Person {\n\n}\n\nfunction mixinRunner(BaseClass) {\n  class NewClass extends BaseClass {\n    running() {\n      console.log(&amp;quot;running~&amp;quot;)\n    }\n  }\n  return NewClass\n}\n\nfunction mixinEater(BaseClass) {\n  return class extends BaseClass {\n    eating() {\n      console.log(&amp;quot;eating~&amp;quot;)\n    }\n  }\n}\n\n// 在JS中类只能有一个父类: 单继承\nclass Student extends Person {\n\n}\n\nvar NewStudent = mixinEater(mixinRunner(Student))\nvar ns = new NewStudent()\nns.running()\nns.eating()\n\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;U7Zwdeg-m&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;认识class和class的构造函数\&#34;&gt;认识class和class的构造函数&lt;/h2&gt;\n&lt;p&gt;在之前我讲原型的文章中，按构造函数创建的类不仅和普通的函数相似，还不容易理解。在ES6中，我们可以使用class来定义类，class的本质其实是构造函数的语法糖而已。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;class Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  say() {\n    console.log(`${this.name} is ${this.age} years old.`);\n  }\n}\n\nvar person = new Person(&#39;Tom&#39;, 18);\n\nperson.say(); // Tom is 18 years old.\n\nconsole.log(person); // Person { name: &#39;Tom&#39;, age: 18 }\nconsole.log(person.__proto__); // {}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript｜Class定义类&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;2BbnUmwOd&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/2BbnUmwOd/&#34;},{&#34;name&#34;:&#34;面向对象&#34;,&#34;slug&#34;:&#34;vwSjS_4RKc&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/vwSjS_4RKc/&#34;}],&#34;date&#34;:&#34;2022-08-09 09:42:28&#34;,&#34;dateFormat&#34;:&#34;2022-08-09&#34;,&#34;feature&#34;:&#34;https://s1.xptou.com/2022/08/09/62f1cf529141c.png&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/U7Zwdeg-m/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:228000,&#34;words&#34;:785,&#34;minutes&#34;:4},&#34;description&#34;:&#34;认识class和class的构造函数\n在之前我讲原型的文章中，按构造函数创建的类不仅和普通的函数相似，还不容易理解。在ES6中，我们可以使用class来定义类，class的本质其实是构造函数的语法糖而已。\nclass Person {\n  ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%A4%E8%AF%86class%E5%92%8Cclass%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\&#34;&gt;认识class和class的构造函数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#class%E6%96%B9%E6%B3%95%E5%92%8C%E6%96%B9%E6%B3%95%E6%8B%A6%E6%88%AA\&#34;&gt;class方法和方法拦截&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#class%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF\&#34;&gt;class中的继承&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%A7%E6%89%BF%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B\&#34;&gt;继承内置类型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E7%9A%84%E6%B7%B7%E5%85%A5\&#34;&gt;类的混入&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;对象是否有属于自己的属性\&#34;&gt;对象是否有属于自己的属性&lt;/h2&gt;\n&lt;p&gt;通过hasOwnProperty()方法判断对象是否有属于自己的属性，而不是原型的属性。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var obj = {\n    name: &#39;obj&#39;,\n};\n\nvar obj1 = Object.create(obj, {\n    age: {\n        value: 18,\n        enumerable: true,\n        configurable: true,\n        writable: true,\n    },\n});\n\nconsole.log(obj1); // { age: 18 }\nconsole.log(obj1.hasOwnProperty(&#39;age&#39;)); // true\nconsole.log(obj1.hasOwnProperty(&#39;name&#39;)); // false\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;判断属性在对象或者原型链上\&#34;&gt;判断属性在对象或者原型链上&lt;/h2&gt;\n&lt;p&gt;通过in/for in可以判断属性在对象或者原型链上。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;console.log(&#39;age&#39; in obj1); // true\nfor (var i in obj1) {\n    console.log(i); // age name\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;检测构造函数的pototype是否出现在某个实例对象的原型链上\&#34;&gt;检测构造函数的pototype，是否出现在某个实例对象的原型链上&lt;/h2&gt;\n&lt;p&gt;通过instanceof判断构造函数的prototype是否出现在某个实例对象的原型链上，但不能用于实例对象。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function inheritPrototype(SubType, SuperType) {\n  SubType.prototype = Object.create(SuperType.prototype)\n  Object.defineProperty(SubType.prototype, &amp;quot;constructor&amp;quot;, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: SubType\n  })\n}\n\n\nfunction Person() {\n\n}\n\nfunction Student() {\n\n}\n\ninheritPrototype(Student, Person)\n\nvar stu = new Student()\n\nconsole.log(stu instanceof Student) // true\nconsole.log(stu instanceof Person) // true\nconsole.log(stu instanceof Object) // true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;检测某个对象是否出现在某个实例对象的原型链上\&#34;&gt;检测某个对象，是否出现在某个实例对象的原型链上&lt;/h2&gt;\n&lt;p&gt;通过isPrototypeOf判断某个对象，是否出现在某个实例对象的原型链上。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function Person() {\n\n}\n\nvar p = new Person()\n\nconsole.log(p instanceof Person) // true\nconsole.log(Person.prototype.isPrototypeOf(p)) // true\n\n// \nvar obj = {\n  name: &amp;quot;why&amp;quot;,\n  age: 18\n}\n\nvar info = Object.create(obj)\n\nconsole.log(info instanceof obj) // trows a TypeError\nconsole.log(obj.isPrototypeOf(info)) // true\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;3kIqfwJzc&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;对象是否有属于自己的属性\&#34;&gt;对象是否有属于自己的属性&lt;/h2&gt;\n&lt;p&gt;通过hasOwnProperty()方法判断对象是否有属于自己的属性，而不是原型的属性。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var obj = {\n    name: &#39;obj&#39;,\n};\n\nvar obj1 = Object.create(obj, {\n    age: {\n        value: 18,\n        enumerable: true,\n        configurable: true,\n        writable: true,\n    },\n});\n\nconsole.log(obj1); // { age: 18 }\nconsole.log(obj1.hasOwnProperty(&#39;age&#39;)); // true\nconsole.log(obj1.hasOwnProperty(&#39;name&#39;)); // false\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript｜原型判断&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;原型链&#34;,&#34;slug&#34;:&#34;IfGFShXd9&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/IfGFShXd9/&#34;},{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;2BbnUmwOd&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/2BbnUmwOd/&#34;}],&#34;date&#34;:&#34;2022-08-04 15:09:37&#34;,&#34;dateFormat&#34;:&#34;2022-08-04&#34;,&#34;feature&#34;:&#34;https://i0.hdslb.com/bfs/album/cb48a5a73cb3362c28a219771bb85a4ba29ff341.png&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/3kIqfwJzc/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:93000,&#34;words&#34;:329,&#34;minutes&#34;:2},&#34;description&#34;:&#34;对象是否有属于自己的属性\n通过hasOwnProperty()方法判断对象是否有属于自己的属性，而不是原型的属性。\nvar obj = {\n    name: &#39;obj&#39;,\n};\n\nvar obj1 = Object.create(obj,...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%9C%89%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B1%9E%E6%80%A7\&#34;&gt;对象是否有属于自己的属性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A4%E6%96%AD%E5%B1%9E%E6%80%A7%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A\&#34;&gt;判断属性在对象或者原型链上&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A3%80%E6%B5%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84pototype%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A\&#34;&gt;检测构造函数的pototype，是否出现在某个实例对象的原型链上&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A\&#34;&gt;检测某个对象，是否出现在某个实例对象的原型链上&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;javascript中的面向对象\&#34;&gt;JavaScript中的面向对象&lt;/h2&gt;\n&lt;p&gt;首先看下面的代码：我们应该怎么称呼这个Person？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function Person() {\n\n}\n\nvar p1 = new Person();\nvar p2 = new Person();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;在JavaScript中，Person是一个函数，它的prototype属性指向一个对象，这个对象的属性包含了Person的所有属性和方法。&lt;/p&gt;\n&lt;p&gt;在其他语言的编程范式来看，Person是一个类，这个对象的属性包含了Person的所有属性和方法。&lt;/p&gt;\n&lt;h2 id=\&#34;面向对象的特点\&#34;&gt;面向对象的特点&lt;/h2&gt;\n&lt;p&gt;面向对象有三大特性：封装、继承、多态。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;封装：将对象的属性和方法封装在一个对象中，这样就可以避免对象之间的耦合。&lt;/li&gt;\n&lt;li&gt;继承：将一个对象的属性和方法复制到另一个对象中，这样就可以让子类继承父类的属性和方法。&lt;/li&gt;\n&lt;li&gt;多态：不同的对象有不同的表现，这样就可以让对象的表现不依赖于它的类型。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;继承的好处：能够将重复的代码抽离到父类中，子类可以直接继承父类，不需要重复定义。&lt;/p&gt;\n&lt;h2 id=\&#34;javascript原型链\&#34;&gt;JavaScript原型链&lt;/h2&gt;\n&lt;p&gt;从对象上获取属性，如果对象中没有该属性和方法，则从对象的原型链上获取。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var obj = {\n    name: &#39;obj&#39;,\n};\n\nobj.__proto__.getName = function() {\n    return &#39;Name is obj&#39;;\n}\n\nconsole.log(obj.getName());  // Name is obj\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62ea26a22203e.jpg\&#34; alt=\&#34;62ea26a22203e\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;原型链的尽头是Object.prototype，Object.prototype的原型是null。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// 普通object\nvar obj = {\n    name: &#39;obj&#39;,\n};\n\nconsole.log(obj.__proto__); // [Object: null prototype] {}\nconsole.log(obj.__proto__.__proto__.__proto__);  // null\n// 字符串\nvar ss = &#39;ss&#39;\n\nconsole.log(ss.__proto__); // [String: null prototype] {}\n\nconsole.log(ss.__proto__.__proto__) ; // [Object: null prototype] {}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;[Object: null prototype] {} 的特殊性，该对象有原型属性，但是它的原型属性已经指向的是null，也就是已经是顶层原型了，而该对象上有很多默认的属性和方法。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62ea289cd1f27.jpg\&#34; alt=\&#34;62ea289cd1f27\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;利用javascript实现继承\&#34;&gt;利用JavaScript实现继承&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62ea3de23df06.jpg\&#34; alt=\&#34;62ea3de23df06\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;javascript原型链继承法\&#34;&gt;JavaScript原型链继承法&lt;/h3&gt;\n&lt;p&gt;利用上述提到的原型链的原理，可以实现继承。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// 父类: 公共属性和方法\nfunction Person() {\n  this.name = &amp;quot;Ricky&amp;quot;\n  this.friends = []\n}\n\nPerson.prototype.eating = function() {\n  console.log(this.name + &amp;quot; eating~&amp;quot;)\n}\n\n// 子类: 特有属性和方法\nfunction Student() {\n  this.sno = 111\n}\n\nvar p = new Person()\nStudent.prototype = p\n\nStudent.prototype.studying = function() {\n  console.log(this.name + &amp;quot; studying~&amp;quot;)\n}\n\n\n// name/sno\nvar stu = new Student()\n\nconsole.log(stu.name) // Ricky\nstu.eating() // Ricky eating~\n\nstu.studying() // Ricky studying~\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;通过原型链实现继承会有一些问题：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;我们通过直接打印对象是看不到这个属性的；&lt;/li&gt;\n&lt;li&gt;这个属性会被多个对象共享，如果这个对象是一个引用类型，那么就会造成问题；&lt;/li&gt;\n&lt;li&gt;不能给Person传递参数，因为这个对象是一次性创建的（没办法定制化）；&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// 原型链实现继承的弊端:\n// 1.第一个弊端: 打印stu对象, 继承的属性是看不到的\nconsole.log(stu) // [Object: Student prototype] {}\n\n// 2.第二个弊端: 创建出来两个stu的对象\nvar stu1 = new Student()\nvar stu2 = new Student()\n\n// 直接修改对象上的属性, 是给本对象添加了一个新属性\nstu1.name = &amp;quot;kobe&amp;quot;\nconsole.log(stu2.name) // Ricky\n\n// 获取引用, 修改引用中的值, 会相互影响\nstu1.friends.push(&amp;quot;kobe&amp;quot;)\n\nconsole.log(stu1.friends) // [kobe]\nconsole.log(stu2.friends) // [kobe]\n\n// 3.第三个弊端: 在前面实现类的过程中都没有传递参数\nvar stu3 = new Student(&amp;quot;lilei&amp;quot;, 112)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;借用构造函数实现继承\&#34;&gt;借用构造函数实现继承&lt;/h3&gt;\n&lt;p&gt;为了解决原型链继承中存在的问题，开发人员提供了一种新的技术: constructor stealing(有很多名称: 借用构造函 数或者称之为经典继承或者称之为伪造对象)&lt;/p&gt;\n&lt;p&gt;方式：在子类型构造函数的内部调用父类型构造函数，例如call, apply, bind等方法。&lt;/p&gt;\n&lt;p&gt;强调: 借用构造函数也是有弊端:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;第一个弊端: Person函数至少被调用了两次&lt;/li&gt;\n&lt;li&gt;第二个弊端: stu的原型对象上会多出一些属性, 但是这些属性是没有存在的必要&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// 父类: 公共属性和方法\nfunction Person(name, age, friends) {\n  // this = stu\n  this.name = name\n  this.age = age\n  this.friends = friends\n}\n\nPerson.prototype.eating = function() {\n  console.log(this.name + &amp;quot; eating~&amp;quot;)\n}\n\n// 子类: 特有属性和方法\nfunction Student(name, age, friends, sno) {\n  Person.call(this, name, age, friends)\n  // this.name = name\n  // this.age = age\n  // this.friends = friends\n  this.sno = 111\n}\n\nvar p = new Person()\nStudent.prototype = p\n\nStudent.prototype.studying = function() {\n  console.log(this.name + &amp;quot; studying~&amp;quot;)\n}\n\n\n// name/sno\nvar stu = new Student(&amp;quot;jame&amp;quot;, 18, [&amp;quot;kobe&amp;quot;], 111)\n\nconsole.log(stu.name)\nstu.eating()\n\nstu.studying()\n\n\n// 原型链实现继承已经解决的弊端\n// 1.第一个弊端: 打印stu对象, 继承的属性是看不到的\nconsole.log(stu)\n\n// 2.第二个弊端: 创建出来两个stu的对象\nvar stu1 = new Student(&amp;quot;jame&amp;quot;, 18, [&amp;quot;lilei&amp;quot;], 111)\nvar stu2 = new Student(&amp;quot;kobe&amp;quot;, 30, [&amp;quot;jame&amp;quot;], 112)\n\n// 但如果直接修改对象上的属性, 是给本对象添加了一个新属性\nstu1.name = &amp;quot;kite&amp;quot;\nconsole.log(stu2.name) // kobe\n\n// 获取引用, 修改引用中的值, 会相互影响\nstu1.friends.push(&amp;quot;lucy&amp;quot;)\n\nconsole.log(stu1.friends)\nconsole.log(stu2.friends)\n\n// // 3.第三个弊端: 在前面实现类的过程中都没有传递参数\n// var stu3 = new Student(&amp;quot;lilei&amp;quot;, 112)\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;原型类继承\&#34;&gt;原型类继承&lt;/h3&gt;\n&lt;p&gt;这种继承方法不是通过构造函数来实现的，也能实现重复利用另一个对象的属性方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var copy = {\n  name: &amp;quot;kobe&amp;quot;,\n  age: 18,\n  friends: [&amp;quot;lilei&amp;quot;, &amp;quot;jame&amp;quot;]\n}\n\n// Object.setPrototypeOf()方法\nfunction createObject1(obj) {\n  var newObj = {}\n  Object.setPrototypeOf(newObj, obj)\n  return newObj\n}\nvar stu1 = createObject1(copy)\nconsole.log(stu1.__proto__ === copy) // true\n\n// 函数原型赋值方法\nfunction createObject2(obj) {\n  funnction F() {}\n  F.prototype = obj\n  return new F()\n}\nvar stu2 = createObject2(copy)\nconsole.log(stu2.__proto__ === copy) // true\n\n// ECMAScript5中的Object.create()方法\nvar stu3 = Object.create(copy)\nconsole.log(stu3.__proto__ === copy) // true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;寄生式继承\&#34;&gt;寄生式继承&lt;/h3&gt;\n&lt;p&gt;寄生式继承的思路是结合原型类继承和工厂模式的一种方式：即创建一个封装继承过程的函数, 该函数在内部以某种方式来增强对象，最后再将这个对象返回。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var personObj = {\n  running: function() {\n    console.log(&amp;quot;running&amp;quot;)\n  }\n}\n\nfunction createStudent(name) {\n  var stu = Object.create(personObj)\n  stu.name = name\n  stu.studying = function() {\n    console.log(&amp;quot;studying~&amp;quot;)\n  }\n  return stu\n}\n\nvar stuObj1 = createStudent(&amp;quot;kobe&amp;quot;)\nvar stuObj2 = createStudent(&amp;quot;james&amp;quot;)\n\nconsole.log(stuObj1.name) // kobe\nstuObj1.running() // running\nstuObj1.studying() // studying~\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;寄生组合式继承\&#34;&gt;寄生组合式继承&lt;/h3&gt;\n&lt;p&gt;寄生式继承解决了原型属性继承的问题，但constructor指向的是父类的构造函数，而不是子类的构造函数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function Person(name, age, friends) {\n  this.name = name\n  this.age = age\n  this.friends = friends\n}\n\nPerson.prototype.running = function() {\n  console.log(&amp;quot;running~&amp;quot;)\n}\n\nPerson.prototype.eating = function() {\n  console.log(&amp;quot;eating~&amp;quot;)\n}\n\n\nfunction Student(name, age, friends, sno, score) {\n  Person.call(this, name, age, friends)\n  this.sno = sno\n  this.score = score\n}\n\nStudent.prototype.studying = function() {\n  console.log(&amp;quot;studying~&amp;quot;)\n}\n\nStudent.prototype = Object.create(Person.prototype);\n\nvar stu = new Student(&amp;quot;Ricky&amp;quot;, 18, [&amp;quot;kobe&amp;quot;], 111, 100)\nconsole.log(stu) //  Person {name: &amp;quot;Ricky&amp;quot;, age: 18, friends: Array(1), sno: 111, score: 100}\nstu.studying() // studying~\nstu.running() // running~\nstu.eating() // eating~\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们可以利用Object.defineProperty()方法来将constructor指向子类的构造函数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;Object.defineProperty(Student.prototype, &amp;quot;constructor&amp;quot;, {\n  enumerable: false,\n  value: Student,\n  writable: true,\n  configuable: true\n})\n\nconsole.log(stu) //  Student {name: &amp;quot;Ricky&amp;quot;, age: 18, friends: Array(1), sno: 111, score: 100}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;实现大量这种组合继承，可以通过实现一个工厂函数来实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function inheritPrototype(SubType, SuperType) {\n  SubType.prototype = Object.create(SuperType.prototype)\n  Object.defineProperty(SubType.prototype, &amp;quot;constructor&amp;quot;, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: SubType\n  })\n}\n\ninheritPrototype(Student, Person)\n\nconsole.log(stu.constructor.name) // Student\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;BvjHWHJ0N&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;javascript中的面向对象\&#34;&gt;JavaScript中的面向对象&lt;/h2&gt;\n&lt;p&gt;首先看下面的代码：我们应该怎么称呼这个Person？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function Person() {\n\n}\n\nvar p1 = new Person();\nvar p2 = new Person();\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript | 原型链与继承&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;原型链&#34;,&#34;slug&#34;:&#34;IfGFShXd9&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/IfGFShXd9/&#34;},{&#34;name&#34;:&#34;继承&#34;,&#34;slug&#34;:&#34;kkvRzPQMaP&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/kkvRzPQMaP/&#34;},{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;2BbnUmwOd&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/2BbnUmwOd/&#34;}],&#34;date&#34;:&#34;2022-08-03 14:59:17&#34;,&#34;dateFormat&#34;:&#34;2022-08-03&#34;,&#34;feature&#34;:&#34;https://www.hualigs.cn/image/62ea432fb4832.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/BvjHWHJ0N/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:true,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:469000,&#34;words&#34;:1768,&#34;minutes&#34;:8},&#34;description&#34;:&#34;JavaScript中的面向对象\n首先看下面的代码：我们应该怎么称呼这个Person？\nfunction Person() {\n\n}\n\nvar p1 = new Person();\nvar p2 = new Person();\n\n\n在Jav...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#javascript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\&#34;&gt;JavaScript中的面向对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E7%82%B9\&#34;&gt;面向对象的特点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#javascript%E5%8E%9F%E5%9E%8B%E9%93%BE\&#34;&gt;JavaScript原型链&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A9%E7%94%A8javascript%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF\&#34;&gt;利用JavaScript实现继承&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#javascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%E6%B3%95\&#34;&gt;JavaScript原型链继承法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF\&#34;&gt;借用构造函数实现继承&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E5%9E%8B%E7%B1%BB%E7%BB%A7%E6%89%BF\&#34;&gt;原型类继承&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF\&#34;&gt;寄生式继承&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF\&#34;&gt;寄生组合式继承&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;认识对象的原型\&#34;&gt;认识对象的原型&lt;/h2&gt;\n&lt;p&gt;JavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。&lt;/p&gt;\n&lt;p&gt;那么这个对象有什么用呢？&lt;br&gt;\n当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作；&lt;br&gt;\n这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它；&lt;br&gt;\n如果对象中没有该属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性；&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;获取对象的原型\&#34;&gt;获取对象的原型&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;obj = {\n    name: &#39;John&#39;,\n    age: 30,\n}\n\nconsole.log(obj.__proto__); // [Object: null prototype] {}\nconsole.log(Object.getPrototypeOf(obj)); // [Object: null prototype] {}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;原型作用\&#34;&gt;原型作用&lt;/h2&gt;\n&lt;p&gt;当我们从一个对象中获取某一个属性时, 它会触发 [[get]] 操作&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;在当前对象中去查找对应的属性, 如果找到就直接使用&lt;/li&gt;\n&lt;li&gt;如果没有找到, 那么会沿着它的原型去查找 [[prototype]]&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;函数的原型-prototype\&#34;&gt;函数的原型 prototype&lt;/h2&gt;\n&lt;p&gt;所有的函数都有一个prototype的属性:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function Person() {\n    this.name = &#39;John&#39;;\n    this.age = 30;\n}\n\nconsole.log(Person.prototype); // [Object: null prototype] {}\n// 因为它是一个函数，才有了这个特殊的属性，而不是因为它是一个对象\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;new-操作符\&#34;&gt;new 操作符&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;在内存中创建一个新对象&lt;/li&gt;\n&lt;li&gt;将新对象的原型指向构造函数的prototype属性&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function Person() {\n\n}\n\nvar p1 = new Person()\nvar p2 = new Person()\n\nconsole.log(p1.__proto__ === p2.__proto__); // true\nconsole.log(p1.__proto__ === Person.prototype); // true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62e7cb8bd9d5e.jpg\&#34; alt=\&#34;62e7cb8bd9d5e\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;constructor-属性\&#34;&gt;constructor 属性&lt;/h2&gt;\n&lt;p&gt;事实上原型对象上面是有一个属性的：constructor，默认情况下原型上都会添加一个属性叫做constructor，这个constructor指向当前的函数对象；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function Person() {\n\n}\n\np1 = new Person();\n\nconsole.log(Person.prototype); // [Object: null prototype] {}\nconsole.log(p1.__proto__.constructor); // [Function: Person]\nconsole.log(p1.__proto__.constructor.name); // Person\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;利用getOwnPropertyDescriptors方法可以获取到所有的属性和属性描述符&lt;br&gt;\n通过这种方法我们可以发现constructor属性是一个属性描述符，它有一个value属性，指向当前的函数对象&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;console.log(Object.getOwnPropertyDescriptors(foo.prototype)) // {constructor: {value: [Function: Person], writable: true, enumerable: false, configurable: true}}\n\nObject.defineProperty(foo.prototype, &amp;quot;constructor&amp;quot;, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value: &amp;quot;哈哈哈哈&amp;quot;\n})\nconsole.log(foo.prototype) // {constructor: &amp;quot;哈哈哈哈&amp;quot;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;原型对象的constructor\&#34;&gt;原型对象的constructor&lt;/h3&gt;\n&lt;p&gt;如果我们需要在原型上添加多种属性，那么可以重新定义整个原型对象，这样就可以添加多个属性了；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function Person() {\n\n}\n\nPerson.prototype = {\n    name: &#39;John&#39;,\n    age: 30,\n    sayHello: function() {\n        console.log(&#39;Hello&#39;);\n    }\n};\n\nvar p1 = new Person();\n\nconsole.log(p1.name, p1.age); // John 30\np1.sayHello(); // Hello\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;每创建一个函数, 就会同时创建它的prototype对象, 这个对象也会自动获取constructor属性；而我们这里相当于给prototype重新赋值了一个对象, 那么这个新对象的constructor属性, 会指向Object构造函数, 而不是Person构造函数了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;console.log(f1.constructor) // [Function: Object]\n\n// 真实开发中我们可以通过Object.defineProperty方式添加constructor\nObject.defineProperty(Person.prototype, &amp;quot;constructor&amp;quot;, {\n  enumerable: false,\n  configurable: true,\n  writable: true,\n  value: Person\n})\n\nconsole.log(f1.constructor) ; // [Function: Person]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;利用原型和构造函数创建对象\&#34;&gt;利用原型和构造函数创建对象&lt;/h2&gt;\n&lt;p&gt;上一篇中我讲到通过构造函数创建对象时，会创造出重复的函数，这里我们可以通过原型对象来创建对象，这样就不会创造出重复的函数了；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nPerson.prototype.sayHello = function() {\n    console.log(this.name + &#39;Hello&#39;);\n}\n\nPerson.prototype.sayGoodbye = function() {\n    console.log(this.name + &#39;Goodbye&#39;);\n}\n\nvar p1 = new Person(&#39;John&#39;, 30);\nvar p2 = new Person(&#39;Mary&#39;, 25);\n\np1.sayHello(); // JohnHello\np2.sayGoodbye(); //MaryGoodbye\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;CkpK7rqXL&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;认识对象的原型\&#34;&gt;认识对象的原型&lt;/h2&gt;\n&lt;p&gt;JavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。&lt;/p&gt;\n&lt;p&gt;那么这个对象有什么用呢？&lt;br&gt;\n当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]]的操作；&lt;br&gt;\n这个操作会首先检查该属性是否有对应的属性，如果有的话就使用它；&lt;br&gt;\n如果对象中没有该属性，那么会访问对象[[prototype]]内置属性指向的对象上的属性；&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript｜对象原型的理解&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;JavaScript&#34;,&#34;slug&#34;:&#34;2BbnUmwOd&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/2BbnUmwOd/&#34;},{&#34;name&#34;:&#34;对象&#34;,&#34;slug&#34;:&#34;_7zozl9nc-&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/_7zozl9nc-/&#34;},{&#34;name&#34;:&#34;原型&#34;,&#34;slug&#34;:&#34;RMmiODQeM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/RMmiODQeM/&#34;}],&#34;date&#34;:&#34;2022-08-01 19:49:06&#34;,&#34;dateFormat&#34;:&#34;2022-08-01&#34;,&#34;feature&#34;:&#34;https://www.hualigs.cn/image/62ea42bcefea4.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/CkpK7rqXL/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:215000,&#34;words&#34;:856,&#34;minutes&#34;:4},&#34;description&#34;:&#34;认识对象的原型\nJavaScript当中每个对象都有一个特殊的内置属性 [[prototype]]，这个特殊的对象可以指向另外一个对象。\n那么这个对象有什么用呢？\n当我们通过引用对象的属性key来获取一个value时，它会触发 [[Get]...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%A4%E8%AF%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B\&#34;&gt;认识对象的原型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B\&#34;&gt;获取对象的原型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E5%9E%8B%E4%BD%9C%E7%94%A8\&#34;&gt;原型作用&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B-prototype\&#34;&gt;函数的原型 prototype&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#new-%E6%93%8D%E4%BD%9C%E7%AC%A6\&#34;&gt;new 操作符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#constructor-%E5%B1%9E%E6%80%A7\&#34;&gt;constructor 属性&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84constructor\&#34;&gt;原型对象的constructor&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A9%E7%94%A8%E5%8E%9F%E5%9E%8B%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1\&#34;&gt;利用原型和构造函数创建对象&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;面向对象概念\&#34;&gt;面向对象概念&lt;/h2&gt;\n&lt;p&gt;对象是JavaScript中一个非常重要的概念，这是因为对象可以将多个相关联的数据封装到一起，更好的描述一个事物：&lt;br&gt;\n比如我们可以描述一辆车：Car，具有颜色（color）、速度（speed）、品牌（brand）、价格（price），行驶（travel）等等；&lt;br&gt;\n比如我们可以描述一个人：Person，具有姓名（name）、年龄（age）、身高（height），吃东西（eat）、跑步（run）等等；&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62dfa9c9e7a25.jpg\&#34; alt=\&#34;62dfa9c9e7a25\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;用对象来描述事物，更有利于我们将现实的事物，抽离成代码中某个数据结构：所以有一些编程语言就是纯面向对象的编程语言，比Java；你在实现任何现实抽象时都需要先创建一个类，根据类再去创建对象；&lt;/p&gt;\n&lt;h2 id=\&#34;javascript的面向对象\&#34;&gt;JavaScript的面向对象&lt;/h2&gt;\n&lt;p&gt;JavaScript其实支持多种编程范式的，包括函数式编程和面向对象编程：&lt;/p&gt;\n&lt;p&gt;JavaScript中的对象被设计成一组属性的无序集合，像是一个哈希表，有key和value组成； key是一个标识符名称，value可以是任意类型，也可以是其他对象或者函数类型； 如果值是一个函数，那么我们可以称之为是对象的方法；&lt;/p&gt;\n&lt;h2 id=\&#34;创建js对象的方法\&#34;&gt;创建JS对象的方法&lt;/h2&gt;\n&lt;h3 id=\&#34;单个对象创建的方法\&#34;&gt;单个对象创建的方法&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// 方法一：\nvar obj = {\n    name: &#39;foo&#39;,\n    age: 18,\n};\n\n// 方法二：\nvar obj = new Object();\nobj.name = &#39;foo&#39;;\nobj.age = 18;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;多个对象创建的方法\&#34;&gt;多个对象创建的方法&lt;/h3&gt;\n&lt;h4 id=\&#34;工厂模式\&#34;&gt;工厂模式&lt;/h4&gt;\n&lt;p&gt;可以通过上述方式创建，但如果需要创建相同属性的多个对象，可以使用工厂模式；&lt;br&gt;\n工厂模式其实是一种常见的设计模式，通常我们会有一个工厂方法，通过该工厂方法我们可以产生想要的对象；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// 工厂模式：\nfunction createPerson(name, age) {\n    var obj = new Object();\n    obj.name = name;\n    obj.age = age;\n    return obj;\n}\n\nvar person1 = createPerson(&#39;foo&#39;, 18);\nvar person2 = createPerson(&#39;bar&#39;, 20);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;构造函数\&#34;&gt;构造函数&lt;/h4&gt;\n&lt;p&gt;构造函数也称之为构造器（constructor），通常是我们在创建对象时会调用的函数；在其他面向的编程语言里面，构造函数是存在于类中的一个方法，称之为构造方法；但是JavaScript中的构造函数有点不太一样；&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function foo() {\n  console.log(&amp;quot;foo~, 函数体代码&amp;quot;)\n}\n\n// foo就是一个普通的函数\nfoo() // foo~, 函数体代码\n\n// 换一种方式来调用foo函数: 通过new关键字去调用一个函数, 那么这个函数就是一个构造函数了\nvar f1 = new foo // foo~, 函数体代码\nconsole.log(f1) // [Function: foo]\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果一个函数被使用new操作符调用了，那么它会执行如下操作：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;在内存中创建一个新的对象（空对象）；&lt;/li&gt;\n&lt;li&gt;这个对象内部的[[prototype]]属性会被赋值为该构造函数的prototype属性；；&lt;/li&gt;\n&lt;li&gt;构造函数内部的this，会指向创建出来的新对象；&lt;/li&gt;\n&lt;li&gt;执行函数的内部代码（函数体代码）；&lt;/li&gt;\n&lt;li&gt;如果构造函数没有返回非空对象，则返回创建出来的新对象；&lt;/li&gt;\n&lt;/ol&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// 规范: 构造函数的首字母一般是大写\nfunction Person(name, age, height, address) {\n  this.name = name\n  this.age = age\n  this.height = height\n  this.address = address\n\n  this.eating = function() {\n    console.log(this.name + &amp;quot;在吃东西~&amp;quot;)\n  }\n\n  this.running = function() {\n    console.log(this.name + &amp;quot;在跑步&amp;quot;)\n  }\n}\n\n\nvar p1 = new Person(&amp;quot;张三&amp;quot;, 18, 1.88, &amp;quot;广州市&amp;quot;) // 创建一个新的对象\nvar p2 = new Person(&amp;quot;李四&amp;quot;, 20, 1.98, &amp;quot;北京市&amp;quot;)\n\nconsole.log(p1) // Person {name: &amp;quot;张三&amp;quot;, age: 18, height: 1.88, address: &amp;quot;广州市&amp;quot;}\nconsole.log(p2)\np1.eating() // 张三在吃东西~\np2.eating()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;操作js对象的方法\&#34;&gt;操作JS对象的方法&lt;/h2&gt;\n&lt;p&gt;普通的属性操作方式：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;// 设置属性：\nobj.name = &#39;bar&#39;;\n// 获取属性：\nconsole.log(obj.name);\n// 删除属性：\ndelete obj.name;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;数据属性描述符\&#34;&gt;数据属性描述符&lt;/h3&gt;\n&lt;p&gt;属性操作的控制：通过属性描述符可以精准的添加或修改对象的属性，属性描述符需要使用 Object.defineProperty 来对属性进行添加或者修改：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;Object.defineProperty(obj, &#39;name&#39;, {\n    value: &#39;bar&#39;,\n    writable: true, // 可写\n    enumerable: true, // 可枚举, 可以通过for in循环获取到, 如果设置为false, 则不能通过for in循环获取到, 也不能console.log(obj)获取到\n    configurable: true , // 可配置，可以删除属性\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;构造函数缺点：每次创建一个新的对象，都需要&lt;strong&gt;重新创建一个函数对象实例&lt;/strong&gt;，会占用大量的内存；&lt;/p&gt;\n&lt;h3 id=\&#34;存取属性描述符\&#34;&gt;存取属性描述符&lt;/h3&gt;\n&lt;p&gt;存取属性描述符：1.隐藏某一个私有属性被希望直接被外界使用和赋值 2.如果我们希望截获某一个属性它访问和设置值的过程时, 也会使用存储属性描述符&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;obj = {\n    _name: &#39;foo&#39;,\n}\n\nfunction foo(value){\n    console.log(&#39;get value&#39;, value);\n}\n\nfunction bar(value){\n    console.log(&#39;set value&#39;, value);\n}\n\nObject.defineProperty(obj, &#39;name&#39;, {\n    enumerable: true,\n    configurable: true,\n    // value: &#39;foo&#39;,  //使用存取属性描述符的话，只能使用getter和setter来控制属性的访问和赋值\n    // writable: true, // 同上\n    get: function() {\n        foo(this._name);\n        return this._name;\n    },\n    set: function(value) {\n        bar(value);\n        this._name = value;\n    }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;同时定义多个属性描述符\&#34;&gt;同时定义多个属性描述符&lt;/h3&gt;\n&lt;p&gt;Object.defineProperties() 方法直接在一个对象上定义多个新的属性或修改现有属性，并且返回该对象。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;Object.defineProperties(obj, {\n    name: {\n        value: &#39;foo&#39;,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    },\n    age: {\n        value: 18,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    }\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;获取某一个属性的属性描述符\&#34;&gt;获取某一个属性的属性描述符&lt;/h3&gt;\n&lt;p&gt;获取对象的属性描述符：getOwnPropertyDescriptor, getOwnPropertyDescriptors&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;var obj = {\n  // 私有属性(js里面是没有严格意义的私有属性)\n  _age: 18,\n  _eating: function() {}\n}\n\nObject.defineProperties(obj, {\n  name: {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: &amp;quot;foo&amp;quot;\n  },\n  age: {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      return this._age\n    },\n    set: function(value) {\n      this._age = value\n    }\n  }\n})\n\n// 获取某一个特性属性的属性描述符\nconsole.log(Object.getOwnPropertyDescriptor(obj, &amp;quot;name&amp;quot;))\nconsole.log(Object.getOwnPropertyDescriptor(obj, &amp;quot;age&amp;quot;))\n\n// 获取对象的所有属性描述符\nconsole.log(Object.getOwnPropertyDescriptors(obj))\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;object的方法对对象限制\&#34;&gt;Object的方法对对象限制&lt;/h3&gt;\n&lt;p&gt;禁止对象扩展新属性：preventExtensions&lt;br&gt;\n给一个对象添加新的属性会失败（在严格模式下会报错）；&lt;/p&gt;\n&lt;p&gt;密封对象，不允许配置和删除属性：seal&lt;br&gt;\n实际是调用preventExtensions p并且将现有属性的configurable:false&lt;/p&gt;\n&lt;p&gt;冻结对象，不允许修改现有属性： freeze&lt;br&gt;\n实际上是调用seal p并且将现有属性的writable: false&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;    Object.freeze() // 冻结对象，不能再修改属性值，不能再删除属性，不能再添加属性，不能再修改属性的可枚举性，不能再修改属性的可配置性，不能再修改属性的可写性\n    Object.seal() // 将对象封闭，不能再修改属性值，不能再删除属性，不能再添加属性，可以修改属性的可枚举性，可以修改属性的可配置性，可以修改属性的可写性\n    Object.preventExtensions() // 阻止对象增加新的属性，不能再修改属性值，不能再删除属性，可以修改属性的可枚举性，可以修改属性的可配置性，可以修改属性的可写性\n    Object.isFrozen() // 判断对象是否被冻结\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;jvcyCW48G&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;面向对象概念\&#34;&gt;面向对象概念&lt;/h2&gt;\n&lt;p&gt;对象是JavaScript中一个非常重要的概念，这是因为对象可以将多个相关联的数据封装到一起，更好的描述一个事物：&lt;br&gt;\n比如我们可以描述一辆车：Car，具有颜色（color）、速度（speed）、品牌（brand）、价格（price），行驶（travel）等等；&lt;br&gt;\n比如我们可以描述一个人：Person，具有姓名（name）、年龄（age）、身高（height），吃东西（eat）、跑步（run）等等；&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;JavaScript｜对象创建与属性控制&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;JS&#34;,&#34;slug&#34;:&#34;CD1IewxwF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/CD1IewxwF/&#34;},{&#34;name&#34;:&#34;面向对象&#34;,&#34;slug&#34;:&#34;vwSjS_4RKc&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/vwSjS_4RKc/&#34;}],&#34;date&#34;:&#34;2022-07-26 16:39:12&#34;,&#34;dateFormat&#34;:&#34;2022-07-26&#34;,&#34;feature&#34;:&#34;https://www.hualigs.cn/image/62e7726cdd566.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/jvcyCW48G/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:409000,&#34;words&#34;:1738,&#34;minutes&#34;:7},&#34;description&#34;:&#34;面向对象概念\n对象是JavaScript中一个非常重要的概念，这是因为对象可以将多个相关联的数据封装到一起，更好的描述一个事物：\n比如我们可以描述一辆车：Car，具有颜色（color）、速度（speed）、品牌（brand）、价格（pric...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5\&#34;&gt;面向对象概念&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#javascript%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\&#34;&gt;JavaScript的面向对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BAjs%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95\&#34;&gt;创建JS对象的方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%95%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E6%B3%95\&#34;&gt;单个对象创建的方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E6%B3%95\&#34;&gt;多个对象创建的方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\&#34;&gt;工厂模式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\&#34;&gt;构造函数&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%93%8D%E4%BD%9Cjs%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95\&#34;&gt;操作JS对象的方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6\&#34;&gt;数据属性描述符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%98%E5%8F%96%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6\&#34;&gt;存取属性描述符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%8C%E6%97%B6%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6\&#34;&gt;同时定义多个属性描述符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6\&#34;&gt;获取某一个属性的属性描述符&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#object%E7%9A%84%E6%96%B9%E6%B3%95%E5%AF%B9%E5%AF%B9%E8%B1%A1%E9%99%90%E5%88%B6\&#34;&gt;Object的方法对对象限制&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;上一篇写了如何用群晖原生的VPN Server搭建OpenVPN回家，这一篇讲讲客户端怎么配置才能连接OpenVPN，并且通过配置能够使用OpenVPN转发某个网段，屏蔽某些ip和网段。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;&lt;a href=\&#34;https://openvpn.net/vpn-client/\&#34;&gt;OpenVPN Connect Client | Our Official VPN Client | OpenVPN&lt;/a&gt;&lt;br&gt;\n首先从官网下载OpenVPN的客户端，并安装。&lt;/p&gt;\n&lt;p&gt;安装好后我们直接用地址和用户名密码连接是连接不成功的，所以我们需要从群晖上把OpenVPN的配置文件下载下来，并且配置好。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de4c8d53af4.jpg\&#34; alt=\&#34;62de4c8d53af4\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;导出配置文件后我们直接点击即可添加到客户端，但其实这个配置文件并没有配置好地址，如果我们直接导入是修改不了地址的，所以需要在配置文件上修改地址。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de4ec3a3c27.jpg\&#34; alt=\&#34;62de4ec3a3c27\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;修改好地址后，直接导入配置文件，输入用户名和密码即可连接。连接好后，进入你设置的vpn动态ip地址+5000端口号，即可进入群晖页面，同时可以访问其他的端口号进入其他服务，不需要在路由器设置虚拟服务器来转发端口了，什么ssh、ftp、http等等开起来。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de4f82b622a.jpg\&#34; alt=\&#34;62de4f82b622a\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;教程到此结束了！才怪呢，如果我们辛辛苦苦配置的OpenVPN只是转发群晖的端口那就没啥意思了，我们可以通过转发服务器的LAN来使我们直接访问家里的局域网地址，这样就可以访问家里的所有服务了。比如说挂个树莓派啥的，就不用一层层转发了，非常方便。&lt;/p&gt;\n&lt;p&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de50e6a46b5.jpg\&#34; alt=\&#34;62de50e6a46b5\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n首先我们需要在VPN面板那边打上这个小勾勾，然后再点击应用，这样服务器就可以支持转发LAN了。&lt;/p&gt;\n&lt;p&gt;然后，在配置文件补充要转发的网段，比如说我们的网段是192.168.0.0，子网掩码是255.255.255.0，可以这样设置：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;route 192.168.0.0 255.255.255.0 vpn_gateway\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;某些地址我们并不想转发，比如在我们公司的局域网也是192.168.0.0那个网段，192.168.0.254是我需要经常访问的地址，所以可以单独把不需要转发的地址进行屏蔽：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;route 192.168.0.254 255.255.255.255 net_gateway\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;整体的配置如图所示：&lt;br&gt;\n&lt;img src=\&#34;https://www.hualigs.cn/image/62de529ab80c9.jpg\&#34; alt=\&#34;62de529ab80c9\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;将配置删除后重新导入，再登陆即可。&lt;br&gt;\n现在访问一下内网地址，比如群晖在我家地址是：192.168.0.108:5000&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de5338b8528.jpg\&#34; alt=\&#34;62de5338b8528\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以正常访问，但是如果我们要访问其他的服务，比如说通过RDP访问我家那个小主机，也是OK的:&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de53d88eab9.jpg\&#34; alt=\&#34;62de53d88eab9\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;看一下公司仓库是不是也能正常访问，看样子也是ok的，说明VPN成功屏蔽了该ip的转发:&lt;br&gt;\n&lt;img src=\&#34;https://www.hualigs.cn/image/62de547277733.jpg\&#34; alt=\&#34;62de547277733\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;yY0lLI5Ye&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;上一篇写了如何用群晖原生的VPN Server搭建OpenVPN回家，这一篇讲讲客户端怎么配置才能连接OpenVPN，并且通过配置能够使用OpenVPN转发某个网段，屏蔽某些ip和网段。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;OpenVPN｜在局域网里头，才有家的感觉&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;群晖&#34;,&#34;slug&#34;:&#34;uZhHBA2HZ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/uZhHBA2HZ/&#34;},{&#34;name&#34;:&#34;VPN&#34;,&#34;slug&#34;:&#34;8lI5Qg-wZU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/8lI5Qg-wZU/&#34;}],&#34;date&#34;:&#34;2022-07-25 15:29:08&#34;,&#34;dateFormat&#34;:&#34;2022-07-25&#34;,&#34;feature&#34;:&#34;https://s1.xptou.com/2022/08/09/62f1cff4836ac.png&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/yY0lLI5Ye/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:152000,&#34;words&#34;:702,&#34;minutes&#34;:3},&#34;description&#34;:&#34;上一篇写了如何用群晖原生的VPN Server搭建OpenVPN回家，这一篇讲讲客户端怎么配置才能连接OpenVPN，并且通过配置能够使用OpenVPN转发某个网段，屏蔽某些ip和网段。\n\nOpenVPN Connect Client | ...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;之前为了方便自己远程玩我的黑群，开了动态DNS和ssh来远程玩，但发现有几次登DSM提示有人尝试ssh登但被封禁了，虽然ip封禁+强密码挺安全的，但我还是担心万一这玩意有漏洞被登了就麻烦了。再加上我到时候毕设还得在上面搭建各种花里胡哨的服务，例如数据库啊，Redis之类的，总不可能开一个服务还得映射一个端口不是吗？而且还涉及到多个设备的玩耍，还得给其他设备做虚拟服务器转发，又麻烦又不安全，索性搭一个VPN服务来方便我一键回家。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;DSM貌似不提供VPN套件了，但官网还是有这个套件的下载地址，可以手动安装一下&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.synology.com/en-global/support/download\&#34;&gt;Download Center | Synology Inc.&lt;/a&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de4084ae1a4.jpg\&#34; alt=\&#34;62de4084ae1a4\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;按照图片上搜索对应的型号，然后拉下去选择Packages，即可看到相关套件：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de40bdafa3a.jpg\&#34; alt=\&#34;62de40bdafa3a\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de410024390.jpg\&#34; alt=\&#34;62de410024390\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;下载好后在套件中心手动安装，这一步挺简单的，一步步走就是了&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de41a4c86ba.jpg\&#34; alt=\&#34;62de41a4c86ba\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;安装完成后直接在套件中心打开，你可以发现这个套件支持三种VPN协议，为啥选用OpenVPN呢？首先是它是三者中最安全的协议，其次是它不容易被BAN，我好不容易搞的公网Ip到时候说没就没了就不好了。在面板启用OpenVPN服务器就行了&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de423db4fec.jpg\&#34; alt=\&#34;62de423db4fec\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;像我第一次并没有启动成功，提示没有配置中间证书，我找了半天都没找到这个VPN的选项有这个证书配置，后来才发现它的意思是我之前配置群晖地址的ssl证书没有选择中间证书，在那边选好就可以应用了，具体位置在这里，嫌麻烦的可以直接用群晖自己的证书，但连接的时候可能会警告，有域名并申请了证书的就用自己的吧。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62de43700016f.jpg\&#34; alt=\&#34;62de43700016f\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这里一般把私钥和证书提交了就可以用SSL，但没有配置中间证书的话是用不了VPN的。如果是在腾讯云DNSPOD那边申请的证书的话，需要再下载一个根证书作为中间证书上传。&lt;/p&gt;\n&lt;p&gt;所有的配置完毕后，即可开启OpenVPN回家了，下一节再讲讲客户端怎么配置VPN才能优雅回家。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;QQ96ZDO07&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;之前为了方便自己远程玩我的黑群，开了动态DNS和ssh来远程玩，但发现有几次登DSM提示有人尝试ssh登但被封禁了，虽然ip封禁+强密码挺安全的，但我还是担心万一这玩意有漏洞被登了就麻烦了。再加上我到时候毕设还得在上面搭建各种花里胡哨的服务，例如数据库啊，Redis之类的，总不可能开一个服务还得映射一个端口不是吗？而且还涉及到多个设备的玩耍，还得给其他设备做虚拟服务器转发，又麻烦又不安全，索性搭一个VPN服务来方便我一键回家。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;OpenVPN｜在群晖上搭建OpenVPN一键回家&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;群晖&#34;,&#34;slug&#34;:&#34;uZhHBA2HZ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/uZhHBA2HZ/&#34;},{&#34;name&#34;:&#34;VPN&#34;,&#34;slug&#34;:&#34;8lI5Qg-wZU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/8lI5Qg-wZU/&#34;}],&#34;date&#34;:&#34;2022-07-25 14:43:45&#34;,&#34;dateFormat&#34;:&#34;2022-07-25&#34;,&#34;feature&#34;:&#34;https://i0.hdslb.com/bfs/album/329d910b87eb68a68f04b606dc7d0d3d94bacc8e.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/QQ96ZDO07/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:126000,&#34;words&#34;:610,&#34;minutes&#34;:3},&#34;description&#34;:&#34;之前为了方便自己远程玩我的黑群，开了动态DNS和ssh来远程玩，但发现有几次登DSM提示有人尝试ssh登但被封禁了，虽然ip封禁+强密码挺安全的，但我还是担心万一这玩意有漏洞被登了就麻烦了。再加上我到时候毕设还得在上面搭建各种花里胡哨的服务...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;callapplybind是做什么的\&#34;&gt;call,apply,bind是做什么的&lt;/h1&gt;\n&lt;p&gt;call、apply、bind是函数的一种特殊形式，它们的作用是调用函数，并且把函数的参数传递给它。call、apply、bind的实现原理是一样的，都是通过构造函数来实现的。这三种形式的第一个参数，都是函数的调用者，即谁调用了这个函数，从而决定this指向谁。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;下面通过一个例子来说明call、apply、bind的用法。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function foo(a, b, c) {\n  console.log(this, a, b, c);\n}\nfoo(1, 2, 3); // window 1 2 3\nfoo.call({ name: &#39;bar&#39; });, 1, 2, 3); // { name: &#39;bar&#39; }, 1, 2, 3;\nfoo.call(null, 1, 2, 3); // null, 1, 2, 3\nfoo.apply({ name: &#39;bar&#39; }, [1, 2, 3]); // { name: &#39;bar&#39; }, 1, 2, 3;\nfoo.apply(null, [1, 2, 3]); // null, 1, 2, 3\nfoo.bind({ name: &#39;bar&#39; })(1, 2, 3); // { name: &#39;bar&#39; }, 1, 2, 3;\nfoo.bind(null)(1, 2, 3); // null, 1, 2, 3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;call-apply-bind的实现原理\&#34;&gt;call、apply、bind的实现原理&lt;/h1&gt;\n&lt;p&gt;通过上面的例子我们大概可以了解call、apply、bind的实现方法，即this指向第一个函数，剩余的参数绑定到函数的arguments上。知道了这些我们就可以很方便地手写call、apply、bind的实现了。&lt;br&gt;\n首先我们先来实现call的方法&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;Function.prototype.mycall = function(thisArg, ...args) {\n  // 在这里可以去执行调用的那个函数(foo)\n  // 问题: 得可以获取到是哪一个函数执行了mycall\n  // 1.获取需要被执行的函数\n  var fn = this\n\n  // 2.对thisArg转成对象类型(防止它传入的是非对象类型)\n  thisArg = (thisArg !== null &amp;amp;&amp;amp; thisArg !== undefined) ? Object(thisArg): window\n\n  // 3.调用需要被执行的函数\n  thisArg.fn = fn\n  var result = thisArg.fn(...args)\n  delete thisArg.fn\n\n  // 4.将最终的结果返回出去\n  return result\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;简单的验证一下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;function testmycall(a, b) {\n    console.log(this, a + b);\n}\n\ntestmycall(1, 2); // window 3\ntestmycall.mycall(&#39;mycall&#39;, 1 , 2); // mycall 3\ntestmycall.call(&#39;call&#39;, 1 , 2); // call 3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;弄懂了call的实现方法，我们就可以很方便的手写apply、bind的实现了。其实主要的区别就是call的其他参数就是函数的参数，而apply的第二个参数是函数的参数转成数组，bind的回调函数就是函数的参数。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-javascript\&#34;&gt;Function.prototype.myapply = function(thisArg, args) {\n    var fn = this;\n\n    thisArg = (thisArg !== undefined &amp;amp;&amp;amp; thisArg !== null) ? Object(thisArg) :window;\n\n    thisArg.fn = fn;\n    \n    args = args || [];\n    var res = thisArg.fn(...args);\n    delete thisArg.fn;\n\n    return res;\n}\n\ntestmycall.myapply(&#39;myapply&#39;, [111, 222]); // myapply 333\ntestmycall.apply(&#39;apply&#39;, [111, 222]); // apply 333\n\nFunction.prototype.mybind = function(thisArg, ...args) {\n    var fn = this;\n\n    thisArg = (thisArg !== undefined &amp;amp;&amp;amp; thisArg !== null) ? Object(thisArg) :window;\n\n    return function proxyFn(...newArgs) {\n        thisArg.fn = fn;\n        var res = thisArg.fn(...args, ...newArgs);\n        delete thisArg.fn;\n    }\n}\n\nvar testbind = testmycall.bind(&#39;bind&#39;, 123, 456);\ntestbind(111, 222); // bind 333\n\nvar testmybind = testmycall.mybind(&#39;mybind&#39;, 111);\ntestmybind(222); // mybind 333\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;6IUZEiiSX&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;callapplybind是做什么的\&#34;&gt;call,apply,bind是做什么的&lt;/h1&gt;\n&lt;p&gt;call、apply、bind是函数的一种特殊形式，它们的作用是调用函数，并且把函数的参数传递给它。call、apply、bind的实现原理是一样的，都是通过构造函数来实现的。这三种形式的第一个参数，都是函数的调用者，即谁调用了这个函数，从而决定this指向谁。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;手撕call、apply、bind，相关实现和原理&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;javascript&#34;,&#34;slug&#34;:&#34;RiIcqHDzX&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/RiIcqHDzX/&#34;},{&#34;name&#34;:&#34;手撕算法&#34;,&#34;slug&#34;:&#34;mXSK6D8su7&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/mXSK6D8su7/&#34;}],&#34;date&#34;:&#34;2022-07-21 19:22:39&#34;,&#34;dateFormat&#34;:&#34;2022-07-21&#34;,&#34;feature&#34;:&#34;https://www.hualigs.cn/image/62d9418239965.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/6IUZEiiSX/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:176000,&#34;words&#34;:632,&#34;minutes&#34;:3},&#34;description&#34;:&#34;call,apply,bind是做什么的\ncall、apply、bind是函数的一种特殊形式，它们的作用是调用函数，并且把函数的参数传递给它。call、apply、bind的实现原理是一样的，都是通过构造函数来实现的。这三种形式的第一个参数...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#callapplybind%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84\&#34;&gt;call,apply,bind是做什么的&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#call-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\&#34;&gt;call、apply、bind的实现原理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;引言\&#34;&gt;引言&lt;/h1&gt;\n&lt;p&gt;前段时间我实习的时候把项目的构建工具升级到Vite，感觉体验确实比基于Webpack5的Vue-Cli3丝滑了不少，那么我们来一起探索一下Vite相对于Vue-Cli3好在哪吧。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;vite-相对于webpack的好处\&#34;&gt;Vite 相对于Webpack的好处&lt;/h1&gt;\n&lt;p&gt;Webpack本质上是一个JavaScript应用的静态编译工具，开发的时候可以启动本地服务器实时预览，但这个过程还是需要对整个项目进行打包，所以非常缓慢。&lt;/p&gt;\n&lt;p&gt;对于开发中文件热更新也会有相同的问题，所有涉及到文件和依赖的更新都需要重新编译，这样会导致开发效率下降。&lt;/p&gt;\n&lt;p&gt;Vite 只启动静态页面的服务，对文件代码不会进行打包，服务器会根据客户端的请求来处理不同的模块，实现了真正的按需加载。&lt;/p&gt;\n&lt;p&gt;对于热更新问题，Vite升级了热更新机制，对当前的文件进行编译，然后把编译后的文件写入到缓存中，客户端直接读取缓存中的文件，不需要再次编译。&lt;/p&gt;\n&lt;p&gt;综上，vite 具有了&lt;strong&gt;快速冷启动、按需编译、模块热更新&lt;/strong&gt;等优良特质。&lt;/p&gt;\n&lt;h1 id=\&#34;vite工作原理\&#34;&gt;Vite工作原理&lt;/h1&gt;\n&lt;p&gt;在根目录下的index.html中，有这么一段：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62d4cc334d901.jpg\&#34; alt=\&#34;62d4cc334d901\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;通过**type=&#39;module&#39;**改变了js的引入方式，使js能够通过import引入其他的js模块。通过这种方式能够使得开发过程中不需要打包即可引入js模块，且能够按需加载。&lt;/p&gt;\n&lt;p&gt;在引入需要npm打包的模块时，Vite会进行一个预打包的操作：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62d4cea19e9d9.jpg\&#34; alt=\&#34;image-20220718110808880\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;预打包的意义是将第三方模块打包后放在vite的一个裸模块地址，以方便引入。&lt;/p&gt;\n&lt;p&gt;在加载vue文件的时候，vite会将vue文件解析成一个js文件，以此来加载vue的内容：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62d4cfcb04fe1.jpg\&#34; alt=\&#34;image-20220718111311148\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;根据这些方法，我们可以看到vite的工作原理是这样的：&lt;br&gt;\n通过启动一个服务器，加载首页，并在首页中设置**type=&#39;module&#39;**改变了js的引入方式，并通过模块地址替换的方法引入了第三方模块，这样就实现了按需加载。对于Vue文件，vite会利用SFC的方法解析js并渲染Dom文件，以此来加载vue的内容。&lt;br&gt;\n有了这些原理，我们就可以动手实现一个简单的Vite了。具体不在文章中赘述了，感兴趣的可以看我实现的项目方法。&lt;br&gt;\n&lt;a href=\&#34;https://github.com/veithly/MyVite\&#34;&gt;我自己实现的Vite项目&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;MPDWmrn41&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;引言\&#34;&gt;引言&lt;/h1&gt;\n&lt;p&gt;前段时间我实习的时候把项目的构建工具升级到Vite，感觉体验确实比基于Webpack5的Vue-Cli3丝滑了不少，那么我们来一起探索一下Vite相对于Vue-Cli3好在哪吧。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Vite原理和好处&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Vite&#34;,&#34;slug&#34;:&#34;r-MGkmkCK&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/r-MGkmkCK/&#34;},{&#34;name&#34;:&#34;WebPack&#34;,&#34;slug&#34;:&#34;_Q9iqSPsKQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/_Q9iqSPsKQ/&#34;},{&#34;name&#34;:&#34;Vue&#34;,&#34;slug&#34;:&#34;jyYqdkRRAH&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/jyYqdkRRAH/&#34;}],&#34;date&#34;:&#34;2022-07-18 10:08:45&#34;,&#34;dateFormat&#34;:&#34;2022-07-18&#34;,&#34;feature&#34;:&#34;https://www.hualigs.cn/image/62d941dbb70b6.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/MPDWmrn41/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:true,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:135000,&#34;words&#34;:646,&#34;minutes&#34;:3},&#34;description&#34;:&#34;引言\n前段时间我实习的时候把项目的构建工具升级到Vite，感觉体验确实比基于Webpack5的Vue-Cli3丝滑了不少，那么我们来一起探索一下Vite相对于Vue-Cli3好在哪吧。\n\nVite 相对于Webpack的好处\nWebpack...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%95%E8%A8%80\&#34;&gt;引言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vite-%E7%9B%B8%E5%AF%B9%E4%BA%8Ewebpack%E7%9A%84%E5%A5%BD%E5%A4%84\&#34;&gt;Vite 相对于Webpack的好处&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#vite%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\&#34;&gt;Vite工作原理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;dom\&#34;&gt;DOM&lt;/h1&gt;\n&lt;p&gt;vue和React框架应用广泛，封装了DOM操作，但DOM操作一直都会前端工程师的基础、必备知识，只会Vue而不懂DOM操作的前端程序员，不会长久&lt;/p&gt;\n&lt;h2 id=\&#34;本质\&#34;&gt;本质&lt;/h2&gt;\n&lt;p&gt;html语言解析出来的树结构&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2590acf.jpg\&#34; alt=\&#34;20220311Na22I3\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;可以通过js获取浏览器的dom节点\&#34;&gt;可以通过js获取浏览器的dom节点&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;const div1 = document.getElementById(&#39;div1&#39;)\nconsole.log(&#39;div1&#39;, div1)\n\nconst divList = document.getElementsByTagName(&#39;div&#39;) // 集合\nconsole.log(&#39;divList.length&#39;, divList.length)\nconsole.log(&#39;divList[1]&#39;, divList[1])\n\nconst containerList = document.getElementsByClassName(&#39;container&#39;) // 集合\nconsole.log(&#39;containerList.length&#39;, containerList.length)\nconsole.log(&#39;containerList[1]&#39;, containerList[1])\n\nconst pList = document.querySelectorAll(&#39;p&#39;)\nconsole.log(&#39;pList&#39;, pList)\n\nconst pList = document.querySelectorAll(&#39;p&#39;)\nconst p1 = pList[0]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;通过property和attribute修改节点属性\&#34;&gt;通过property和attribute修改节点属性&lt;/h2&gt;\n&lt;p&gt;property：修改对象属性，不会体现到html结构中&lt;br&gt;\nattribute：修改html属性，会改变html结构&lt;br&gt;\n两者都有可能引起DOM重新渲染&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;// property 形式\np1.style.width = &#39;100px&#39;\nconsole.log( p1.style.width )\np1.className = &#39;red&#39;\nconsole.log( p1.className )\nconsole.log(p1.nodeName)\nconsole.log(p1.nodeType) // 1\n\n// attribute\np1.setAttribute(&#39;data-name&#39;, &#39;imooc&#39;)\nconsole.log( p1.getAttribute(&#39;data-name&#39;) )\np1.setAttribute(&#39;style&#39;, &#39;font-size: 50px;&#39;)\nconsole.log( p1.getAttribute(&#39;style&#39;) )\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;新建-移动节点\&#34;&gt;新建、移动节点&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;const div1 = document.getElementById(&#39;div1&#39;)\nconst div2 = document.getElementById(&#39;div2&#39;)\n\n// 新建节点\nconst newP = document.createElement(&#39;p&#39;)\nnewP.innerHTML = &#39;this is newP&#39;\n// 插入节点\ndiv1.appendChild(newP)\n\n// 移动节点\nconst p1 = document.getElementById(&#39;p1&#39;)\ndiv2.appendChild(p1)\n\n// 获取父元素\nconsole.log( p1.parentNode )\n\n// 获取子元素列表\nconst div1ChildNodes = div1.childNodes\nconsole.log( div1.childNodes )\nconst div1ChildNodesP = Array.prototype.slice.call(div1.childNodes).filter(child =&amp;gt; {\n    if (child.nodeType === 1) {\n        return true\n    }\n    return false\n})\nconsole.log(&#39;div1ChildNodesP&#39;, div1ChildNodesP)\n\ndiv1.removeChild( div1ChildNodesP[0] )\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;dom性能优化\&#34;&gt;dom性能优化&lt;/h2&gt;\n&lt;p&gt;DOM操作非常“昂贵”，避免频繁的DOM操作&lt;br&gt;\n对DOM查询做缓存&lt;br&gt;\n将频繁操作改为一次性操作&lt;/p&gt;\n&lt;h3 id=\&#34;缓存dom查询\&#34;&gt;缓存dom查询&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;// 不缓存DOM查询结果\nfor (let i = 0;i &amp;lt; document.getElementsByTagName(&#39;p&#39;).length;i++){\n  // 每次循环都会计算length，频繁进行DOM查询\n}\n\n// 缓存DOM查询结果\nconst Plist = document.getElementsByTagName(&#39;p&#39;);\nconst length = Plist.length;\nfor (let i = 0;i &amp;lt; length;i++) {\n  // 缓存length，只进行一次dom查询\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;将频繁的操作改成一次性操作\&#34;&gt;将频繁的操作改成一次性操作&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;const list = document.getElementById(&#39;list&#39;)\n\n// 创建一个文档片段，此时还没有插入到 DOM 结构中\nconst frag = document.createDocumentFragment()\n\nfor (let i  = 0; i &amp;lt; 20; i++) {\n    const li = document.createElement(&#39;li&#39;)\n    li.innerHTML = `List item ${i}`\n\n    // 先插入文档片段中\n    frag.appendChild(li)\n}\n\n// 都完成之后，再统一插入到 DOM 结构中\nlist.appendChild(frag)\n\nconsole.log(list)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;bom\&#34;&gt;BOM&lt;/h1&gt;\n&lt;h2 id=\&#34;浏览器信息查看\&#34;&gt;浏览器信息查看&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;//navigator\nconst ua = navigator.userAgent\nconst isChrome = ua.indexOf(&#39;Chrome&#39;)\nconsole.log (isChrome)\n//screen\nconsole.log(screen.width)\nconsole.log (screen.height)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;地址信息查看\&#34;&gt;地址信息查看&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;//location\nconsole.log(location.href)\nconsole.log(location.protocol)//&#39;http:&#39;https:\nconsole.log(location.pathname)//&#39;/learn/199&#39;\nconsole.log(location.search)// ? ...\nconsole.log(location.hash) // # ...\n//history\nhistory.back() //后退\nhistory.forward() //前进\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;d4uf5Rh_t&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;dom\&#34;&gt;DOM&lt;/h1&gt;\n&lt;p&gt;vue和React框架应用广泛，封装了DOM操作，但DOM操作一直都会前端工程师的基础、必备知识，只会Vue而不懂DOM操作的前端程序员，不会长久&lt;/p&gt;\n&lt;h2 id=\&#34;本质\&#34;&gt;本质&lt;/h2&gt;\n&lt;p&gt;html语言解析出来的树结构&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2590acf.jpg\&#34; alt=\&#34;20220311Na22I3\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;title&#34;:&#34;javascript webapi&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2022-03-11 18:38:00&#34;,&#34;dateFormat&#34;:&#34;2022-03-11&#34;,&#34;feature&#34;:&#34;https://www.hualigs.cn/image/62d9422b8af93.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/d4uf5Rh_t/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:181000,&#34;words&#34;:622,&#34;minutes&#34;:4},&#34;description&#34;:&#34;DOM\nvue和React框架应用广泛，封装了DOM操作，但DOM操作一直都会前端工程师的基础、必备知识，只会Vue而不懂DOM操作的前端程序员，不会长久\n本质\nhtml语言解析出来的树结构\n\n\n可以通过js获取浏览器的dom节点\ncons...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#dom\&#34;&gt;DOM&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E8%B4%A8\&#34;&gt;本质&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87js%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84dom%E8%8A%82%E7%82%B9\&#34;&gt;可以通过js获取浏览器的dom节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%80%9A%E8%BF%87property%E5%92%8Cattribute%E4%BF%AE%E6%94%B9%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7\&#34;&gt;通过property和attribute修改节点属性&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E5%BB%BA-%E7%A7%BB%E5%8A%A8%E8%8A%82%E7%82%B9\&#34;&gt;新建、移动节点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dom%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\&#34;&gt;dom性能优化&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%93%E5%AD%98dom%E6%9F%A5%E8%AF%A2\&#34;&gt;缓存dom查询&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%86%E9%A2%91%E7%B9%81%E7%9A%84%E6%93%8D%E4%BD%9C%E6%94%B9%E6%88%90%E4%B8%80%E6%AC%A1%E6%80%A7%E6%93%8D%E4%BD%9C\&#34;&gt;将频繁的操作改成一次性操作&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#bom\&#34;&gt;BOM&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B\&#34;&gt;浏览器信息查看&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B\&#34;&gt;地址信息查看&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;单线程和异步\&#34;&gt;单线程和异步&lt;/h1&gt;\n&lt;h2 id=\&#34;js单线程\&#34;&gt;JS单线程&lt;/h2&gt;\n&lt;p&gt;JS是单线程语言，只能同时做一件事。&lt;/p&gt;\n&lt;p&gt;浏览器和node.js已支持JS启动进程，如Web Worker&lt;/p&gt;\n&lt;p&gt;JS和DOM渲染共用同一个线程，因为JS可修改DOM结构&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;异步原因\&#34;&gt;异步原因&lt;/h2&gt;\n&lt;p&gt;遇到等待（网络请求，定时任务）不能卡住&lt;/p&gt;\n&lt;p&gt;需要异步&lt;/p&gt;\n&lt;p&gt;回调callback函数形式&lt;/p&gt;\n&lt;h2 id=\&#34;异步和同步\&#34;&gt;异步和同步&lt;/h2&gt;\n&lt;p&gt;基于JS是单线程语言&lt;br&gt;\n异步不会阻塞代码执行&lt;br&gt;\n同步会阻塞代码执行&lt;/p&gt;\n&lt;p&gt;异步 （callback 回调函数）&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;console.log(100)\nsetTimeout(() =&amp;gt; {\n    console.log(200)\n}, 1000) // 最后打印\nconsole.log(300)\nconsole.log(400)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;同步&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;console.log(100)\nalert(200) // 点击ok才能打印300\nconsole.log(300)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;应用场景\&#34;&gt;应用场景&lt;/h1&gt;\n&lt;p&gt;网络请求，如ajax图片加载&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;console.log(&#39;start&#39;)\n$.get(&#39;./data.json&#39;,function(data){\n  console.log(data)\n})\nconsole.log(&#39;end&#39;)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;定时任务，如setTimeout&lt;/p&gt;\n&lt;h1 id=\&#34;promise\&#34;&gt;Promise&lt;/h1&gt;\n&lt;h2 id=\&#34;callback-hell回调地狱\&#34;&gt;callback hell回调地狱&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;//获取第一份数据\n$.get(url1, (data1) =&amp;gt; {\n  console.log(data1);\n  //获取第二份数据\n  $.get(url2, (data2) =&amp;gt; {\n    console.log(data2);\n    //获取第三份数据\n    $get(url3, (data3) =&amp;gt; {\n      console.log(data3);\n      //还可能获取更多的数据})\n    });\n  });\n});\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;promise封装ajax\&#34;&gt;Promise封装ajax&lt;/h2&gt;\n&lt;h3 id=\&#34;封装\&#34;&gt;封装&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;getData = (url) =&amp;gt; {\n  return new Promise((resolve, reject) =&amp;gt; {\n    $.ajax({\n      url,\n      success(data) {\n        resolve(data);\n      },\n      error(err) {\n        reject(err);\n      },\n    });\n  });\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;使用\&#34;&gt;使用&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;const url1 = &amp;quot;/data1.json&amp;quot;;\nconst url2 = &amp;quot;/data2.json&amp;quot;;\nconst url3 = &amp;quot;/data3.json&amp;quot;;\n\ngetData(url1)\n  .then((data1) =&amp;gt; {\n    console.log(data1);\n    return getData(url2);\n  })\n  .then((data2) =&amp;gt; {\n    console.log(data2);\n    return getData(url3);\n  })\n  .then((data3) =&amp;gt; {\n    console.log(data3);\n  })\n  .catch((err) =&amp;gt; console.error(err));\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;IYITuNTSJ&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;单线程和异步\&#34;&gt;单线程和异步&lt;/h1&gt;\n&lt;h2 id=\&#34;js单线程\&#34;&gt;JS单线程&lt;/h2&gt;\n&lt;p&gt;JS是单线程语言，只能同时做一件事。&lt;/p&gt;\n&lt;p&gt;浏览器和node.js已支持JS启动进程，如Web Worker&lt;/p&gt;\n&lt;p&gt;JS和DOM渲染共用同一个线程，因为JS可修改DOM结构&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;javascript异步&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;异步&#34;,&#34;slug&#34;:&#34;zGkcuxftU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/zGkcuxftU/&#34;},{&#34;name&#34;:&#34;js&#34;,&#34;slug&#34;:&#34;5B7eIVW7Nw&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/5B7eIVW7Nw/&#34;}],&#34;date&#34;:&#34;2022-03-11 18:35:45&#34;,&#34;dateFormat&#34;:&#34;2022-03-11&#34;,&#34;feature&#34;:&#34;https://i0.hdslb.com/bfs/album/0bc438b7740ee8cb7b4d5ac7aa80e485caf2574e.png&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/IYITuNTSJ/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:92000,&#34;words&#34;:336,&#34;minutes&#34;:2},&#34;description&#34;:&#34;单线程和异步\nJS单线程\nJS是单线程语言，只能同时做一件事。\n浏览器和node.js已支持JS启动进程，如Web Worker\nJS和DOM渲染共用同一个线程，因为JS可修改DOM结构\n\n异步原因\n遇到等待（网络请求，定时任务）不能卡住\n...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5\&#34;&gt;单线程和异步&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#js%E5%8D%95%E7%BA%BF%E7%A8%8B\&#34;&gt;JS单线程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%82%E6%AD%A5%E5%8E%9F%E5%9B%A0\&#34;&gt;异步原因&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5\&#34;&gt;异步和同步&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\&#34;&gt;应用场景&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promise\&#34;&gt;Promise&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#callback-hell%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1\&#34;&gt;callback hell回调地狱&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#promise%E5%B0%81%E8%A3%85ajax\&#34;&gt;Promise封装ajax&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%81%E8%A3%85\&#34;&gt;封装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%BF%E7%94%A8\&#34;&gt;使用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;class和继承\&#34;&gt;Class和继承&lt;/h1&gt;\n&lt;h2 id=\&#34;class\&#34;&gt;class&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;class Student {\n    constructor(name, number) {\n        this.name = name;\n        this.number = number;\n    }\n    sayHi() {\n        console.log(\n            `Name:${this.name}, Id:${this.number}`\n        )\n    }\n}\n\n&amp;lt;!-- more --&amp;gt;\n\nconst Ricky = new Student(&amp;quot;Ricky&amp;quot;,100)\nconsole.log(Ricky.name)\nRicky.sayHi()\n//Ricky\n//Name:Ricky, Number:100\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;继承\&#34;&gt;继承&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;// 父类\nclass People {\n  constructor(name) {\n    this.name = name;\n  }\n  eat() {\n    console.log(`${this.name} eat something`);\n  }\n}\n\n// 子类\nclass Student extends People {\n  constructor(name, number) {\n    super(name);\n    this.number = number;\n  }\n  sayHi() {\n      console.log(`hi,${this.name},your number is ${this.number}`)\n  }\n}\n\nconst me = new Student(&amp;quot;RS&amp;quot;,100)\nme.sayHi()\nme.eat()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;hi,RS,your number is 100&lt;br&gt;\nRS eat something&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;类型判断\&#34;&gt;类型判断&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;me instanceof Student // true\nme instanceof People // true\nme instanceof Object // true\ntypeof me // object\ntypeof Student // function \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;原型和原型链\&#34;&gt;原型和原型链&lt;/h2&gt;\n&lt;h3 id=\&#34;原型\&#34;&gt;原型&lt;/h3&gt;\n&lt;p&gt;隐式原型和显示原型&lt;/p&gt;\n&lt;p&gt;每个class都有显示原型prototype&lt;br&gt;\n每个实例都有隐式原型_proto_&lt;br&gt;\n实例的_proto_指向对应class的prototype&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;me.__proto__ === Student.prototype //true\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;获取属性xialuo.name或执行方法xialuo.sayhi()时&lt;br&gt;\n先在自身属性和方法寻找&lt;br&gt;\n如果找不到则自动去_proto_中查找&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2536b2f.jpg\&#34; alt=\&#34;20220311sjyGYm\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;原型链\&#34;&gt;原型链&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c256afed.jpg\&#34; alt=\&#34;202203116lh5b6\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;如何准确判断一个变量是不是数组\&#34;&gt;如何准确判断一个变量是不是数组？&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;a instanceof Array\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;class的原型本质怎么理解\&#34;&gt;class的原型本质，怎么理解？&lt;/h2&gt;\n&lt;p&gt;原型和原型链图示&lt;/p&gt;\n&lt;p&gt;属性和方法执行规则&lt;/p&gt;\n&lt;h2 id=\&#34;手写一个简易的jquery考虑插件和扩展性\&#34;&gt;手写一个简易的jQuery，考虑插件和扩展性&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;class jQuery {\n  constructor(selector) {\n    const result = document.querySelectorAll(selector);\n    const length = result.length;\n    for (let i = 0; i &amp;lt; length; i++) {\n      this[i] = result[i];\n    }\n    this.length = length;\n    this.selector = selector;\n    // 类似于数组\n  }\n\n  get(index) {\n    return this[index];\n  }\n\n  each(fn) {\n    for (let i = 0; i &amp;lt; this.length; i++) {\n      const elem = this[i];\n      fn(elem);\n    }\n  }\n\n  on(type, fn) {\n    return this.each((elem) =&amp;gt; {\n      elem.addEventListener(type, fn, false);\n    });\n  }\n}\n\n// 插件\njQuery.prototype.dialog = function (info) {\n  alert(info);\n};\n\n// 造轮子\nclass myJquery extends jQuery {\n  constructor(selector) {\n    super(selector);\n  }\n  methods() {}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;gExSGHVAQ&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;class和继承\&#34;&gt;Class和继承&lt;/h1&gt;\n&lt;h2 id=\&#34;class\&#34;&gt;class&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;class Student {\n    constructor(name, number) {\n        this.name = name;\n        this.number = number;\n    }\n    sayHi() {\n        console.log(\n            `Name:${this.name}, Id:${this.number}`\n        )\n    }\n}&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;title&#34;:&#34;原型和原型链&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;原型&#34;,&#34;slug&#34;:&#34;RMmiODQeM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/RMmiODQeM/&#34;},{&#34;name&#34;:&#34;js&#34;,&#34;slug&#34;:&#34;5B7eIVW7Nw&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/5B7eIVW7Nw/&#34;}],&#34;date&#34;:&#34;2022-03-11 18:32:25&#34;,&#34;dateFormat&#34;:&#34;2022-03-11&#34;,&#34;feature&#34;:&#34;https://i0.hdslb.com/bfs/album/619312d2e9b5135c51bda5e31eda945d25152f60.png&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/gExSGHVAQ/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:113000,&#34;words&#34;:377,&#34;minutes&#34;:2},&#34;description&#34;:&#34;Class和继承\nclass\nclass Student {\n    constructor(name, number) {\n        this.name = name;\n        this.number = number;\n ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#class%E5%92%8C%E7%BB%A7%E6%89%BF\&#34;&gt;Class和继承&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#class\&#34;&gt;class&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%A7%E6%89%BF\&#34;&gt;继承&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\&#34;&gt;类型判断&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE\&#34;&gt;原型和原型链&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E5%9E%8B\&#34;&gt;原型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8E%9F%E5%9E%8B%E9%93%BE\&#34;&gt;原型链&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E5%87%86%E7%A1%AE%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84\&#34;&gt;如何准确判断一个变量是不是数组？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#class%E7%9A%84%E5%8E%9F%E5%9E%8B%E6%9C%AC%E8%B4%A8%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3\&#34;&gt;class的原型本质，怎么理解？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84jquery%E8%80%83%E8%99%91%E6%8F%92%E4%BB%B6%E5%92%8C%E6%89%A9%E5%B1%95%E6%80%A7\&#34;&gt;手写一个简易的jQuery，考虑插件和扩展性&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;作用域\&#34;&gt;作用域&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2533940.jpg\&#34; alt=\&#34;作用域\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;全局作用域\&#34;&gt;全局作用域&lt;/h2&gt;\n&lt;p&gt;window对象，document对象&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;函数作用域\&#34;&gt;函数作用域&lt;/h2&gt;\n&lt;p&gt;在函数中定义的变量&lt;/p&gt;\n&lt;h2 id=\&#34;块级作用域\&#34;&gt;块级作用域&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;if (1) {\n\tlet x = 100\n}\nconsole.log(x) // 报错\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;创建10个a标签点击时弹出对应序号\&#34;&gt;创建10个&lt;a&gt;标签，点击时弹出对应序号&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;// 错误写法：i是全局作用域，点击事件发生时i已经是10了\nlet i,a;\nfor(i=0;i&amp;lt;10;i++){\n  a = document.createElement(&#39;a&#39;)\n  a.innerHTML = i + &#39;&amp;lt;br&amp;gt;&#39;\n\t// 点击时才会执行，此时的i已经为10\n  a.addEventListener(&#39;click&#39;, function(e){\n    e.preventDefault();\n    alert(i)\n  })\n  document.body.appendChild(a)\n}\n// 正确写法\nlet a;\nfor(let i=0;i&amp;lt;10;i++){\n  a = document.createElement(&#39;a&#39;)\n  a.innerHTML = i + &#39;&amp;lt;br&amp;gt;&#39;\n\t// 点击时才会执行，此时的i已经为10\n  a.addEventListener(&#39;click&#39;, function(e){\n    e.preventDefault();\n    alert(i)\n  })\n  document.body.appendChild(a)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;闭包\&#34;&gt;闭包&lt;/h1&gt;\n&lt;p&gt;自由变量的查找，是在函数定义的地方，向上级作用域查找不是在执行的地方！！！&lt;/p&gt;\n&lt;h2 id=\&#34;函数作为返回值\&#34;&gt;函数作为返回值&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;function create() {\n  let a = 100;\n  return function() {\n    console.log(a)\n  }\n}\nlet fn = create()\nlet a = 200\nfn() // 100\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;函数作为参数\&#34;&gt;函数作为参数&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;function print(fn) {\n  let a = 200\n  fn()\n}\nlet a = 100\nfunction fn() {\n  console.log(a)\n}\nprint(fn) // 100\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;闭包隐藏数据只提供api\&#34;&gt;闭包隐藏数据，只提供API&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;const createCache = () =&amp;gt; {\n  const data = {};\n  return {\n    set : (key,val) =&amp;gt; {\n      data[key] =  val\n    },\n    get : (key) =&amp;gt; {\n      return data[key]\n    }\n  }\n}\n\nconst c = createCache()\nc.set(&#39;a&#39;,100)\nconsole.log(c.get(&#39;a&#39;)) // 100\nconsole.log(c.data) // undefined\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;this\&#34;&gt;this&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;当做普通函数被调用&lt;/li&gt;\n&lt;li&gt;使用call apply bind&lt;/li&gt;\n&lt;li&gt;作为对象方法调用&lt;/li&gt;\n&lt;li&gt;在class的方法中调用&lt;/li&gt;\n&lt;li&gt;箭头函数&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;this取什么样的值是在函数执行时决定而不是函数定义时。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;function fn() {\n  console.log(this)\n}\nfn() // window\nfn.call({x:100}) // {x:100}\nconst fn2 = fn.bind({x:200}) \nfn2() // {x:200}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在宏任务时this指向window&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;const Zhangshan = {\n  name: &amp;quot;Zhangshan&amp;quot;,\n  sayhi() {\n    console.log(this)\n  },\n  waitSayhi() {\n    setTimeout(function() {\n      console.log(this)      \n    } )\n  }\n}\nZhangshan.sayhi() // object Zhangshan\nZhangshan.waitSayhi() // window\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;箭头函数永远指向上一级&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;const Zhangshan = {\n  name: &amp;quot;Zhangshan&amp;quot;,\n  sayhi() {\n    console.log(this)\n  },\n  waitSayhi() {\n    setTimeout(() =&amp;gt; {\n      console.log(this)      \n    } )\n  }\n}\nZhangshan.sayhi() // object Zhangshan\nZhangshan.waitSayhi() // object Zhangshan\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;手写bind\&#34;&gt;手写bind&lt;/h3&gt;\n&lt;p&gt;**&lt;code&gt;bind()&lt;/code&gt;**方法创建一个新的函数，在 &lt;code&gt;bind()&lt;/code&gt;被调用时，这个新函数的 &lt;code&gt;this&lt;/code&gt;被指定为 &lt;code&gt;bind()&lt;/code&gt;的第一个参数，而其余参数将作为新函数的参数，供调用时使用。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\&#34;&gt;Function.prototype.bind() - JavaScript | MDN&lt;/a&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;// 模拟bind\nFunction.prototype.bind1 = function() {\n  // 将参数拆解成数组\n  const args = Array.prototype.slice.call(arguments);\n  // 获取 this (数组第一项)\n  const t = args.shift();\n  // fn1.bind(...)中的fn1\n  const self = this;\n  // 返回一个函数\n  return function(){\n    return self.apply(t,args)\n  }\n}\n\nfunction fn1(a, b, c) {\n  console.log(&amp;quot;this&amp;quot;, this);\n  console.log(a, b, c);\n  return &amp;quot;this is fn1&amp;quot;;\n}\n\nconst fn2 = fn1.bind1({ x: 100 }, 10, 20, 30);\nconst res = fn2();\nconsole.log(res);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;this { x: 100 }&lt;br&gt;\n10 20 30&lt;br&gt;\nthis is fn1&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;jI2_ld7dF&#34;,&#34;abstract&#34;:&#34;&lt;h1 id=\&#34;作用域\&#34;&gt;作用域&lt;/h1&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2533940.jpg\&#34; alt=\&#34;作用域\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;全局作用域\&#34;&gt;全局作用域&lt;/h2&gt;\n&lt;p&gt;window对象，document对象&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;作用域与闭包问题&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;作用域&#34;,&#34;slug&#34;:&#34;YIORB0h7K&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/YIORB0h7K/&#34;},{&#34;name&#34;:&#34;前端&#34;,&#34;slug&#34;:&#34;fQqcR7eLj&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/fQqcR7eLj/&#34;}],&#34;date&#34;:&#34;2022-03-10 00:07:30&#34;,&#34;dateFormat&#34;:&#34;2022-03-10&#34;,&#34;feature&#34;:&#34;https://www.hualigs.cn/image/62d94319272a2.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/jI2_ld7dF/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:179000,&#34;words&#34;:620,&#34;minutes&#34;:3},&#34;description&#34;:&#34;作用域\n\n全局作用域\nwindow对象，document对象\n\n函数作用域\n在函数中定义的变量\n块级作用域\nif (1) {\n\tlet x = 100\n}\nconsole.log(x) // 报错\n\n创建10个标签，点击时弹出对应序号\n//...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%9C%E7%94%A8%E5%9F%9F\&#34;&gt;作用域&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F\&#34;&gt;全局作用域&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F\&#34;&gt;函数作用域&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F\&#34;&gt;块级作用域&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9B%E5%BB%BA10%E4%B8%AAa%E6%A0%87%E7%AD%BE%E7%82%B9%E5%87%BB%E6%97%B6%E5%BC%B9%E5%87%BA%E5%AF%B9%E5%BA%94%E5%BA%8F%E5%8F%B7\&#34;&gt;创建10个&lt;a&gt;标签，点击时弹出对应序号&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AD%E5%8C%85\&#34;&gt;闭包&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC\&#34;&gt;函数作为返回值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0\&#34;&gt;函数作为参数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AD%E5%8C%85%E9%9A%90%E8%97%8F%E6%95%B0%E6%8D%AE%E5%8F%AA%E6%8F%90%E4%BE%9Bapi\&#34;&gt;闭包隐藏数据，只提供API&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#this\&#34;&gt;this&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%8B%E5%86%99bind\&#34;&gt;手写bind&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;console.log([1,2,3,4,5].splice(1,2,3,4,5));\nconsole.log([1,2,3,4,5].slice(1,2,3,4,5));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;以下代码输出&lt;br&gt;\n&lt;code&gt;[2,3]和[2]&lt;/code&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;splice与slice区别\&#34;&gt;splice与slice区别&lt;/h2&gt;\n&lt;p&gt;slice方法实现了从原数组中截取一部分返回新的数组&lt;/p&gt;\n&lt;p&gt;slice(start, end)&lt;strong&gt;不包含end&lt;/strong&gt;,如果start,end为负数则表示从数组最后一个索引向前计算&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;返回值：所截取的数组对象&lt;/em&gt;&lt;/p&gt;\n&lt;p&gt;所以问题一的结果为[2].&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;问题二：[1,2,3,4,5].splice(1,2,3,4,5)&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;splice方法实现了从原数组中删除或插入一部分内容&lt;/p&gt;\n&lt;p&gt;splice(index, howmany, item1, ...itemx )&lt;/p&gt;\n&lt;p&gt;index表示从当前索引开始删除，&lt;/p&gt;\n&lt;p&gt;howmany代表删除元素的个数&lt;/p&gt;\n&lt;p&gt;items 要添加到索引的新元素&lt;/p&gt;\n&lt;p&gt;&lt;em&gt;返回值：如果从原数组中删除了元素，则但返回含有被删除的数组对象&lt;/em&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;root元素的高-通过getcomputedstylerootheight计算-为\&#34;&gt;root元素的高 (通过getComputedStyle(root).height计算) 为？&lt;/h2&gt;\n&lt;p&gt;70px&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;&amp;lt;html&amp;gt;\n&amp;lt;body&amp;gt;\n&amp;lt;div id=&amp;quot;root&amp;quot; style=&amp;quot;border:1px solid red;&amp;quot;&amp;gt;\n    &amp;lt;div style=&amp;quot;width:10px;height:10px;margin:10px;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;div style=&amp;quot;width:10px;height:10px;margin:20px;&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;/div&amp;gt;\n&amp;lt;/body&amp;gt;\n&amp;lt;/html&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;有border形成BFC，两个子组件margin重叠，取大&lt;/p&gt;\n&lt;p&gt;如果块元素的 margin-top 与它的第一个子元素的 margin-top 之间没有 border、padding等来分隔，或者块元素的 margin-bottom与它最后一个子元素的 margin-bottom 之间没有 border、padding、height、min-height、max-height 分隔，那么&lt;strong&gt;外边距会塌陷&lt;/strong&gt;。子元素多余的外边距会被父元素的外边距截断。&lt;/p&gt;\n&lt;h2 id=\&#34;bfcblock-formatting-context格式化上下文是web页面中盒模型布局的css渲染模式指一个独立的渲染区域或者说是一个隔离的独立容器-形成bfc的条件有\&#34;&gt;BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。&lt;strong&gt;形成BFC的条件有&lt;/strong&gt;&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;display 为以下其中之一的值 inline-block，table-cell，table-caption、flex&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;浮动元素，float 除 none 以外的值&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;overflow 除了 visible 以外的值（hidden，auto，scroll）&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;绝对定位元素，position（absolute，fixed）&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://www.notion.so/CSS-BFC-IFC-GFC-FFC-4a6a13a5270e48f6a8504f5bc0141667\&#34;&gt;CSS 盒模型、BFC、IFC、GFC、FFC&lt;/a&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;下边关于https描述正确的是\&#34;&gt;下边关于https描述正确的是:&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;客户端会对服务器下发的证书进行域名校验&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;HTTPS 协议是由 HTTP 加上 &lt;a href=\&#34;https://baike.baidu.com/item/TLS/2979545\&#34;&gt;TLS&lt;/a&gt;/SSL 协议构建的可进行加密传输、身份认证的网络协议，主要通过&lt;a href=\&#34;https://baike.baidu.com/item/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/326874\&#34;&gt;数字证书&lt;/a&gt;、&lt;a href=\&#34;https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/2816213\&#34;&gt;加密算法&lt;/a&gt;、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。设计目标主要有三个。&lt;/p&gt;\n&lt;p&gt;（1）数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 [4]  。&lt;/p&gt;\n&lt;p&gt;（2）数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 [4]  。&lt;/p&gt;\n&lt;p&gt;（3）身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 [4]  。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;双向的身份认证&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081\&#34;&gt;客户端&lt;/a&gt;和&lt;a href=\&#34;https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AF/6492316\&#34;&gt;服务端&lt;/a&gt;在传输数据之前,会通过基于&lt;a href=\&#34;https://baike.baidu.com/item/X.509/2817050\&#34;&gt;X.509&lt;/a&gt;证书对双方进行身份认证 。具体过程如下 [3]  :&lt;/p&gt;\n&lt;p&gt;客户端发起 SSL 握手消息给服务端要求连接。&lt;/p&gt;\n&lt;p&gt;服务端将证书发送给客户端。&lt;/p&gt;\n&lt;p&gt;客户端检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。&lt;/p&gt;\n&lt;p&gt;服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的&lt;a href=\&#34;https://baike.baidu.com/item/%E5%85%AC%E9%92%A5/6447788\&#34;&gt;公钥&lt;/a&gt;，一般为1024位或者 2048位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。&lt;/p&gt;\n&lt;h2 id=\&#34;下边关于xss描述正确的是\&#34;&gt;下边关于XSS描述正确的是&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;XSS又名跨站脚本攻击，是利用服务器查询漏洞，在提交数据中注入sql语句，从而破坏网站数据&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;防范XSS攻击只要前端对数据进行Base64就可以解决&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;XSS攻击需要也服务器对接口进行防护&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;XSS攻击仅在表单提交时使用&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;A选项：xss（cross-site-scripting）攻击指的是攻击者往 web 页面里&lt;strong&gt;插入恶意 html 标签或者 javascript 代码&lt;/strong&gt; ；&lt;/p&gt;\n&lt;p&gt;B选项：首先代码里对用户输入的地方和变量都需要&lt;strong&gt;仔细检查长度和对 “&amp;lt;&amp;gt; , ; . ”等字进行过滤&lt;/strong&gt;；其次任何内容写到页面之前&lt;strong&gt;都必须加 encode&lt;/strong&gt;，避免不小心把 html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 ；&lt;/p&gt;\n&lt;p&gt;D选项：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器汇总，而不是用户原本以为的信任站点 ；&lt;/p&gt;\n&lt;h2 id=\&#34;以下运行结果\&#34;&gt;以下运行结果:&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;for(var i = 0; i &amp;lt; 10; i++) {\n\n    setTimeout(function() {\n\n        console.log(i);\n\n    }, 1000);\n\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;10个10&lt;/p&gt;\n&lt;p&gt;for循环执行内部函数的时候i到9，然后终止时i加到10后不累加了，所以通过宏任务可知console.log十次十&lt;/p&gt;\n&lt;h2 id=\&#34;在跨域请求中下列请求头中哪种content-type一定会触发cors预检查\&#34;&gt;在跨域请求中，下列请求头中哪种content-type一定会触发cors预检查&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;text/plain&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;multipart/form-data&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;application/x-www-form-unlencoded&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;application/json&lt;/code&gt;&lt;/strong&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;触发预检请求的三类条件&lt;/strong&gt;：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;默认情况下，跨域请求只支持GET,HEAD,POST方法，如果不是这三个请求方法（比如：PUT、DELETE、CONNECT、OPTIONS、TRACE和PATCH），那么将触发预检请求&lt;/li&gt;\n&lt;li&gt;默认情况下，浏览器跨域请求时，会自动添加的请求头（HOST,Referer,Connection、Accept、User-Agent,Accept-Languange,Accept-Encoding,Accept-Charset和Content-Type）,这些请求中还有其他请求头时，那么将触发预检请求。&lt;/li&gt;\n&lt;li&gt;如1、2所说的情况排除在外的条件下，跨域请求是，浏览器支持的Content-Type值为application/x-www-form-urlencoded，multipart/form-data和text/plain。如果是其他数据类型(如application/json,text/xml...)，那么将触发预检请求。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;关于position定位下列说法正确的是\&#34;&gt;关于position定位，下列说法正确的是&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;relative，absolute, fixed都会脱离当前文档流，并相对于当前位置设置偏移量&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;absolute元素如果其父级设置了fixed属性，则其会相对于浏览器窗口设置偏移&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;z-index属性对元素position属性为relative，absolute, fixed都可以做层级设置&lt;/code&gt;&lt;/strong&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;&lt;code&gt;relative元素以它原来的位置为基准偏移，在其移动后，原来的位置不再占据空间&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;absolute的元素，如果它的父容器设置了position属性，并且position的属性值为absolute或者relative，那么就会依据父容器进行偏移&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;relative元素以它原来的位置为基准偏移，在其移动后，原来的位置不再占据空间&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;fixed元素，可定位于相对于浏览器窗口的指定坐标，它始终是以 body 为依据&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;relative元素是参照父级的原始点为原始点，无父级则以BODY的原始点为原始点，配合TOP、RIGHT、BOTTOM、LEFT进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;absolute:只有上级标签有position：absolute/relative属性，才能作为它的父级，否则以body为参考;&lt;br&gt;\nrelative:偏移的top，right，bottom，left 的值都以它原来的位置为基准偏移，移动后的元素在原来的位置仍会占空间；&lt;/p&gt;\n&lt;p&gt;设置了fixed属性的元素，才是相对于视口进行定位偏移的，&lt;/p&gt;\n&lt;p&gt;设置了absolute属性的元素，是以离他最近的开启定位的祖先元素为基准，进行偏移。&lt;/p&gt;\n&lt;p&gt;这里在fixed元素中的absolute元素，会相对于fixed元素进行定位偏移，不是视口&lt;/p&gt;\n&lt;h2 id=\&#34;请选择console打印的正确值\&#34;&gt;请选择console打印的正确值&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;Object.prototype.foo = &#39;Object&#39;;\nFunction.prototype.foo = &#39;Function&#39;;\nfunction Animal () {};\nvar cat = new Animal();\nconsole.log(cat.foo);\nconsole.log(Animal.foo);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;Object Function&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;构造函数Animal是由 new Function() 创建的一个对象，因此Animal的__proto__属性指向的是Function.prototype；又因函数本身又是一个对象，因此Animal.prototype是指向Object.prototype;cat是由Animal创建出来的实例，cat.__proto__指向Animal.prototype.&lt;/p&gt;\n&lt;h2 id=\&#34;下列哪个属性不会引起浏览器重排reflow\&#34;&gt;下列哪个属性不会引起浏览器重排（reflow）:&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt; @**keyframes** animate {\n    0%{\n        transform: translate(0,0);\n    }\n    25%{\n        transform: translate(200px,0);\n    }\n    50%{\n        transform: translate(200px,200px);\n    }\n    75%{\n        transform: translate(0,200px);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;.hide {\n    visibility:hidden;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;回流：当render tree 的一部分或全部的元素因改变了自身的&lt;strong&gt;宽高，布局，显示或隐藏&lt;/strong&gt;，或者元素内部的文字结构发生变化 导致需要重新构建页面的时候，回流就产生了。&lt;/li&gt;\n&lt;li&gt;重绘：当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的&lt;strong&gt;外观风格&lt;/strong&gt;的时候，就会产生重绘。例如你改变了元素的background-color....&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;回流必将引起重绘，而重绘不一定会引起回流。&lt;/p&gt;\n&lt;h2 id=\&#34;下列会导致页面回流reflow的操作有\&#34;&gt;下列会导致页面回流reflow的操作有&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;添加或者删除可见的DOM元素&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;仅修改DOM元素的字体颜色、背景色&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;resize浏览器窗口&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;设置可见元素为display: none&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;读取元素的属性offsetWidth和offsetHeight&lt;/code&gt; ✓&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;添加或者删除可见的DOM元素；&lt;/li&gt;\n&lt;li&gt;元素位置改变；&lt;/li&gt;\n&lt;li&gt;元素尺寸改变——边距、填充、边框、宽度和高度&lt;/li&gt;\n&lt;li&gt;内容变化，比如用户在input框中输入文字，文本或者图片大小改变而引起的计算值宽度和高度改变&lt;/li&gt;\n&lt;li&gt;页面渲染初始化&lt;/li&gt;\n&lt;li&gt;浏览器窗口尺寸改变——resize事件发生时&lt;/li&gt;\n&lt;li&gt;计算 offsetWidth 和 offsetHeight 属性&lt;/li&gt;\n&lt;li&gt;设置 style 属性的值&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;关于javascript以下选项描述错误的是\&#34;&gt;关于javascript，以下选项描述错误的是&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;在原型上扩展的可枚举方法，会被for in循环出来&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;通过hasOwnProperty可判断一个对象以及其原型链上是否具有指定名称的属性&lt;/code&gt; x&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;每个函数对象都有prototype属性，返回对象类型原型的引用&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;For循环是按顺序的，for in 循环是不一定按顺序的&lt;/code&gt; x&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;for...of 循环可遍历普通对象，如{a:&#39;1&#39;, b:2}&lt;/code&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;所有继承了 &lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object\&#34;&gt;Object&lt;/a&gt; 的对象都会继承到 hasOwnProperty 方法。这个方法可以用来检测一个对象是否含有特定的自身属性；和 &lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in\&#34;&gt;in&lt;/a&gt; 运算符不同，该方法忽略掉那些从原型链上继承到的属性。&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in\&#34;&gt;for...in&lt;/a&gt; 语句以任意顺序迭代对象的&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\&#34;&gt;可枚举属性&lt;/a&gt;。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;for...of语句&lt;/strong&gt;在&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols\&#34;&gt;可迭代对象&lt;/a&gt; 上创建一个迭代循环，目前所有的内置可迭代对象如下：&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\&#34;&gt;String&lt;/a&gt;、&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\&#34;&gt;Array&lt;/a&gt;、&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray\&#34;&gt;TypedArray&lt;/a&gt;、&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map\&#34;&gt;Map&lt;/a&gt; 和 &lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set\&#34;&gt;Set&lt;/a&gt;，它们的原型对象都实现了 @@iterator 方法。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;for...in语句&lt;/strong&gt;以任意顺序遍历一个对象的除&lt;a href=\&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\&#34;&gt;Symbol&lt;/a&gt;以外的&lt;a href=\&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\&#34;&gt;可枚举&lt;/a&gt;属性，包括继承的可枚举属性。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;下列关于js事件的描述中正确的有\&#34;&gt;下列关于js事件的描述中，正确的有&lt;/h2&gt;\n&lt;p&gt;**&lt;code&gt;事件冒泡**是指当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;**&lt;code&gt;不支持冒泡的事件有**blur、focus、load、resize、mouseleave&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;事件委托不依赖于事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;通过addEventListener方法给Dom添加事件监听，addEventListener形参中的第三个参数控制是捕获传递触发还是冒泡传递触发。&lt;/code&gt; ✓&lt;/p&gt;\n&lt;h2 id=\&#34;css中哪些属性可以继承\&#34;&gt;&lt;strong&gt;css中哪些属性可以继承&lt;/strong&gt;&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;font-size&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;margin&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;border&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;color&lt;/code&gt; ✓&lt;/p&gt;\n&lt;p&gt;1、字体系列属性&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;font：组合字体&lt;/li&gt;\n&lt;li&gt;font-family：规定元素的字体系列&lt;/li&gt;\n&lt;li&gt;font-weight：设置字体的粗细&lt;/li&gt;\n&lt;li&gt;font-size：设置字体的尺寸&lt;/li&gt;\n&lt;li&gt;font-style：定义字体的风格&lt;/li&gt;\n&lt;li&gt;font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。&lt;/li&gt;\n&lt;li&gt;font-stretch：允许你使文字变宽或变窄。所有主流浏览器都不支持。&lt;/li&gt;\n&lt;li&gt;font-size-adjust：为某个元素规定一个 aspect 值，字体的小写字母 &amp;quot;x&amp;quot; 的高度与&amp;quot;font-size&amp;quot; 高度之间的比率被称为一个字体的 aspect 值。这样就可以保持首选字体的 x-height。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;2、文本系列属性&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;text-indent：文本缩进&lt;/li&gt;\n&lt;li&gt;text-align：文本水平对齐&lt;/li&gt;\n&lt;li&gt;line-height：行高&lt;/li&gt;\n&lt;li&gt;word-spacing：增加或减少单词间的空白（即字间隔）&lt;/li&gt;\n&lt;li&gt;letter-spacing：增加或减少字符间的空白（字符间距）&lt;/li&gt;\n&lt;li&gt;text-transform：控制文本大小写&lt;/li&gt;\n&lt;li&gt;direction：规定文本的书写方向&lt;/li&gt;\n&lt;li&gt;color：文本颜色&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;3、元素可见性：visibility&lt;/p&gt;\n&lt;p&gt;4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout&lt;/p&gt;\n&lt;p&gt;5、列表属性：list-style-type、list-style-image、list-style-position、list-style&lt;/p&gt;\n&lt;p&gt;6、生成内容属性：quotes&lt;/p&gt;\n&lt;p&gt;7、光标属性：cursor&lt;/p&gt;\n&lt;p&gt;8、页面样式属性：page、page-break-inside、windows、orphans&lt;/p&gt;\n&lt;p&gt;9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation&lt;/p&gt;\n&lt;p&gt;所有元素可以继承的属性：&lt;/p&gt;\n&lt;p&gt;1、元素可见性：visibility、opacity2、光标属性：cursor&lt;/p&gt;\n&lt;p&gt;内联元素可以继承的属性:&lt;/p&gt;\n&lt;p&gt;1、字体系列属性2、除text-indent、text-align之外的文本系列属性&lt;/p&gt;\n&lt;p&gt;块级元素可以继承的属性:&lt;/p&gt;\n&lt;p&gt;1、text-indent、text-align&lt;/p&gt;\n&lt;h2 id=\&#34;请选择结果为真的表达式\&#34;&gt;请选择结果为真的表达式&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;null == undefined&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;undefined === undefined&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;null == null&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;null === null&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;=== 判断规则&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;如果类型不同，就[不相等]&lt;/li&gt;\n&lt;li&gt;如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断）&lt;/li&gt;\n&lt;li&gt;如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。&lt;/li&gt;\n&lt;li&gt;如果两个值都是true，或者都是false，那么[相等]。&lt;/li&gt;\n&lt;li&gt;如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。&lt;/li&gt;\n&lt;li&gt;如果两个值都是null，或者都是undefined，那么[相等]。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;== 判断规则：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;如果两个值类型相同，进行 === 比较。&lt;/li&gt;\n&lt;li&gt;如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;如果一个是null、一个是undefined，那么[相等]。&lt;/li&gt;\n&lt;li&gt;如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。&lt;/li&gt;\n&lt;li&gt;如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。&lt;/li&gt;\n&lt;li&gt;如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。&lt;/li&gt;\n&lt;li&gt;任何其他组合，都[不相等]。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;实现一个函数输入一个字符串返回该字符串出现最多的字母\&#34;&gt;实现一个函数，输入一个字符串，返回该字符串出现最多的字母&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;const fn = (str) =&amp;gt; {\n    let obj = {};\n    for (let i=0;i&amp;lt;str.length;i++){\n        if (!obj[str[i]]) obj[str[i]] = 1;\n        else obj[str[i]]++;\n    }\n    let maxItem = 0;\n    let index = 0;\n    for (item in obj) {\n        if (obj[item]&amp;gt;maxItem){\n            maxItem = obj[item];\n            index = item\n        } \n    }\n    return index;\n}\nvar arr = readline().split(&#39;,&#39;);\nconsole.log(fn(arr[0]));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;编写查询函数返回数字字符串中最大的公共前缀字符串\&#34;&gt;编写查询函数返回数字字符串中最大的公共前缀字符串&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;var arr = readline().split(&#39;,&#39;);\nconst maxStr = (arr) =&amp;gt; {\n  let longest = arr[0];\n  for (let i = 1; i &amp;lt; arr.length; i++) {\n    for (let j = 0; j &amp;lt; Math.min(longest.length, arr[i].length); j++) {\n      if (longest[j] != arr[i][j]) {\n        longest = longest.slice(0,j);\n      }\n    }\n  }\n  return longest;\n};\nconsole.log(maxStr(arr))\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;o_m2XgTX-&#34;,&#34;abstract&#34;:&#34;&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;console.log([1,2,3,4,5].splice(1,2,3,4,5));\nconsole.log([1,2,3,4,5].slice(1,2,3,4,5));\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;以下代码输出&lt;br&gt;\n&lt;code&gt;[2,3]和[2]&lt;/code&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;58同城2021校招笔试部分题目及讲解&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;前端&#34;,&#34;slug&#34;:&#34;fQqcR7eLj&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/fQqcR7eLj/&#34;},{&#34;name&#34;:&#34;校招&#34;,&#34;slug&#34;:&#34;I7pdcejcBQ&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/I7pdcejcBQ/&#34;},{&#34;name&#34;:&#34;面经&#34;,&#34;slug&#34;:&#34;IXp-Jzyfp-&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/IXp-Jzyfp-/&#34;}],&#34;date&#34;:&#34;2022-03-08 23:47:39&#34;,&#34;dateFormat&#34;:&#34;2022-03-08&#34;,&#34;feature&#34;:&#34;https://www.hualigs.cn/image/62d943407d73b.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/o_m2XgTX-/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;16 min read&#34;,&#34;time&#34;:923000,&#34;words&#34;:4010,&#34;minutes&#34;:16},&#34;description&#34;:&#34;console.log([1,2,3,4,5].splice(1,2,3,4,5));\nconsole.log([1,2,3,4,5].slice(1,2,3,4,5));\n\n以下代码输出\n[2,3]和[2]\n\nsplice与slice区别...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#splice%E4%B8%8Eslice%E5%8C%BA%E5%88%AB\&#34;&gt;splice与slice区别&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#root%E5%85%83%E7%B4%A0%E7%9A%84%E9%AB%98-%E9%80%9A%E8%BF%87getcomputedstylerootheight%E8%AE%A1%E7%AE%97-%E4%B8%BA\&#34;&gt;root元素的高 (通过getComputedStyle(root).height计算) 为？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#bfcblock-formatting-context%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%8A%E4%B8%8B%E6%96%87%E6%98%AFweb%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%B8%83%E5%B1%80%E7%9A%84css%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F%E6%8C%87%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E6%B8%B2%E6%9F%93%E5%8C%BA%E5%9F%9F%E6%88%96%E8%80%85%E8%AF%B4%E6%98%AF%E4%B8%80%E4%B8%AA%E9%9A%94%E7%A6%BB%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%AE%B9%E5%99%A8-%E5%BD%A2%E6%88%90bfc%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%9C%89\&#34;&gt;BFC（Block Formatting Context）格式化上下文，是Web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域或者说是一个隔离的独立容器。&lt;strong&gt;形成BFC的条件有&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E8%BE%B9%E5%85%B3%E4%BA%8Ehttps%E6%8F%8F%E8%BF%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF\&#34;&gt;下边关于https描述正确的是:&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E8%BE%B9%E5%85%B3%E4%BA%8Exss%E6%8F%8F%E8%BF%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF\&#34;&gt;下边关于XSS描述正确的是&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A5%E4%B8%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C\&#34;&gt;以下运行结果:&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A8%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E4%B8%AD%E4%B8%8B%E5%88%97%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E5%93%AA%E7%A7%8Dcontent-type%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%A7%A6%E5%8F%91cors%E9%A2%84%E6%A3%80%E6%9F%A5\&#34;&gt;在跨域请求中，下列请求头中哪种content-type一定会触发cors预检查&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8Eposition%E5%AE%9A%E4%BD%8D%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF\&#34;&gt;关于position定位，下列说法正确的是&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%B7%E9%80%89%E6%8B%A9console%E6%89%93%E5%8D%B0%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%80%BC\&#34;&gt;请选择console打印的正确值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E5%88%97%E5%93%AA%E4%B8%AA%E5%B1%9E%E6%80%A7%E4%B8%8D%E4%BC%9A%E5%BC%95%E8%B5%B7%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E6%8E%92reflow\&#34;&gt;下列哪个属性不会引起浏览器重排（reflow）:&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E5%88%97%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%A1%B5%E9%9D%A2%E5%9B%9E%E6%B5%81reflow%E7%9A%84%E6%93%8D%E4%BD%9C%E6%9C%89\&#34;&gt;下列会导致页面回流reflow的操作有&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8Ejavascript%E4%BB%A5%E4%B8%8B%E9%80%89%E9%A1%B9%E6%8F%8F%E8%BF%B0%E9%94%99%E8%AF%AF%E7%9A%84%E6%98%AF\&#34;&gt;关于javascript，以下选项描述错误的是&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E5%88%97%E5%85%B3%E4%BA%8Ejs%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%AD%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%9C%89\&#34;&gt;下列关于js事件的描述中，正确的有&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#css%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF\&#34;&gt;&lt;strong&gt;css中哪些属性可以继承&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%B7%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%9C%E4%B8%BA%E7%9C%9F%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F\&#34;&gt;请选择结果为真的表达式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%94%E5%9B%9E%E8%AF%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%97%E6%AF%8D\&#34;&gt;实现一个函数，输入一个字符串，返回该字符串出现最多的字母&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E5%86%99%E6%9F%A5%E8%AF%A2%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E5%AD%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%E5%AD%97%E7%AC%A6%E4%B8%B2\&#34;&gt;编写查询函数返回数字字符串中最大的公共前缀字符串&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;1掌握盒子水平垂直居中的五大方案\&#34;&gt;1.掌握盒子水平垂直居中的五大方案&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;定位：三种&lt;/li&gt;\n&lt;li&gt;display:flex&lt;/li&gt;\n&lt;li&gt;JavaScript&lt;/li&gt;\n&lt;li&gt;display:table-cell&lt;/li&gt;\n&lt;/ul&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;问：盒子水平和垂直居中怎么来实现？&lt;/p&gt;\n&lt;p&gt;答：这个这种需求的话其实在我之前项目当中是非常常见的，刚开始我只用这种这种方法，后来随着Css3的一个兴起，然后这种flex方式其实特别方便，尤其在移动端开发的时候来实现，它的话特别强大对吧？然后那个有一段时间我自己去看掘金，看博客的时候发现，这种方案虽然不常用，但是也能实现，我感觉挺好玩的，所以我就记下来了。&lt;/p&gt;\n&lt;h3 id=\&#34;定位方式\&#34;&gt;定位方式:&lt;/h3&gt;\n&lt;p&gt;最开始实现的方案的话，其实我们都用这种方案叫定位的方式最开始实现的方案的话，其实我们都用这种方案叫定位的方式&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;body {\n\t\t/* 让盒子相对父级定位 */\n\t\tposition: relative;\t\n\t}\n\n.box {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\t/* 盒子左上角在页面居中，通过盒子长宽调整到中间居中 */\n\t\t\tmargin-top: -25px;\n\t\t\tmargin-left: -50px;\n\t}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;宽高自适应的定位方式\&#34;&gt;宽高自适应的定位方式:&lt;/h3&gt;\n&lt;p&gt;或者说我的宽和高，不知道具体宽高的情况下，前提是有宽高。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.box {\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t\tmargin: auto;\n\t}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;利用css3控制形变位移实现\&#34;&gt;利用CSS3控制形变位移实现：&lt;/h3&gt;\n&lt;p&gt;不需要设置宽度和高度，能够随着内容变化自适应。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.box {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\ttransform: translate(-50%, -50%);\t\n\t}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;不通过定位方式来实现\&#34;&gt;不通过定位方式来实现：&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;body {\n\t\t\tdisplay: flex;\n\t\t\tjustify-content: center;\n\t\t\talign-items: center;\n\t}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;jsts方法实现\&#34;&gt;JS/TS方法实现&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-jsx\&#34;&gt;let HTML = document.documentElement,\n\t\t\twinW = HTML.clientWidth,\n\t\t\twinH = HTML.clientHeight,\n\t\t\tboxW = box.offsetWidth,\n\t\t\tboxH = box.offsetHeight;\n\t\tbox.style.position = &amp;quot;absolute&amp;quot;;\n\t\tbox.style.left = (winW - boxW) / 2 + &#39;px&#39;;\n\t\tbox.style.top = (winH - boxH) / 2 + &#39;px&#39;;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;table方法实现\&#34;&gt;table方法实现&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;body {\n\t\t\tdisplay: table-cell;\n\t\t\tvertical-align: middle;\n\t\t\ttext-align: center;\n\t\t\t/* 固定宽高 */\n\t\t\twidth: 500px;\n\t\t\theight: 500px;\n\t\t}\n\n.box {\n\tdisplay: inline-block;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-css3中盒模型\&#34;&gt;2. CSS3中盒模型&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2570c44.jpg\&#34; alt=\&#34;标准盒模型\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c255eb4f.jpg\&#34; alt=\&#34;IE盒模型\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c249131f.jpg\&#34; alt=\&#34;Flex弹性伸缩盒模型\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;问：css3中有哪些盒模型？&lt;/p&gt;\n&lt;p&gt;答：标准盒模型和 IE 盒模型也叫怪异盒模型，还有flex 弹性伸缩盒模型。&lt;/p&gt;\n&lt;p&gt;问：盒子大小确定&lt;/p&gt;\n&lt;p&gt;答：&lt;/p&gt;\n&lt;p&gt;其实我们最常用的就是标准盒模型，也就是css 中的 contentbox 。它指的是谁呢？width和height 样式，指的是内容的宽度。对吧？并不是盒子最终的宽高。盒子宽高是由我们的内容宽高加上 padding 加上 border 。但这种东西的话在我们真实项目当中可能就会遇到一个问题，什么问题呢？假设然后我想指定一个，我想指我想构建一个 100 乘 100 的这样一个盒子。但是我之前我写的 width和height 是 100 乘100，后来我发现我要给它加个 border 我只要加 border 我不改 width和height 的话咋办？它一定会变大了，这样的话就会折下来了，是不是这样的话不好。那么我还要每改 border 每改 padding 我都要手动改下 width和height 值，还要重新计算，我认为这种方式比较谁麻烦。&lt;br&gt;\n后来 CSS 3 里边给我们提供了一个方式，叫box-sizing=content-box 这也是我们所谓的IE盒模型，能够让我们来控制出使用IE盒模型了。&lt;br&gt;\n这种怪异盒模型里边有个好处，什么好处呢？它里边我们在 width和height 指的是盒子大小，并不是内容的大小。比如说我写 100 乘 100 盒子最终就是谁 100 乘 100 不管我怎么调border的，不管我怎么调 padding，它会自己通过缩放内容来实现整个盒子还是100 乘 100。这样的话我写样的时候干什么比较方便，不用每一次来回算值了是不是？所以我现在在真实项目当中大部分都在应用谁应用我们的box-sizing= content-box这种IE盒模型，包括我看了 boost up 以及各大 UI 组件 element UI 这种组件它的源码里面的一些公共样式，里边大部分也是让盒子默认就采用box-sizing=content-box所以我认为这是我们开发中的一种规范和一种方式&lt;/p&gt;\n&lt;h2 id=\&#34;3-左右固定中间自适应方案布局\&#34;&gt;3. 左右固定，中间自适应方案布局&lt;/h2&gt;\n&lt;h3 id=\&#34;最简单的flex布局\&#34;&gt;最简单的flex布局&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;&amp;lt;style&amp;gt;\n.container {\n\t\t\tdisplay: flex;\n\t\t\tjustify-content: space-between;\n}\n\n.left,\n.right {\n\tflex:0 0 200px;\n}\n\n.center {\n\tflex:1;\n}\n&amp;lt;/style&amp;gt;\n\n&amp;lt;div class=&amp;quot;container clearfix&amp;quot;&amp;gt;\n    &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;/div&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;定位方法\&#34;&gt;定位方法&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;&amp;lt;style&amp;gt;\n.container {\n\t\t\tposition: relateive;\n}\n\n.left,\n.right {\n\t\t\tposition: absolute;\n}\n.left {\n\t\t\tleft: 0;\n}\n.right {\n\t\t\tright: 0;\n}\n.center {\n\t\t\tmargin: 0 200px;\n}\n&amp;lt;/style&amp;gt;\n\n&amp;lt;div class=&amp;quot;container clearfix&amp;quot;&amp;gt;\n    &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;/div&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;圣杯布局浮动和负margin\&#34;&gt;&lt;strong&gt;圣杯布局：浮动和负MARGIN&lt;/strong&gt;&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;&amp;lt;style&amp;gt;\n    html,\n    body {\n        height: 100%;\n        overflow: hidden;\n    }\n\n    .container {\n        height: 100%;\n        padding: 0 200px;\n    }\n\n    .left,\n    .right {\n        width: 200px;\n        min-height: 200px;\n        background: lightblue;\n    }\n\n    .center {\n        width: 100%;\n        min-height: 400px;\n        background: lightsalmon;\n    }\n\n    .left,\n    .center,\n    .right {\n        float: left;\n    }\n\n    .left {\n        margin-left: -100%;\n        position: relative;\n        left: -200px;\n    }\n\n    .right {\n        margin-right: -200px;\n    }\n&amp;lt;/style&amp;gt;\n\n&amp;lt;div class=&amp;quot;container clearfix&amp;quot;&amp;gt;\n    &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;/div&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;strong&gt;双飞翼布局：浮动和负MARGIN&lt;/strong&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;&amp;lt;style&amp;gt;\n    html,\n    body {\n        height: 100%;\n        overflow: hidden;\n    }\n\n    .container,\n    .left,\n    .right {\n        float: left;\n    }\n\n    .container {\n        width: 100%;\n    }\n\n    .container .center {\n        margin: 0 200px;\n        min-height: 400px;\n        background: lightsalmon;\n    }\n\n    .left,\n    .right {\n        width: 200px;\n        min-height: 200px;\n        background: lightblue;\n    }\n\n    .left {\n        margin-left: -100%;\n    }\n\n    .right {\n        margin-left: -200px;\n    }\n&amp;lt;/style&amp;gt;\n\n&amp;lt;body class=&amp;quot;clearfix&amp;quot;&amp;gt;\n    &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;\n        &amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;left&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n    &amp;lt;div class=&amp;quot;right&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;\n&amp;lt;/body&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;4-让元素div消失在视野中\&#34;&gt;4. 让元素div消失在视野中&lt;/h2&gt;\n&lt;p&gt;1.position:absolute/relative/fixed  +  方位 top/bottom/left/right: -9999px&lt;br&gt;\n2.display:none&lt;br&gt;\n3.visibility:hidden&lt;br&gt;\n4.width:0 + overflow:hidden&lt;br&gt;\nheight:0 +  overflow:hidden&lt;br&gt;\n5.margin-top/bottom/left/right:-9999px;&lt;br&gt;\n6.background-color:transparent&lt;br&gt;\n7.opacity:0&lt;br&gt;\n8.transform: translateX(-9999px)/translateY(-9999px)/translate(-9999px,-9999px)&lt;br&gt;\n9.transform: scale(0)&lt;/p&gt;\n&lt;h2 id=\&#34;5-请说明z-index的工作原理适用范围\&#34;&gt;5. 请说明z-index的工作原理,适用范围?&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;z-index这个属性控制着元素在z轴上的表现形式。&lt;/li&gt;\n&lt;li&gt;适用范围:仅适用于定位元素，即拥有relative,absolute,fixed属性的position元素。&lt;/li&gt;\n&lt;li&gt;堆叠顺序是当前元素位于z轴上的值，数值越大说明元素的堆叠1顺序越高，越靠近屏幕。&lt;/li&gt;\n&lt;li&gt;未定义时，后来居上，未定义z-index的属性，元素的堆叠顺序基于它所在的文档树。默认情况下，后来的元素的z-index的值越大。&lt;/li&gt;\n&lt;li&gt;使用范围：&lt;/li&gt;\n&lt;/ol&gt;\n&lt;ul&gt;\n&lt;li&gt;网页两侧的浮动窗口（播放器，指定按钮，广告等）&lt;/li&gt;\n&lt;li&gt;导航栏浮动值顶&lt;/li&gt;\n&lt;li&gt;隐藏div实现弹窗功能（通过设置div定位和z-index控制div的位置和出现隐藏）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;6-谈谈你对html5的理解\&#34;&gt;6. 谈谈你对html5的理解&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;语义化标签类&lt;/li&gt;\n&lt;li&gt;音视频处理&lt;/li&gt;\n&lt;li&gt;canvas / webGL&lt;/li&gt;\n&lt;li&gt;history API&lt;/li&gt;\n&lt;li&gt;requestAnimationFrame&lt;/li&gt;\n&lt;li&gt;地理位置&lt;/li&gt;\n&lt;li&gt;web scoket&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;7-如何使一个div里面的文字垂直居中且该文字的大小根据屏幕大小自适应\&#34;&gt;7. &lt;strong&gt;&lt;strong&gt;如何使一个div里面的文字垂直居中，且该文字的大小根据屏幕大小自适应？&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;\n&lt;h3 id=\&#34;垂直居中\&#34;&gt;垂直居中：&lt;/h3&gt;\n&lt;p&gt;行高法：文字行高和容器相同&lt;/p&gt;\n&lt;p&gt;内边距法: 利用padding将内容垂直居中&lt;/p&gt;\n&lt;p&gt;模拟表格法：将容器设置为display:table，然后将子元素也就是要垂直居中显示的元素设置为display:table-cell，然后加上vertical-align:middle来实现。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-html\&#34;&gt;&amp;lt;div id=&amp;quot;wrapper&amp;quot;&amp;gt;\n    &amp;lt;div id=&amp;quot;cell&amp;quot;&amp;gt;\n        &amp;lt;p&amp;gt;测试垂直居中效果测试垂直居中效果&amp;lt;/p&amp;gt;\n        &amp;lt;p&amp;gt;测试垂直居中效果测试垂直居中效果&amp;lt;/p&amp;gt;\n    &amp;lt;/div&amp;gt;\n&amp;lt;/div&amp;gt;\n&amp;lt;style&amp;gt;\n#wrapper {display:table;}\n#cell{display:table-cell; vertical-align:middle;}\n&amp;lt;/style&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;CSS3 flex&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-html\&#34;&gt;&amp;lt;div class=&amp;quot;flex&amp;quot;&amp;gt;\n    &amp;lt;div&amp;gt;\n       &amp;lt;p&amp;gt;我是多行文字我是多行文字我是多行文字我是多行文字&amp;lt;/p&amp;gt;\n      &amp;lt;p&amp;gt;我是多行文字我是多行文字我是多行文字我是多行文字&amp;lt;/p&amp;gt;\n    &amp;lt;/div&amp;gt;\n&amp;lt;/div&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.flex{\n    /*flex 布局*/\n    display: flex;\n    /*实现垂直居中*/\n    align-items: center;\n    /*实现水平居中*/\n    justify-content: center;\n    text-align: justify;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;CSS3 transform&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.center-vertical{\n  position: relative;\n  top:50%;\n  transform:translateY(-50%);\n}.center-horizontal{\n  position: relative;\n  left:50%;\n  transform:translateX(-50%); \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;CSS3 box&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-html\&#34;&gt;&amp;lt;div class=&amp;quot;center&amp;quot;&amp;gt;\n  &amp;lt;div class=&amp;quot;text&amp;quot;&amp;gt;\n    &amp;lt;p&amp;gt;我是多行文字&amp;lt;/p&amp;gt;\n    &amp;lt;p&amp;gt;我是多行文字&amp;lt;/p&amp;gt;\n    &amp;lt;p&amp;gt;我是多行文字&amp;lt;/p&amp;gt;\n  &amp;lt;/div&amp;gt;\n&amp;lt;/div&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.center {\n  width: 300px;\n  height: 200px;\n  padding: 10px;\n  border: 1px solid #ccc;\n  background:#000;\n  color:#fff;\n  margin: 20px auto;\n  display: -webkit-box;\n  -webkit-box-orient: horizontal;\n  -webkit-box-pack: center;\n  -webkit-box-align: center;\n  \n  display: -moz-box;\n  -moz-box-orient: horizontal;\n  -moz-box-pack: center;\n  -moz-box-align: center;\n  \n  display: -o-box;\n  -o-box-orient: horizontal;\n  -o-box-pack: center;\n  -o-box-align: center;\n  \n  display: -ms-box;\n  -ms-box-orient: horizontal;\n  -ms-box-pack: center;\n  -ms-box-align: center;\n  \n  display: box;\n  box-orient: horizontal;\n  box-pack: center;\n  box-align: center;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;文字大小自适应\&#34;&gt;文字大小自适应：&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;p {\nfont-size: 36px;\n}\n@media (max-width: 1000px) {\n  p {\n    font-size: 30px;\n  }\n}\n\n@media (max-width: 800px) {\n  p {\n    font-size: 24px;\n  }\n}\n\n@media (max-width: 600px) {\n  p {\n    font-size: 18px;\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;8-不考虑其它因素下面哪种的渲染性能比较高\&#34;&gt;8. 不考虑其它因素，下面哪种的渲染性能比较高？&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-css\&#34;&gt;.box a{\n    ...\n}\n\na{\n    ...\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;第二个：CSS 的浏览器渲染机制是选择器从右向左查询，所以说遇到div的话就只找所有的 div 查找层级。浏览器渲染机制是先找所有 a 再找 box 下所有的 a，它进行了二次筛选，所以第一个的性能要比第二个慢。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;XQaMLq3pa&#34;,&#34;abstract&#34;:&#34;&lt;h2 id=\&#34;1掌握盒子水平垂直居中的五大方案\&#34;&gt;1.掌握盒子水平垂直居中的五大方案&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;定位：三种&lt;/li&gt;\n&lt;li&gt;display:flex&lt;/li&gt;\n&lt;li&gt;JavaScript&lt;/li&gt;\n&lt;li&gt;display:table-cell&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;title&#34;:&#34;CSS常见面试&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;css&#34;,&#34;slug&#34;:&#34;n0wFTqvoB&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/n0wFTqvoB/&#34;},{&#34;name&#34;:&#34;vue&#34;,&#34;slug&#34;:&#34;ToYFD13Rv&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/ToYFD13Rv/&#34;}],&#34;date&#34;:&#34;2022-03-04 10:38:50&#34;,&#34;dateFormat&#34;:&#34;2022-03-04&#34;,&#34;feature&#34;:&#34;https://www.hualigs.cn/image/62d943812c908.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/XQaMLq3pa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;11 min read&#34;,&#34;time&#34;:608000,&#34;words&#34;:2293,&#34;minutes&#34;:11},&#34;description&#34;:&#34;1.掌握盒子水平垂直居中的五大方案\n\n定位：三种\ndisplay:flex\nJavaScript\ndisplay:table-cell\n\n\n问：盒子水平和垂直居中怎么来实现？\n答：这个这种需求的话其实在我之前项目当中是非常常见的，刚开始我只...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E6%8E%8C%E6%8F%A1%E7%9B%92%E5%AD%90%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E4%BA%94%E5%A4%A7%E6%96%B9%E6%A1%88\&#34;&gt;1.掌握盒子水平垂直居中的五大方案&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F\&#34;&gt;定位方式:&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%BD%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F\&#34;&gt;宽高自适应的定位方式:&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A9%E7%94%A8css3%E6%8E%A7%E5%88%B6%E5%BD%A2%E5%8F%98%E4%BD%8D%E7%A7%BB%E5%AE%9E%E7%8E%B0\&#34;&gt;利用CSS3控制形变位移实现：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8D%E9%80%9A%E8%BF%87%E5%AE%9A%E4%BD%8D%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%AE%9E%E7%8E%B0\&#34;&gt;不通过定位方式来实现：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#jsts%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0\&#34;&gt;JS/TS方法实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#table%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0\&#34;&gt;table方法实现&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-css3%E4%B8%AD%E7%9B%92%E6%A8%A1%E5%9E%8B\&#34;&gt;2. CSS3中盒模型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E5%B7%A6%E5%8F%B3%E5%9B%BA%E5%AE%9A%E4%B8%AD%E9%97%B4%E8%87%AA%E9%80%82%E5%BA%94%E6%96%B9%E6%A1%88%E5%B8%83%E5%B1%80\&#34;&gt;3. 左右固定，中间自适应方案布局&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84flex%E5%B8%83%E5%B1%80\&#34;&gt;最简单的flex布局&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95\&#34;&gt;定位方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E6%B5%AE%E5%8A%A8%E5%92%8C%E8%B4%9Fmargin\&#34;&gt;&lt;strong&gt;圣杯布局：浮动和负MARGIN&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E8%AE%A9%E5%85%83%E7%B4%A0div%E6%B6%88%E5%A4%B1%E5%9C%A8%E8%A7%86%E9%87%8E%E4%B8%AD\&#34;&gt;4. 让元素div消失在视野中&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5-%E8%AF%B7%E8%AF%B4%E6%98%8Ez-index%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4\&#34;&gt;5. 请说明z-index的工作原理,适用范围?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9html5%E7%9A%84%E7%90%86%E8%A7%A3\&#34;&gt;6. 谈谈你对html5的理解&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#7-%E5%A6%82%E4%BD%95%E4%BD%BF%E4%B8%80%E4%B8%AAdiv%E9%87%8C%E9%9D%A2%E7%9A%84%E6%96%87%E5%AD%97%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E4%B8%94%E8%AF%A5%E6%96%87%E5%AD%97%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%A0%B9%E6%8D%AE%E5%B1%8F%E5%B9%95%E5%A4%A7%E5%B0%8F%E8%87%AA%E9%80%82%E5%BA%94\&#34;&gt;7. &lt;strong&gt;&lt;strong&gt;如何使一个div里面的文字垂直居中，且该文字的大小根据屏幕大小自适应？&lt;/strong&gt;&lt;/strong&gt;&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD\&#34;&gt;垂直居中：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%87%E5%AD%97%E5%A4%A7%E5%B0%8F%E8%87%AA%E9%80%82%E5%BA%94\&#34;&gt;文字大小自适应：&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#8-%E4%B8%8D%E8%80%83%E8%99%91%E5%85%B6%E5%AE%83%E5%9B%A0%E7%B4%A0%E4%B8%8B%E9%9D%A2%E5%93%AA%E7%A7%8D%E7%9A%84%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E9%AB%98\&#34;&gt;8. 不考虑其它因素，下面哪种的渲染性能比较高？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c250b485.jpg\&#34; alt=\&#34;思维导图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;缺乏正向反馈\&#34;&gt;缺乏「正向反馈」&lt;/h1&gt;\n&lt;p&gt;在我们的大脑中，有一个叫做「奖励系统」的东西，其中包括了前额叶(主要掌管规划和决策)，还有一个叫伏隔核(主要是用来感知愉悦)，最后一个是中脑的一块区域，主要用来分泌多巴胺。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;重点说一下多巴胺，它是一种神经传导物质，当多巴胺分泌传导之后，我们的大脑就会产生愉悦的感受，而这一发现也获得了2000年的诺贝尔医学奖。&lt;br&gt;\n而我们提到的抖音上瘾，其实就是因为我们在看一个个小视频的时候，会&lt;strong&gt;让大脑大量分泌多巴胺，让我们出现强烈的愉悦感&lt;/strong&gt;，这种愉悦感就会让我们完全停不不来。&lt;/p&gt;\n&lt;h2 id=\&#34;为什么向目标努力时无法上瘾\&#34;&gt;为什么向目标努力时无法上瘾&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;朝着目标努力的过程中，正向反馈的频率太低了。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;努力的过程中，负向反馈反而更多。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;做一个行为设计专家让自律上瘾\&#34;&gt;做一个行为设计专家，让自律上瘾&lt;/h1&gt;\n&lt;p&gt;人的行为是可以设计的，当我们&lt;strong&gt;提前设计好激励和奖励措施&lt;/strong&gt;，人就会被这些措施所“摆弄。&lt;/p&gt;\n&lt;p&gt;既然说，行为设计学可以主动地去制造正向反馈，让我们对APP的使用产生依赖，甚至上瘾，那么，同样的对于自律，对于我们去努力实现目标这件事，是不是也可以通过一些设计，设置各种正向反馈，从而实现自律上瘾，让我们更加坚持地去做一件更有意义的事呢?&lt;/p&gt;\n&lt;h2 id=\&#34;如何通过主动设计让我们更容易坚持自律\&#34;&gt;如何通过主动设计，让我们更容易坚持自律?&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;设置可量化的关键结果&lt;/p&gt;\n&lt;p&gt;个人成就反馈体系要求，必须再次重新审视自己的关键结果，是否是可以进行清晰衡量的，而不是那种模棱两可的结果。&lt;br&gt;\n比如，有些同学要复习考试，其中一个关键结果是:“复习完全部教材”。这个关键结果就属于不可量化的。要让这个KR达到一个效果，就是别人拿着你的KR，就可以对你是否完成这项结果，做出准确的判断。&lt;br&gt;\n不然，你说我复习完这本书了，粗看一遍也算复习了，精读一遍也算复习了，这种不清晰的KR，需要再次优化。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;设置量化成就里程碑&lt;/p&gt;\n&lt;p&gt;还是以复习一本书为例，如果有10个章节，那就按照章节划分为5个阶段。比如第1-3章是第一阶段，接着以此类推。&lt;br&gt;\n还有，比如你要减肥20斤，那么每5斤，可以作为你的一个阶段。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;设置奖励机制&lt;/p&gt;\n&lt;p&gt;刚才我们已经设置了成就里程碑，你的每一个KR都进行了细分，接着就是在你的每个里程碑的点，设置一些奖品。&lt;/p&gt;\n&lt;p&gt;第一，要根据自己的经济状况来设置。&lt;br&gt;\n第二，最好设置的奖品能够比平时用的东西高档一点点。&lt;br&gt;\n第三，奖品设置不要过于影响自己的状态。&lt;br&gt;\n第四，奖品设置可以创新。注意，奖品不一定非要给自己买东西呀!你也可以做一些一直想做但没做的事情。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;坚持追踪，持续复盘&lt;/p&gt;\n&lt;p&gt;把奖品设置好之后，接着就需要坚持跟踪进度，持续进行复盘了。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;社群的力量\&#34;&gt;社群的力量&lt;/h2&gt;\n&lt;p&gt;社群之所以为社群，是因为社群会形成一种社交磁力，这种磁力，会成为每一个人向前走的推动力。这些推动力的表现形式，通常都是一种正向反馈。&lt;br&gt;\n一个人走，总会有疲惫的时候，不要过于封闭自己，而是和那些与你志同道合的小伙伴，一起互相给予正向反馈，更好地抱团成长。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;dVEj-wsQc&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c250b485.jpg\&#34; alt=\&#34;思维导图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;缺乏正向反馈\&#34;&gt;缺乏「正向反馈」&lt;/h1&gt;\n&lt;p&gt;在我们的大脑中，有一个叫做「奖励系统」的东西，其中包括了前额叶(主要掌管规划和决策)，还有一个叫伏隔核(主要是用来感知愉悦)，最后一个是中脑的一块区域，主要用来分泌多巴胺。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;如何彻底摆脱三分钟热度?把自律变成一场好玩的游戏!&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;自律&#34;,&#34;slug&#34;:&#34;0oNwEHseg&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/0oNwEHseg/&#34;},{&#34;name&#34;:&#34;正向反馈&#34;,&#34;slug&#34;:&#34;YDMhFeh7QI&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/YDMhFeh7QI/&#34;}],&#34;date&#34;:&#34;2021-11-01 00:41:28&#34;,&#34;dateFormat&#34;:&#34;2021-11-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/dVEj-wsQc/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:200000,&#34;words&#34;:993,&#34;minutes&#34;:4},&#34;description&#34;:&#34;\n缺乏「正向反馈」\n在我们的大脑中，有一个叫做「奖励系统」的东西，其中包括了前额叶(主要掌管规划和决策)，还有一个叫伏隔核(主要是用来感知愉悦)，最后一个是中脑的一块区域，主要用来分泌多巴胺。\n\n重点说一下多巴胺，它是一种神经传导物质，当多...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%BA%E4%B9%8F%E6%AD%A3%E5%90%91%E5%8F%8D%E9%A6%88\&#34;&gt;缺乏「正向反馈」&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%91%E7%9B%AE%E6%A0%87%E5%8A%AA%E5%8A%9B%E6%97%B6%E6%97%A0%E6%B3%95%E4%B8%8A%E7%98%BE\&#34;&gt;为什么向目标努力时无法上瘾&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%81%9A%E4%B8%80%E4%B8%AA%E8%A1%8C%E4%B8%BA%E8%AE%BE%E8%AE%A1%E4%B8%93%E5%AE%B6%E8%AE%A9%E8%87%AA%E5%BE%8B%E4%B8%8A%E7%98%BE\&#34;&gt;做一个行为设计专家，让自律上瘾&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%B8%BB%E5%8A%A8%E8%AE%BE%E8%AE%A1%E8%AE%A9%E6%88%91%E4%BB%AC%E6%9B%B4%E5%AE%B9%E6%98%93%E5%9D%9A%E6%8C%81%E8%87%AA%E5%BE%8B\&#34;&gt;如何通过主动设计，让我们更容易坚持自律?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BE%E7%BE%A4%E7%9A%84%E5%8A%9B%E9%87%8F\&#34;&gt;社群的力量&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2566e89.jpg\&#34; alt=\&#34;思维导图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;设定晨间okr三只青蛙\&#34;&gt;设定晨间OKR三只青蛙&lt;/h1&gt;\n&lt;p&gt;装瓶理论，核心就是说，我们在做事的时候，要&lt;strong&gt;优先利用大块的时间，去处理那些重要的、复杂的事情，也就是那些大石块，然后利用一些间隙去完成那些小事情&lt;/strong&gt;，从而提升我们的整体行动效率。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;每天早上，到了办公室，先思考:今天对于你来说，最重要的三件事是什么，也就是那三只让人感觉很不爽的青蛙，而这些青蛙就相当于我们前面说的大石头。&lt;/p&gt;\n&lt;h1 id=\&#34;种植okr专注森林\&#34;&gt;种植OKR专注森林&lt;/h1&gt;\n&lt;p&gt;如何让自己保持专注的状态，找到所谓「心流」的感觉呢?&lt;br&gt;\n这里给大家介绍一个方法，叫做种植专注森林。其实，跟我们比较熟悉的番茄钟的概念是相似的，但是从个人体验来看，使用种植森林的方式，会更容易让我进入到专注的状态。&lt;/p&gt;\n&lt;p&gt;我来简单介绍一下专注森林或者说番茄钟的理论，一句话来说就是：&lt;strong&gt;一个25分钟的专注时间和5分钟的休息时间组成的工作循环。&lt;/strong&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;掌握吃拿卡要四字诀\&#34;&gt;掌握“吃拿卡要”四字诀&lt;/h1&gt;\n&lt;p&gt;接下来是我们的第三步，也是解决我们在吃青蛙过程中，最容易出现的问题:&lt;strong&gt;那就是被打扰。&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;吃\&#34;&gt;“吃”&lt;/h2&gt;\n&lt;p&gt;当我们在吃青蛙的时候，遇到干扰了，这时候你首先要做一个判断，那就是&lt;strong&gt;这件事是否能够在2分钟之内完成&lt;/strong&gt;。比如，领导让你打电话定一个会议室;同事让你帮他收一个快递;老婆让你给家里买袋米.....诸如此类的事情，它们其实很小，也比较琐碎，算不上重要事务，那么就直接“吃”掉它。所以，“吃”字诀就是:干净利落脆，&lt;strong&gt;2分钟能搞定，赶紧吃掉&lt;/strong&gt;!&lt;/p&gt;\n&lt;h2 id=\&#34;拿\&#34;&gt;“拿”&lt;/h2&gt;\n&lt;p&gt;但是如果这件事没办法2分钟搞定，怎么办呢?先不着急，再做一次判断，那就是&lt;strong&gt;这件事能不能交给别人做&lt;/strong&gt;？&lt;/p&gt;\n&lt;p&gt;有一个时间管理领域的概念，叫做**「甩掉你身上的猴子」**，这里并不是鼓励大家在工作中甩锅，而是要做理性判断。你想，领导为什么把活儿交给你，其实就是把猴子扔在你肩上了，因为他已经做了一次判断，这并不代表，你一定要把这斯重。请们&lt;br&gt;\n个猴子接住。我们要做的，是善于去进行资源优化配置，如果这件事不一定非要你来做，有更好的人选，为什么不把猴子交给别人呢?&lt;/p&gt;\n&lt;h2 id=\&#34;卡\&#34;&gt;“卡”&lt;/h2&gt;\n&lt;p&gt;不要总觉得，只要领导交给你的事，就要第一时间完成，你需要去根据自己的工作进度和状态来做出配置的。&lt;br&gt;\n很多时候，&lt;strong&gt;延后并不是低效和拖延，而是更高效的优化配置&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;所谓的“卡”，就是让自己的工作安排，可以&lt;strong&gt;严格的卡在你的日程表上，在不影响自己核心事务的前提下，来去更好地安排工作&lt;/strong&gt;。&lt;/p&gt;\n&lt;h1 id=\&#34;持续高频复盘追踪\&#34;&gt;持续高频复盘追踪&lt;/h1&gt;\n&lt;p&gt;上节课介绍0KR的时候，我们就提到了，对0KR的进度要进行持续追踪，包括&lt;strong&gt;每周一列0KR的计划，每周末对OKR进行总结分析&lt;/strong&gt;，这个复盘是以周为单位的。&lt;/p&gt;\n&lt;h2 id=\&#34;第一方面是okr在自己心中的不断强化\&#34;&gt;第一方面，是OKR在自己心中的不断强化&lt;/h2&gt;\n&lt;p&gt;就像我们每天设定晨间OKR三只青蛙的时候，不是瞎列的。而是要对照着你的OR，你的周计划，来安排你一天的青蛙的，这个过程，本身就需要你对自己的OKR重新回顾一遍。&lt;br&gt;\n第二天写青蛙的时候，同样需要回顾0KR，第三天也一样....&lt;br&gt;\n我们可以对比一下你以前设定目标的方法，通常是年初写好目标，热血两三天，基本就把目标束之高阁去吃灰了，很多时候，不是我们不想达成目标，是我们早就把目标给忘记了。&lt;/p&gt;\n&lt;p&gt;但是当我们开始使用OKR之后，会强迫着你每天都要对自己的0KR目标回顾一遍，每一次回顾都是一次对目标的强化，这种强化，会很大程度上提升我们的目标感，不断提醒我们朝着正确的方向前进。&lt;/p&gt;\n&lt;h2 id=\&#34;第二方面就是每天吃青蛙的复盘\&#34;&gt;第二方面，就是每天吃青蛙的复盘&lt;/h2&gt;\n&lt;p&gt;如：每天早上会开一个5分钟的青蛙早会，内容很简单，就是每个人说一下昨天的青蛙吃的如何，今天的青蛙计划是什么。&lt;/p&gt;\n&lt;p&gt;你也可以给自己&lt;strong&gt;每天设定一个复盘的固定化流程&lt;/strong&gt;，只需要几分钟的时间，来回顾自己吃青蛙的情况，这种复盘会让自己对0KR的进度保持足够的觉知，而不至于迷失在繁忙的工作中。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;2g6RmtDe4&#34;,&#34;abstract&#34;:&#34;&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2566e89.jpg\&#34; alt=\&#34;思维导图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;设定晨间okr三只青蛙\&#34;&gt;设定晨间OKR三只青蛙&lt;/h1&gt;\n&lt;p&gt;装瓶理论，核心就是说，我们在做事的时候，要&lt;strong&gt;优先利用大块的时间，去处理那些重要的、复杂的事情，也就是那些大石块，然后利用一些间隙去完成那些小事情&lt;/strong&gt;，从而提升我们的整体行动效率。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;4个核心步骤，构建你的专属「自律行动流」&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-10-30 00:05:00&#34;,&#34;dateFormat&#34;:&#34;2021-10-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/2g6RmtDe4/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:255000,&#34;words&#34;:1260,&#34;minutes&#34;:5},&#34;description&#34;:&#34;\n设定晨间OKR三只青蛙\n装瓶理论，核心就是说，我们在做事的时候，要优先利用大块的时间，去处理那些重要的、复杂的事情，也就是那些大石块，然后利用一些间隙去完成那些小事情，从而提升我们的整体行动效率。\n\n每天早上，到了办公室，先思考:今天对于...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%BE%E5%AE%9A%E6%99%A8%E9%97%B4okr%E4%B8%89%E5%8F%AA%E9%9D%92%E8%9B%99\&#34;&gt;设定晨间OKR三只青蛙&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A7%8D%E6%A4%8Dokr%E4%B8%93%E6%B3%A8%E6%A3%AE%E6%9E%97\&#34;&gt;种植OKR专注森林&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%8C%E6%8F%A1%E5%90%83%E6%8B%BF%E5%8D%A1%E8%A6%81%E5%9B%9B%E5%AD%97%E8%AF%80\&#34;&gt;掌握“吃拿卡要”四字诀&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%83\&#34;&gt;“吃”&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8B%BF\&#34;&gt;“拿”&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%A1\&#34;&gt;“卡”&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8C%81%E7%BB%AD%E9%AB%98%E9%A2%91%E5%A4%8D%E7%9B%98%E8%BF%BD%E8%B8%AA\&#34;&gt;持续高频复盘追踪&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%B8%80%E6%96%B9%E9%9D%A2%E6%98%AFokr%E5%9C%A8%E8%87%AA%E5%B7%B1%E5%BF%83%E4%B8%AD%E7%9A%84%E4%B8%8D%E6%96%AD%E5%BC%BA%E5%8C%96\&#34;&gt;第一方面，是OKR在自己心中的不断强化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AC%AC%E4%BA%8C%E6%96%B9%E9%9D%A2%E5%B0%B1%E6%98%AF%E6%AF%8F%E5%A4%A9%E5%90%83%E9%9D%92%E8%9B%99%E7%9A%84%E5%A4%8D%E7%9B%98\&#34;&gt;第二方面，就是每天吃青蛙的复盘&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;自律动机从哪里来?最重要、也是最强悍的自律动机，来源于我们的人生使命和目标。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2542a03.jpg\&#34; alt=\&#34;思维导图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;如何最大限度地激发我们的自我驱动力，就是&lt;strong&gt;通过撰写自己的「人生基本法」&lt;/strong&gt;，找到我们的人生方向和目标，找到那个我们愿意为之奋斗一生的目标，支撑着我们向目标冲刺。&lt;br&gt;\n「人生基本法」是由四个重要的支柱，或者说四个步骤组成的，包括:&lt;/p&gt;\n&lt;h3 id=\&#34;确定你的人生使命\&#34;&gt;确定你的人生使命&lt;/h3&gt;\n&lt;p&gt;所谓人生使命，就是你来到这个世界后，最终为之奋斗的东西，它是你和这个世界产生链接的方式，它能够让你在这个世界上产生的独特的意义与价值。&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;三星:为人类社会作贡献\n苹果:让每人拥有一台计算机\n迪斯尼公司:使人们过得快活\n华为:丰富人们的沟通和生活\n京东:让生活变得简单快乐\n阿里巴巴:让天下没有难做的生意\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/Ricky_Shao/upic_upload/raw/master/oss/2021%2010%2027%20image-20211027001723807%20.png\&#34; alt=\&#34;image-20211027001723807\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;**「3小时追梦计划」，帮助大家找到自己的人生使命: **&lt;/p&gt;\n&lt;p&gt;具体的方法，就是给自己找出大约3个小时的时间，而且是不被打扰的状态，在白纸上逐条写下自己的渴望与梦想，不断不断地写，直到有一条能让你哭出来，此时你可能就找到了自己心灵深处的人生使命。&lt;/p&gt;\n&lt;h3 id=\&#34;确定你的人生目标\&#34;&gt;确定你的人生目标&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;身体：早睡早起、健康饮食、保持健身、精力满满，这些都可以作为身体维度上的目标。&lt;/li&gt;\n&lt;li&gt;智力：目标也可以体现为比如“每日读书”，或者“给自己设定阶段性的学习任务”再或者“每年都有一个新的研究课题”等等。&lt;/li&gt;\n&lt;li&gt;情感：这里可以包括亲情、爱情、友情以及各种人际关系，你希望可以达成什么样的目标状态。&lt;/li&gt;\n&lt;li&gt;财富：不应该是标准答案，每个人的财富目标都是不同的，因为每个人的人生使命是有区别的。&lt;/li&gt;\n&lt;li&gt;人生意义：这里给大家推荐一种最具有操作性的思考维度，就是根据你的人生角色，来找到你在不同角色下的人生意义，这个意义翻译过来，就是你想在这个维度下，变成一个什么样的人。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;确定你的价值观或原则\&#34;&gt;确定你的价值观或原则&lt;/h3&gt;\n&lt;p&gt;所谓价值观，就是你在做各种选择的时候，哪些是应该做的，哪些是不应该做的，哪些是重要的，哪些是不重要的。&lt;br&gt;\n比如，极度开放、积极主动、实现双赢、真诚友善等等，这些都可以作为我们的价值观或者原则。&lt;/p&gt;\n&lt;h3 id=\&#34;确定你的人生策略\&#34;&gt;确定你的人生策略&lt;/h3&gt;\n&lt;p&gt;所谓人生策略，就是你想要达到以上提到的目标，需要做些什么。&lt;br&gt;\n比如，你要实现财富自由，是不是应该学习相应的知识，开展相应的投资实践?比如你要获得家庭幸福，是不是应该学会沟通的艺术?这些都是我们的人生策略。&lt;/p&gt;\n&lt;h2 id=\&#34;关于人生基本法\&#34;&gt;关于人生基本法&lt;/h2&gt;\n&lt;p&gt;第一，「人生基本法」不是一天写成的，它需要你不断去思考、打磨和更新。这一周完成这项成果之后，并不代表这件事结来了，而是要不断地去思考、打磨和修正的。&lt;/p&gt;\n&lt;p&gt;第二，「人生基本法」在不同的人生阶段，必然会出现变化。你想想看，你在小学时候的人生观和现在，是不是完全不同，再过十年，你的人生基本法一定又会出现巨大的变化。&lt;br&gt;\n第三，「人生基本法」既包括使命、目标，也包括原则、策略。不要过于纠结于他的形式，他可能是你一生要追求的目标，比如实现财务自由;也可能是你在为人处世时必须要遵守的原则，比如为人诚信。最重要的是，你开始用“以终为始”的理念，来思考自己的人生意义，梳理自己的人生目标，完成这个思考过程，对于大多数人来说，都已经是一次认知上的巨大突破了。&lt;/p&gt;\n&lt;h2 id=\&#34;人生基本法模板\&#34;&gt;《人生基本法》模板&lt;/h2&gt;\n&lt;h3 id=\&#34;一-人生使命\&#34;&gt;一、人生使命&lt;/h3&gt;\n&lt;p&gt;(你愿意为之奋斗一生的事情是什么?)&lt;/p&gt;\n&lt;p&gt;[撰写指导]&lt;/p&gt;\n&lt;p&gt;“每个人都有一个觉醒期,但觉醒的早晚决定个人的命运。”一一路遥&lt;br&gt;\n思考人生使命，就是在唤醒沉睡的自己。&lt;br&gt;\n寥寥几句话，却能让你热血沸腾。人人都有独特的人生使命，只是有的人已经找到，有的人还在追寻，但一定有那么一件事，是能够让你感受到浓厚的使命感的。&lt;/p&gt;\n&lt;p&gt;撰写「人生使命」部分，不必过于纠结。可能在现阶段想破头都没有找到让自己百分百满意的使命，但没关系，把那个你认为已经是现阶段的最佳答案写下来，未来不断寻找，持续调整，总会找到满意的答案。&lt;/p&gt;\n&lt;h3 id=\&#34;二-人生目标\&#34;&gt;二、人生目标&lt;/h3&gt;\n&lt;p&gt;(你希望自己变成什么样的人，获得什么样的成就?)&lt;/p&gt;\n&lt;p&gt;[撰写指导]&lt;br&gt;\n建议从富足人生的5个维度，来撰写自己的人生目标。每个维度下，也可以做更细维度的划分，这个过程，将会更加全面深刻地剖析，“你想要的人生，到底是什么样子的”。&lt;br&gt;\n相信我，绝大多数人，从来没有花时间认真思考过这个问题，因为它看起来太复杂，太庞大，太虚无缥缈了。但任何一个目标的实现，都不是碰巧出来的，而是经过持续深入的思考，持续不断的践行，才得以实现的。&lt;br&gt;\n撰写「人生目标」部分，需要发挥你的想象力，从不同维度去描绘你的未来，这些目标或许一辈子都无法实现，但如果你连确定目标的勇气都没有，又怎么可能实现它呢?&lt;/p&gt;\n&lt;p&gt;富足人生五要素:&lt;br&gt;\n身体:&lt;br&gt;\n智力:&lt;br&gt;\n情感:&lt;br&gt;\n财富:&lt;br&gt;\n人生意义:&lt;/p&gt;\n&lt;h3 id=\&#34;三-人生原则价值观\&#34;&gt;三、人生原则(价值观)&lt;/h3&gt;\n&lt;p&gt;不同的人生原则，决定了不同人生命运。&lt;br&gt;\n撰写「人生原则」时，不用顾虑太多的逻辑结构，只需要把你觉得自己最希望坚持的价值观写下来即可，同时这个人生原则，也需要不断去补充和更新。&lt;/p&gt;\n&lt;h2 id=\&#34;四-人生策略可选\&#34;&gt;四、人生策略(可选)&lt;/h2&gt;\n&lt;p&gt;(为了达成目标，你需要做哪些事情?)&lt;br&gt;\n人生策略，是为了达成我们的人生使命和目标。&lt;br&gt;\n撰写「人生策略」时，可以对照着你的人生目标，去思考想要完成这个目标，你需要做的事情。人生策略的撰写，一定是一个大工作，在「人生基本法J中可以省略，但我希望大家在未来的日子里，能够不断地去补充完善;&lt;br&gt;\n只有人生目标是不够的，还需要你去绘制自己的人生地图，而人生策略就是你需要的那份地图。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;Ajz-sKXZ4&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;自律动机从哪里来?最重要、也是最强悍的自律动机，来源于我们的人生使命和目标。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://www.hualigs.cn/image/62cc1c2542a03.jpg\&#34; alt=\&#34;思维导图\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;title&#34;:&#34;四个步骤找到人生使命和目标&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-10-27 00:09:24&#34;,&#34;dateFormat&#34;:&#34;2021-10-27&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/Ajz-sKXZ4/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:365000,&#34;words&#34;:1823,&#34;minutes&#34;:7},&#34;description&#34;:&#34;自律动机从哪里来?最重要、也是最强悍的自律动机，来源于我们的人生使命和目标。\n\n\n如何最大限度地激发我们的自我驱动力，就是通过撰写自己的「人生基本法」，找到我们的人生方向和目标，找到那个我们愿意为之奋斗一生的目标，支撑着我们向目标冲刺。\n「...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84%E4%BA%BA%E7%94%9F%E4%BD%BF%E5%91%BD\&#34;&gt;确定你的人生使命&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84%E4%BA%BA%E7%94%9F%E7%9B%AE%E6%A0%87\&#34;&gt;确定你的人生目标&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84%E4%BB%B7%E5%80%BC%E8%A7%82%E6%88%96%E5%8E%9F%E5%88%99\&#34;&gt;确定你的价值观或原则&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A1%AE%E5%AE%9A%E4%BD%A0%E7%9A%84%E4%BA%BA%E7%94%9F%E7%AD%96%E7%95%A5\&#34;&gt;确定你的人生策略&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E4%BA%BA%E7%94%9F%E5%9F%BA%E6%9C%AC%E6%B3%95\&#34;&gt;关于人生基本法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%BA%E7%94%9F%E5%9F%BA%E6%9C%AC%E6%B3%95%E6%A8%A1%E6%9D%BF\&#34;&gt;《人生基本法》模板&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-%E4%BA%BA%E7%94%9F%E4%BD%BF%E5%91%BD\&#34;&gt;一、人生使命&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C-%E4%BA%BA%E7%94%9F%E7%9B%AE%E6%A0%87\&#34;&gt;二、人生目标&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89-%E4%BA%BA%E7%94%9F%E5%8E%9F%E5%88%99%E4%BB%B7%E5%80%BC%E8%A7%82\&#34;&gt;三、人生原则(价值观)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9B-%E4%BA%BA%E7%94%9F%E7%AD%96%E7%95%A5%E5%8F%AF%E9%80%89\&#34;&gt;四、人生策略(可选)&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;&lt;img src=\&#34;https://gitee.com/Ricky_Shao/upic_upload/raw/master/oss/2021%2010%2023%20sPWZfO%20.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;strong&gt;&amp;quot;把自律当做一种目标，是对自律本身最大的误解。&amp;quot;&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;为什么会间歇性自律\&#34;&gt;为什么会间歇性自律&lt;/h2&gt;\n&lt;p&gt;你在最开始阶段，对自律这件事本身的理解，就出现了严重的偏差。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;首先你的认知、你的立场、你的选择、你的前期准备是正确的，&lt;strong&gt;如果你在认知上就出现了偏差&lt;/strong&gt;，那就相当于走上了一条注定会失败的路，在错误的道路上前行，无论多么努力都是徒劳。&lt;br&gt;\n其实，类似的问题还有很多。我们会发现:如果把自律看做我们的目标，会很容易陷入一种极端的**“只执行不思考”**的状态，只顾低头赶路，却忘记了思考和辨别自己的人生方向。&lt;br&gt;\n&lt;strong&gt;总结起来就是:错误的目标+自律的行动=灾难。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;为了自律而自律，就像在填一个深不见底的大坑，遥遥无期，极其痛苦。&lt;/strong&gt;&lt;br&gt;\n当你一直在做一件永远看不到头的事情的时候，你是很难坚持下来的。&lt;/p&gt;\n&lt;h2 id=\&#34;最底层的自律动机是人生使命和目标\&#34;&gt;最底层的自律动机是人生使命和目标&lt;/h2&gt;\n&lt;p&gt;自律，意味着你需要以&lt;strong&gt;极度开放的心态、积极主动的态度，去面对痛苦、承担责任、解决问题&lt;/strong&gt;。自律，是帮助我们实现人生目标的&lt;strong&gt;方法、路径和工具&lt;/strong&gt;。几乎所有的目标实现，都需要你付诸自律的行动，才能够达成。&lt;br&gt;\n了解完自律的定义后，那么，能够让我们持续不断地保持自律，最底层的动机来源是什么呢?&lt;br&gt;\n我们都知道，任何事情都离不开两个范畴。一个是“道”，一个是“术”，所谓**“道”，是最宏观的原则、方向，所谓“术”是我们微观的方法、策略。**&lt;br&gt;\n而我们经常会花太多时间纠结和痛苦于自律的“术”，却从来没有认真思考过，自律的“道”。&lt;br&gt;\n自律的道，就是我们的人生使命和目标。&lt;br&gt;\n那么，问题又来了，&lt;strong&gt;人生使命和目标&lt;/strong&gt;又是什么呢?&lt;br&gt;\n有的人渴望事业有成、实现财务自由，有的人希望家庭幸福，美满一生，有的人可能就想着每天开心就好。&lt;br&gt;\n我试着对人生目标做了一个简单的提炼。我理解，无论何种目标，也无论有多少维度的目标，我们的人生目标都可以用一句话来解释，那就是:&lt;br&gt;\n你这一辈子，&lt;strong&gt;想达到什么样的目标?想成为什么样的人?想获得什么样的成就?&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;思考一种人生状态富足人生\&#34;&gt;思考一种人生状态:富足人生&lt;/h2&gt;\n&lt;p&gt;仅仅是单一维度的人生目标，对于我们整个人生来说，是极不稳定的，甚至说是摇摇欲坠的。因为，我们的人生本身就是漫长的、复杂的、充满不确定性的。&lt;br&gt;\n因此，我们在思考人生目标的时候，要有&lt;strong&gt;多维度的综合思维，从多个方面来组合我们的人生目标&lt;/strong&gt;，才能更加全面和稳定，我们的自律动机才足够坚定。&lt;br&gt;\n富足人生，是指我们的人生无论在任何一个维度或者要素下，都能够获得一种丰富、充盈、满足的体验。&lt;br&gt;\n富足的人生目标有五个纬度：&lt;strong&gt;第一:身体、第二:智力、第三:情感、第四:财富、第五:人生意义。&lt;/strong&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;-WxTzW7cO&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;&lt;img src=\&#34;https://gitee.com/Ricky_Shao/upic_upload/raw/master/oss/2021%2010%2023%20sPWZfO%20.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n&lt;strong&gt;&amp;quot;把自律当做一种目标，是对自律本身最大的误解。&amp;quot;&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;为什么会间歇性自律\&#34;&gt;为什么会间歇性自律&lt;/h2&gt;\n&lt;p&gt;你在最开始阶段，对自律这件事本身的理解，就出现了严重的偏差。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;为什么真正自律的人，从来都不把自律当目标?&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2021-10-23 00:03:38&#34;,&#34;dateFormat&#34;:&#34;2021-10-23&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/-WxTzW7cO/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:174000,&#34;words&#34;:869,&#34;minutes&#34;:3},&#34;description&#34;:&#34;\n&amp;quot;把自律当做一种目标，是对自律本身最大的误解。&amp;quot;\n为什么会间歇性自律\n你在最开始阶段，对自律这件事本身的理解，就出现了严重的偏差。\n\n首先你的认知、你的立场、你的选择、你的前期准备是正确的，如果你在认知上就出现了偏差，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%97%B4%E6%AD%87%E6%80%A7%E8%87%AA%E5%BE%8B\&#34;&gt;为什么会间歇性自律&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%80%E5%BA%95%E5%B1%82%E7%9A%84%E8%87%AA%E5%BE%8B%E5%8A%A8%E6%9C%BA%E6%98%AF%E4%BA%BA%E7%94%9F%E4%BD%BF%E5%91%BD%E5%92%8C%E7%9B%AE%E6%A0%87\&#34;&gt;最底层的自律动机是人生使命和目标&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%9D%E8%80%83%E4%B8%80%E7%A7%8D%E4%BA%BA%E7%94%9F%E7%8A%B6%E6%80%81%E5%AF%8C%E8%B6%B3%E4%BA%BA%E7%94%9F\&#34;&gt;思考一种人生状态:富足人生&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h3 id=\&#34;本文所需的工具ksweb可道云termux\&#34;&gt;本文所需的工具：ksweb，可道云，termux&lt;/h3&gt;\n&lt;h3 id=\&#34;网站管理文件方法\&#34;&gt;网站管理文件方法：&lt;/h3&gt;\n&lt;p&gt;从&lt;a href=\&#34;https://kodcloud.com/\&#34;&gt;可道云官网&lt;/a&gt;下好源码解压到你用ksweb搭建的文件夹（参考我之前发的文章&lt;a href=\&#34;http://ricky.shineteens.com/index.php/archives/13/\&#34;&gt;旧手机搭建网站&lt;/a&gt;）然后建议文件夹改个好记的名字，然后进入&lt;a href=\&#34;http://localhost/\&#34;&gt;http://localhost&lt;/a&gt;:8080/你文件夹的名字。改个密码就完事了！以后你就可以随时访问这个目录访问你手机的文件夹了，只要你ksweb不被后台杀掉的话&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://img.imgdb.cn/item/606a0d218322e6675ce6b2c2.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;aira2搭建\&#34;&gt;aira2搭建&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;pkg install aira2\naria2c --enable-rpc --rpc-listen-all\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果你想在浏览器上访问你的aira2的话，可以执行以下代码 先安装nodejs环境&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;pkg install nodejs\ngit clone https://github.com/ziahamza/webui-aria2.git\ncd webui-aria2\nnode node-server.js\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;利用ftp访问文件\&#34;&gt;&lt;img src=\&#34;https://img.imgdb.cn/item/606a0cd28322e6675ce68832.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n利用ftp访问文件&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;ES浏览器——网络——从PC访问，然后在电脑上的资源管理器输入它给你的地址就好了，也可以在“增加一个网络位置”中输入那个地址&lt;br&gt;\n优点：&lt;br&gt;\n方便简单，对小白极其友好&lt;br&gt;\n缺点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;手机后台多跑一个应用，除非你打算下次临时访问时去打开&lt;/li&gt;\n&lt;li&gt;如果映射到外网，没有用户名密码意味着别人输了地址就可以操作你手机文件了&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;KSweb上的ftp创建一个用户，然后电脑访问你的手机地址，一般为192.168.0.x:2121(x为随机地址，可以到路由器后台看，也可以在termux输入ipconfig -a查看，端口不一定是2121，具体看ksweb的主页怎么显示的），输入用户名密码就可以看见你手机的文件夹了&lt;br&gt;\n优点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;网站在ftp就在，只要ksweb不死你就可以随时访问&lt;/li&gt;\n&lt;li&gt;有用户名密码，安全性很强&lt;br&gt;\n缺点：&lt;br&gt;\n除了有些小白可能操作半天外还真没什么缺点了，建议优先考虑&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://img.imgdb.cn/item/606a0cc28322e6675ce67ee3.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;另外我的图片是从电脑访问处截图的，所以请不要模仿上面的地址。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;jiu-shou-ji-gai-zao-ji-hua-da-jian-aira2yi-ji-ji-qi-bian-jie-de-wang-ye-guan-li-wen-jian-fang-fa&#34;,&#34;abstract&#34;:&#34;&lt;h3 id=\&#34;本文所需的工具ksweb可道云termux\&#34;&gt;本文所需的工具：ksweb，可道云，termux&lt;/h3&gt;\n&lt;h3 id=\&#34;网站管理文件方法\&#34;&gt;网站管理文件方法：&lt;/h3&gt;\n&lt;p&gt;从&lt;a href=\&#34;https://kodcloud.com/\&#34;&gt;可道云官网&lt;/a&gt;下好源码解压到你用ksweb搭建的文件夹（参考我之前发的文章&lt;a href=\&#34;http://ricky.shineteens.com/index.php/archives/13/\&#34;&gt;旧手机搭建网站&lt;/a&gt;）然后建议文件夹改个好记的名字，然后进入&lt;a href=\&#34;http://localhost/\&#34;&gt;http://localhost&lt;/a&gt;:8080/你文件夹的名字。改个密码就完事了！以后你就可以随时访问这个目录访问你手机的文件夹了，只要你ksweb不被后台杀掉的话&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;旧手机改造计划——搭建aira2，以及极其便捷的网页管理文件方法&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2020-02-05 02:52:52&#34;,&#34;dateFormat&#34;:&#34;2020-02-05&#34;,&#34;feature&#34;:&#34;https://img.imgdb.cn/item/606a0da78322e6675ce6f899.jpg&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/jiu-shou-ji-gai-zao-ji-hua-da-jian-aira2yi-ji-ji-qi-bian-jie-de-wang-ye-guan-li-wen-jian-fang-fa/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:110000,&#34;words&#34;:506,&#34;minutes&#34;:2},&#34;description&#34;:&#34;本文所需的工具：ksweb，可道云，termux\n网站管理文件方法：\n从可道云官网下好源码解压到你用ksweb搭建的文件夹（参考我之前发的文章旧手机搭建网站）然后建议文件夹改个好记的名字，然后进入http://localhost:8080/...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9C%AC%E6%96%87%E6%89%80%E9%9C%80%E7%9A%84%E5%B7%A5%E5%85%B7ksweb%E5%8F%AF%E9%81%93%E4%BA%91termux\&#34;&gt;本文所需的工具：ksweb，可道云，termux&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95\&#34;&gt;网站管理文件方法：&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#aira2%E6%90%AD%E5%BB%BA\&#34;&gt;aira2搭建&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A9%E7%94%A8ftp%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6\&#34;&gt;!&lt;br&gt;\n利用ftp访问文件&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;努力分享一些好玩实用的内容，虽然不算多！&lt;/p&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;p&gt;立志实现财富自由的Coder～&lt;/p&gt;\n&lt;h2 id=\&#34;兴趣爱好\&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;\n&lt;p&gt;探索Github、学点有趣的东西、健身羽毛球那些……&lt;/p&gt;\n&lt;h2 id=\&#34;️技术栈\&#34;&gt;🤹‍♂️技术栈&lt;/h2&gt;\n&lt;p&gt;Vue 🌟🌟🌟🌟🌟&lt;br&gt;\nPython 🌟🌟🌟🌟🌟&lt;br&gt;\nMogoDB 🌟🌟🌟&lt;br&gt;\nMySQL 🌟🌟🌟&lt;br&gt;\nC++ 🌟🌟🌟&lt;br&gt;\nDocker🌟🌟🌟&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&lt;p&gt;Email:veithly@163.com&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-25 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:19000,&#34;words&#34;:89,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n努力分享一些好玩实用的内容，虽然不算多！\n👨‍💻 博主是谁\n立志实现财富自由的Coder～\n⛹ 兴趣爱好\n探索Github、学点有趣的东西、健身羽毛球那些……\n🤹‍♂️技术栈...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B4%E8%B6%A3%E7%88%B1%E5%A5%BD\&#34;&gt;⛹ 兴趣爱好&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%EF%B8%8F%E6%8A%80%E6%9C%AF%E6%A0%88\&#34;&gt;🤹‍♂️技术栈&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;\n✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;br&gt;\n😨讲真，这又是一次博客搬迁，从群晖偶然挂了我就觉得还是要找个可靠的地方记录文字，别再瞎整一些乱七八糟的玩意来浪费时间了。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;🤔再三思量后，我打算使用静态页面来配置搭建博客，之前php+mysql的cms像wordpress和typecho虽然简单无脑，但出事后重整太难受了。在做出静态页面的选择时我考虑过hexo,hugo，但还是偶然发现Gridea这个神奇的玩意，虽然说好像操作比较无脑，但考虑到我折腾hexo一直支棱不起来连发篇文章都费劲就觉得无脑的东西也挺好的。多花点时间看几篇paper，学学东西不香吗？&lt;br&gt;\n😏github的page功能访问确实蛋疼，其他的仓库又不太支持，但还好我域名备案了，这就可以每月嫖腾讯的10GB CDN，访问速度还是挺ok的，至少比之前白嫖frp时不时宕机要舒服点。&lt;br&gt;\n🤒用什么CSDN、知乎、简书记录东西也不是不行，但我还是不太喜欢自己的内容掌控在别的网站上，写个东西还要被放别人的广告白嫖挺不爽的。但毕竟人家流量是有的，等我有精力还是会考虑做个同步的玩意一键多平台分发。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;hello-gridea&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;\n✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;br&gt;\n😨讲真，这又是一次博客搬迁，从群晖偶然挂了我就觉得还是要找个可靠的地方记录文字，别再瞎整一些乱七八糟的玩意来浪费时间了。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Hello Gridea&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Gridea&#34;,&#34;slug&#34;:&#34;hgp_pcWhT&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://ricky.shineteens.com/tag/hgp_pcWhT/&#34;}],&#34;date&#34;:&#34;2018-12-12 00:00:00&#34;,&#34;dateFormat&#34;:&#34;2018-12-12&#34;,&#34;feature&#34;:&#34;https://ricky.shineteens.com/post-images/hello-gridea.png&#34;,&#34;link&#34;:&#34;https://ricky.shineteens.com/post/hello-gridea/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:80000,&#34;words&#34;:388,&#34;minutes&#34;:2},&#34;description&#34;:&#34;👏  欢迎使用 Gridea ！\n✍️  Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...\n😨讲真，这又是一次博客搬迁，从群晖偶然挂了我就觉得还是要找个可靠的地方记录文字，别再瞎整一些...&#34;,&#34;toc&#34;:&#34;&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/peace.js"></script>


<script src=" /media/js/cool.js"></script>


</html>